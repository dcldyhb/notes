<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 数据结构笔记

## 引言

### 算法与数据结构

数据结构的研究内容

1. 数据之间的**逻辑关系**，以及这种关系对应的操作
2. **储存实现**：数据及逻辑关系的存储
3. **运算实现**：具体存储模式下，运算的实现，即**算法**

#### 数据的逻辑结构

- **集合结构**
  次序任意，元素之间除了**同处于一个集合内**之外没有任意其他的关系.
- **线性结构**
  数据元素的**有序**排列，除了头尾的元素外其余元素都有一个前趋和一个后继.
- **树形结构**
  除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.
- **图形结构**
  每个元素的前趋和后继数量都不限
  ![FourLogicalDataStructures](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png)

#### 数据结构的操作

- **创造**
- **清除**
- **插入**
- **删除**
- **更新**
- **搜索**
- **访问**
- **遍历（traverse）**：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次
- 每一种数据结构的特定操作

数据结构的**五大类**：构建类、属性类、数据操纵类、遍历类、特定类

### 存储实现

### 算法分析

#### 时间复杂度的概念

- 是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，$T(n)$
- 算法的时间复杂度也与被处理的数据分布有关
- 算法的时间复杂度分为三种
  - 最好的
  - 最坏的
  - 平均

#### 算法运算量的计算

#### 渐进时间复杂度

#### 算法的优化

#### 空间复杂度的概念

- 渐进的空间复杂度
- 一般只考虑**辅助**空间的占用情况
- 空间复杂度一般按照最坏情况处理
- 空间复杂度的计算、表示方法与时间复杂度相同

### 面向对象方法

#### 类模板的定义

类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型

##### 定义格式

```cpp
template <class 标识符>
class 类名
{
    // 类成员声明
};
```

##### 类定义的一般格式

```cpp
class 类名
{
  [private:]
    // 私有数据成员和成员函数声明
  public:
    // 公有数据成员和成员函数声明
};
```

#### 虚函数

- 在基类中用关键词 `virtual` 声明的成员函数，并在派生类中重新定义的函数称为虚函数
- 虚函数的一般格式
  
  ```cpp
  virtual 返回类型 函数名(参数表)
  {
    // 函数体
  };
  ```

- 在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（**继承**）
- 当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数
- 虚函数在基类中有默认实现，派生类可以选择性地对其进行重写

#### 纯虚函数

- 是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数
- 纯虚函数的一般形式
  
  ```cpp
  virtual 返回类型 函数名(参数表) = 0;
  ```

- 纯虚函数在基类中无实现，只有函数原型，派生类必须实现

#### 抽象类

- 如果一个类中**至少有一个纯虚函数**，那么这个类就是抽象类
- 抽象类只能作为其他类的基类，不能建立抽象类的对象

#### 继承

- 在已有类的基础上建立新的类
- 基类（父类）和派生类（子类）
- 继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题

##### 派生类

- 一般格式

  ```cpp
  class 派生类名 : [派生方式] 基类名
  {
    // 派生类新增的数据成员和成员函数
  };
  ```

- 派生方法
  - 公有派生：`public`
  - 私有派生：`protected`
  - 保护派生：`private`
- `class` 默认是 `private` 继承， `struct` 默认是 `public` 继承

###### 派生类对基类成员的访问性

|  |`public` 继承|`protected` 继承|`private` 继承|
|:---:|:---:|:---:|:---:|
|`public` 成员|public|protected|private|
|`protected` 成员|protected|protected|private|
|`private` 成员|不可访问|不可访问|不可访问|

#### 类定义时常见的两种`const`用法

以函数 `int search(constelemType&x) const` 为例

1. 修饰参数 `x` 的 `const` 和 `&` 组合
   - `const` 修饰参数 `x`，表示函数 `search` 不会修改参数 `x` 的值
   - 参数加了 `const` 之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数 `x` 的修改操作，若有则会报错
   - **如果确认函数实现中不准备改变 `x` 的值，养成加 `const`的习惯**
   - `&` 修饰参数 `x`，表示参数 `x` 是引用传递，即传递的是实参的地址，而不是实参的值
2. 修饰函数 `search` 的 `const`
   - 参数表后的 `const` 保护调用对象的值不被修改
   - 如果没有 `const` 修饰，那么在调用对象为 `const` 类型时，不能调用该函数
     常量对象只能调用参数表后带 `const` 的常量成员函数

## 线性表

### 线性表的定义

#### 线性表的概念

- 是一种**线性结构**，是由 $n(n\geq0)$ 个数据元素组成的有限序列
- 除了首节点 $A_0$ 和尾节点 $A_{n-1}$ 之外，每个节点 $A_i$ 有且仅有一个前趋 $A_{i-1}$ 和一个后继 $A_{i+1}$
- $A_0$ 只有后趋，$A_{n-1}$ 只有前趋

  ![线性表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png)

#### 表的基本操作

- **创建 `create()`**：创建一个空的线性表
- **清除 `clear()`**：删除线性表中的所有数据元素
- **长度 `length()`**：返回线性表的长度
- **插入 `insert(i,x)`**：在线性表的第 $i$ 个位置插入一个新元素 `x`
- **删除 `remove(i)`**：删除线性表中第 $i$ 个位置的元素
- **搜索 `search(x)`**：在线性表中搜索元素 `x`，返回其位置
- **访问 `visit(i)`**：返回线性表中第 $i$ 个位置的元素
- **遍历 `traverse()`**：依次访问线性表中的每个元素

#### 线性表的抽象类

```cpp
template <class elemType>
class list
{
  public:
    virtual void clear() = 0;                           // 清空
    virtual int length() const = 0;                     // 返回长度
    virtual void insert(int i, const elemType &x) = 0;  // 插入
    virtual void remove(int i) = 0;                     // 删除
    virtual int search(const elemType &x) const = 0;    // 搜索
    virtual elemType visit(int i) const = 0;            // 访问
    virtual void traverse() const = 0;                  // 遍历
    virtual ~list() {}                                  // 析构函数
};
```

- 抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现
- **抽象类无构造函数**

### 线性表的顺序实现

#### 顺序存储结构

- 节点存储在存储器的一块**连续**的空间中
- 节点依照逻辑顺序依次**存放**
- 节点存放的物理位置和逻辑顺序是对应的
- 线性表的顺序实现通常被称为**顺序表**

#### 顺序表类的定义

```cpp
template <class elemType>
class seqList : public list<elemtype>
{
  private:
    elemType *data;
    int currentLength;
    int maxSize;
    void doubleSpace();
  public:
    seqList(int initSize = 10);             // 构造函数
    ~seqList()                              // 析构函数
    {
      delete[] data;
    }
    void clear()                            //清空
    {
      currentLength = 0;
    }
    int length() const                      // 返回长度
    {
      return currentLength;
    }
    void insert(int i, const elemType &x);  // 插入
    void remove(int i);                     // 删除
    int search(const elemType &x) const;    // 搜索
    elemType visit(int i) const;            // 访问
    void traverse() const;                  // 遍历
};
```

#### 函数实现

##### 构造函数

- 定义对象时自动调用，用于初始化对象的数据成员
- **函数名与类名相同**
- 可以有任何类型的参数，也可以没有参数，但是**不能有返回类型**，所以定义时不能说明类型
- 若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数

```cpp
template<class elemType>
seqList<elemType>::seqList(int initSize)
{
  data = new elemType[initSize];
  maxSize = initSize;
  currentLength = 0;
}
```

![seqList](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png)

##### 析构函数

- 用于释放对象所占用的内存空间，由编译系统自动调用
- **函数名与类名相同，前面加 `~`**
- 不能有参数，也不能有返回类型
- 若没有给出析构函数，编译器会自动生成一个默认的析构函数
- 不是所有类都要由析构函数
- 一般在构造函数中动态申请内存的，必须有析构函数

```cpp
~seqList()
{
  delete[] data;
}  //在线性表的类中已经实现了，不用到类外定义
```

##### 顺序表的运算实现

###### `search`

从数组的第0个下标变量开始一次往后检查每一个元素，直到找到 `x` 或找到表尾

```cpp
template<class elemType>
int seqList<elemType>::search(const elemType &x) const
{
  int i ;
  for (i = 0 ; i < currentLength && data[i] != x ; ++i);
  if (i == currentLength) 
  {
    return -1;
  }
  else
  {
    return i;
  }
}
```

###### `traverse`

从数组的第0个下标变量开始一次往后访问每一个元素，直到表尾

```cpp
template<class elemtype>
void seqList<elemType>::traverse() const
{
  for (int i = 0 ; i < currentLength ; ++i)
  {
    cout << data[i] << ' ';
  }
}
```

###### `insert`

- 在第 `i` 个位置插入元素 `x`
- 若插入后表长超过 `maxSize`，则将 `maxSize` 扩大一倍

![seqList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png)

```cpp
template<class elemType>
void seqList<elemType>::insert(int i , const elemType &x)
{
  if (currentSize = maxSize)
  {
    doubleSpace();
  }
  for (int j = currentLength ; j > i ; --j)
  {
    data[j] = data[j - 1];
  }
  data[i] = x;
  ++currentLength;
}
```

###### `doubleSpace` 操作的实现

- 重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区

![seqList::doublespace](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png)

```cpp
template<class elemType>
void seqList<elemType>::doublespace()
{
  elemtype *tmp = data;
  maxSize *= 2;
  data = new elemtype[maxSize];
  for (int i = 0 ; i < currentLength ; ++1)
  {
    data[i] = tmp[i];
  }
  delete[] tmp;
}
```

###### `remove`

![seqlist::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png)

```cpp
template<class elemType>
void seqList<elemType>::remove(int i)
{
  if (i < 0 ||i > currentlength)
  {
    throw OutOfBound();
  }
  for (int j = i ; j < currentlength -1 ; ++j)
  {
    data[j] = data[j + 1];
  }
  --currentLength;
}
```

### 线性表的链接存储

#### 单链表

- 每个节点附加指针字段，如 `next`，指向直接后继节点，最后一个节点的 `next` 指向 `nullptr`

![单链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png)

##### 头节点、头指针

- 在表头额外增加一个相同类型的特殊结点
- 不是线性表中的组成部分
- 头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化

![带头节点的单链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png)

##### 结点及其组成

- 链表的节点包含两个部分
  - 数据字段
    - 可以存储任何类型的数据，仍然使用 `elemType` 表示
  - 指针字段
    - 用于存储**后继节点**的地址值
  - 结点类型是链表专用的，可以设为内嵌类
  - 将节点类定义为 `struct` 方便链表类访问

##### 单链表类的定义

```cpp
template <class elemType>
class sLinkList:public list<elemtype>
{
  private:
    struct node                                    // 节点类
    {
      elemType data;
      node *next;
      node(const elemType &x , node *n = nullptr)
      {
        data = x;
        next = n;
      }
      node():next(nullptr){}
      ~node(){}
    };

    node *head;
    int currentLength;
    node *move(int i) const;
  public:
    sLinkList();
    ~sLinkList();
    void clear();
    int length() const
    {
      return currentLength;
    }
    void insert(int i , const elemType &x);
    void remove(int i);
    int search(const elemType &x) const;
    elemType visit(int i) const;
    void traverse() const;
};
```

##### 构造函数

![sLinklist](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png)

```cpp
template <class elemType>
sLinkList<elemType>::sLinkList()
{
  head = new node();
  currentLength = 0;
}
```

##### `clear`

- 将单链表变成一个空表
- 回收节点空间

![sLinkList::clear](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png)

```cpp
template <class elemType>
void sLinkList<elemType>::clear()
{
  node *p = head->next , *q;

  while (p != nullptr)        // 删除节点
  {
    q = p->next;
    delete p;
    p = q;
  }
  currentLength = 0;
}
```

##### `move`

- 返回第 $i$ 个元素的指针

```cpp
template <class elemType>
struct sLinkList<elemType>::node *sLinkList<elemType>::move(int i) const
{
  node *p = head;
  for (int j = 0 ; j < i ; ++j)
  {
    p = p->next;
  }
  return p;
}
```

##### `insert`

1. 指针 `p` 指向要插入的位置 `i` 的前一个节点
2. 申请一个新节点 `s`
3. 将 `s` 的 `next` 指向 `p` 的 `next`
4. 将 `p` 的 `next` 指向 `s`

![sLinkList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png)

```cpp
template <class elemType>
void sinkList<elemtype>::insert(int i , const elemType &x)
{
  if (i < 0 || i > currentLength)
  {
    throw OutOfBound();
  }
  node *p = move(i-1);
  node *s = new node(x , p->next);
  p->next = s;
  ++currentLength;
}
```

##### `remove`

1. 找到被删除节点的前一个节点 `pos`
2. 让 `delp` 指向被删除节点
3. 让 `pos` 的 `next` 指向 `delp` 的 `next`
4. 释放 `delp` 的空间

![sLinkList::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png)

```cpp
template <class elemType>
void sLinkList<elemType>::remove(int i)
{
  if (i < 0 || i >= currentLength)
  {
    throw OutOfBound();
  }
  node *pos = move(i-1);
  node *delp = pos->next;
  pos->next = delp->next;
  delete delp;
  --currentLength;
}
```

##### `search`

- 从头节点开始，依次访问每个节点，直到找到 `x` 或到达表尾

```cpp
template <class elemType>
int sLinkList<elemType>::search(const elemtype 7x) const
{
  node *p = head -> next;
  int i = 0;
  while (p != nullptr && p->data != x) // 访问每个节点，条件的顺序不能交换
  {
    p = p->next;
    ++i;
  }
  if (p == nullptr)
  {
    return -1;
  }
  else
  {
    return i;
  }
}
```

- 如果判定条件改为 `p->data != x && p != nullptr`，会在 `p` 为空时试图访问 `p->data`，导致访问空指针，从而产生未定义行为

##### `visit`

1. 找到第 `i` 个节点
2. 返回 `p->data`

```cpp
template <class elemType>
elemType sLinkList<elemType>::visit(int i) const
{
  if (i < 0 || i >= currentLength)
  {
    throw OutOfBound();
  }
  return move(i)->data;
}
```

##### `traverse`

```cpp
template <class elemType>
void sLinkList<elemType>::traverse() const
{
  node *p = head->next;
  while (p != nullptr)
  {
    cout << p->data << ' ';
    p = p->next;
  }
}
```

#### 双链表

- 每个节点有两个指针字段
  - `next` 指向直接后继节点
  - `prev` 指向直接前驱节点

##### 双链表的头尾节点

- 头节点
  - `prev` 指向 `nullptr`
  - `next` 指向首节点
- 尾节点 `tail`
  - `prev` 指向最后一个节点
  - `next` 指向 `nullptr`

![双链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png)

##### 双链表类的定义

```cpp
template <class elemType>
class dLinkList:public list<elemType>
{
  private:
    struct node                                                         // 双链表中的节点类
    {
      elemType data;
      node *next;
      node *prev;
      node(const elemType &x , node *p = nullptr , node *n = nullptr)
      {
        data = x;
        prev = p;
        next = n;
      }
      node():next(nullptr),prev(nullptr){}
      ~node(){}
    };
    node *head , *tail;                                                  // 头节点和尾节点
    int currentLength;                                                   // 当前长度
    node *move(int i) const;                                             // 返回第 i 个节点的指针
  public:
    dLinkList();
    ~dLinkList();
    void clear();
    int length() const
    {
      return currentLength;
    }
    void insert(int i , const elemType &x);
    void remove(int i);
    int search(const elemType &x) const;
    elemType visit(int i) const;
    void traverse() const;
};
```

##### 构造函数

- 申请头节点和尾节点

![dLinkList](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png)

```cpp
template <class elemType>
dLinkList<elemType>::dLinkList()
{
  head = new node();
  tail = new node();
  head->next = tail;
  tail->prev = head;
  currentLength = 0;
}
```

##### `insert`

1. 申请一个新节点 `tmp`，找到要插入的位置 `pos`
2. 将 `tmp` 的 `prev` 指向 `pos` 的 `prev`，`tmp` 的 `next` 指向 `pos`
3. 将 `pos` 的前一个结点的 `next` 指向 `tmp`
4. 将 `pos` 的 `prev` 指向 `tmp`

![dLinkList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png)

```cpp
template <class elemType>
void dLinkList<elemtype>::insert(int i ,const elemTypr &x)
[
  node *pos , *tmp;

  pos = move(i);
  temp = new node(x,pos -> prev , pos);
  pos->prev->next = tmp;
  pos->prev = tmp;

  ++currentLength;
]
```

##### `remove`

1. 找到要删除的节点 `pos`
2. 将 `pos` 的前一个节点的 `next` 指向 `pos` 的后一个节点
3. 将 `pos` 的后一个节点的 `prev` 指向 `pos` 的前一个节点

![dLinkList::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png)

```cpp
template <class elemType>
void dLinkList<elemType>::remove(int i)
{
  node *pos = move(i);

  pos->prev->next = pos->next;
  pos->next->prev = pos->prev;

  delete pos;
  --currentLength;
}
```

#### 单循环链表

- 一般单循环链表不带头节点

![单循环链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png)

#### 双循环链表

- 头结点中 `prev` 字段给出尾结点的地址，尾结点中 `next` 字段给出头结点的地址
- 一般也不设置头尾节点

## 栈

### 栈的定义

- 栈是一种特殊的线性表
- 只允许在一段进行插入和删除操作
- 先进后出（LIFO，Last In First Out）

![栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png)

#### 栈的基本操作

- **创建 `create()`**：创建一个空栈
- **进栈 `push(x)`**：将元素 `x` 压入栈顶
- **出栈 `pop()`**：删除栈顶元素并返回其值
- **访问栈顶元素 `top()`**：返回栈顶元素的值但是不删除
- **判断是否为空 `isEmpty()`**：若栈空返回 `true`，否则返回 `false`

#### 栈的抽象类

```cpp
template <class elemType>
class stack
{
  public:
    virtual void push(const elemType &x) = 0;       // 进栈
    virtual elemType pop() = 0;                     // 出栈
    virtual elemType top() const = 0;               // 访问栈顶元素
    virtual bool isEmpty() const = 0;               // 是否为空
    virtual ~stack() {}                             // 析构函数
};
```

### 栈的顺序实现

- 使用数组储存栈中的节点
- 进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶

![顺序栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png)

#### 顺序栈类

```cpp
template <class elemType>
class seqStack:public stack<elemType>
{
  private:
    elemType *data;                     // 数据域
    int top_p;                          // 栈顶指针
    int maxSize;                        // 栈的最大容量
    void doubleSpace();                
  public:
    seqStack(int initSize = 10);        // 构造函数
    ~seqStack();                        // 析构函数
    bool isEmpty() const;               // 是否为空
    void push(const elemType &x);       // 进栈
    elemType pop();                    // 出栈
    elemType top() const;               // 访问栈顶元素
};
```

#### 顺序存储的运算实现

##### 构造函数

- 按照用户估计的栈的规模申请一个动态数组，将数组地址保存在 `elem` 中，数组规模保存在 `maxSize` 中，并设 `top_p` 的值为$-1$

```cpp
template <class elemType>
seqStack<elemType>::seqStack(int initSize)
{
  elem = new elemType[initSize];
  maxSize = initSize;
  top_p = -1;
}
```

#### `push`

- 先判断栈是否已满，若满则调用 `doubleSpace` 扩大栈的容量
- 将 `top_p` 加1，指向栈顶元素
- 将 `x` 压入栈顶

```cpp
template <class elemType>
void seqStack<elemType>::push(const elemType &x)
{
  if (top_p == maxSize - 1)
  {
    doubleSpace();
  }
  elem[++top_p] = x;
}
```

##### `doubleSpace`

```cpp
template <class elemType>
void seqStack<elemType>::doubleSpace()
{
  elemType *tmp = elem;
  elem = new elemType[maxSize * 2];
  for (int i = 0 ; i <= maxSize ; ++i)
  {
    elem[i] = tmp[i];
  }
  maxSize *= 2;
  delete[] tmp;
}
```

##### `pop`

- 返回 `top_p` 指向的元素
- 将 `top_p` 减1

```cpp
template <class elemType>
elemType seqStack<elemType>::pop()
{
  return elem[top_p--];
}
```

##### `top`

- 返回 `top_p` 指向的元素

```cpp
template <class elemType>
elemType seqStack<elemType>::top() const
{
  return elem[top_p];
}
```

##### `isEmpty`

- 判断 `top_p` 是否为 $-1$，若是则栈空

```cpp
template <class elemType>
bool seqStack<elemType>::isEmpty() const
{
  return top_p == -1;
}
```

#### 析构函数

```cpp
template <class elemType>
seqStack<elemType>::~seqStack()
{
  delete[] elem;
}
```

#### 性能分析

- 所有运算实现的时间复杂度都为 $O(1)$
- 进栈运算在最坏的情况下的时间复杂度为 $O(n)$ （需要 `doublespace` 时）

### 栈的链接实现

- 使用**不含头结点的单链表**实现栈
- 从使用方便性上看，将单链表的头指针指向栈顶

![链接栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png)

#### 链接栈类

```cpp
template <class elemType>
class LinkedStack:public stack<elemType>
{
  private:
    struct node
    {
      elemType data;
      node *next;
      node(const elemType &x , node *n = nullptr)
      {
        data = x;
        next = n;
      }
      node():next(nullptr){}
      ~node(){}
    };
    node *top_p;                       // 栈顶指针
  public:
    LinkedStack();                    // 构造函数
    ~LinkedStack();                   // 析构函数
    bool isEmpty() const;             // 是否为空
    void push(const elemType &x);     // 进栈
    elemType pop();                   // 出栈
    elemType top() const;             // 访问栈顶元素
};
```

#### 链接存储的运算实现

##### 构造函数

- 将 `top_p` 初始化为 `nullptr`

```cpp
template <class elemType>
LinkedStack<elemType>::LinkedStack()
{
  top_p = nullptr;
}
```

##### 析构函数

```cpp
template <class elemType>
LinkStack<elemType>::~LinkStack()
{
  node *tmp;
  while (top_p != nullptr)
  {
    tmp = top_p;
    top_p = top_p->next;
    delete tmp;
  }
}
```

##### `push`

- 在表头插入

```cpp
template <class elemType>
void LinkedStack<elemType>::push(const elemType &x)
{
  top_p = new node(x , top_p);
}
```

##### `pop`

- 删除表头节点

```cpp
template <class elemType>
elemType LinkedStack<elemType>::pop()
{
  node *tmp = top_p;
  elemType x = top_p->data;
  top_p = top_p->next;
  delete tmp;
  return x;
}
```

##### `top`

- 返回 `top_p` 指向的节点的 `data`

```cpp
template <class elemType>
elemType LinkedStack<elemType>::top() const
{
  return top_p->data;
}
```

##### `isEmpty`

- 判断 `top_p` 是否为 `nullptr`

```cpp
template <class elemType>
bool LinkedStack<elemType>::isEmpty() const
{
  return top_p == nullptr;
}
```

#### 性能分析

- 所有运算实现的时间复杂度都为 $O(1)$，因为都是对栈顶进行操作

### 栈的应用

#### 递归函数的非递归实现

##### 函数调用

- 递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈

```cpp
void main()
{
  ...
  r1:f1();
  r2:
  ..
}

void f1()
{
  ...
  t1:f2();
  t2:
  ...
}

void f2()
{
  ...
  ...
}
```

![函数执行过程](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png)

- 设置一个栈模拟函数调用，当调用发生时，将函数压入栈中
- 函数返回时，将栈顶元素弹出

###### 递归算法的例子

hanoi塔算法

```cpp
void Move(int Height , int FromNeedle ,int ToNeedle ,int UsingNeedle) // FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针
{
  if (Height > 0)
  {
    Move(Height - 1，FromNeedle , UsingNeeedle,ToNeedle); // 将上面n-1个盘子从FromNeedle移动到UsingNeedle
    cout << FromNeedle << "->" << ToNeedle << endl; // 将最底下的盘子从FromNeedle移动到ToNeedle>
    Move(Height - 1,UsingNeedle , ToNeedle , FromNeedle); // 将上面的盘子从UsingNeedle移动到ToNeedle
  }
}
```

##### 递归算法的时间复杂度

###### 数学归纳法

以Hanio塔问题为例
  
$$
\begin{dcases}
T(n) = 2T(n-1) + 1 &\\
T(1) = 1 &
\end{dcases}
$$
  
可以使用数学归纳法证明 $T(n) = 2^n - 1$

###### 递归方程

**主定理**：设 $a \geq 1$，$b > 1$ 为常数，$f(n)$ 是一个函数，则递归方程

$$
T(n) = aT(\frac{n}{b}) + f(n) \quad (n > 1)
$$

的解为

1. 若 $f(n) < O\left(n^{\log_{b}a}\right)$，则 $T(n)=O\left(n^{\log_{b}a}\right)$
2. 若 $f(n) = O\left(n^{\log_{b}a}\right)$，则 $T(n)=O\left(n^{\log_{b}a}\log_{2}n\right)$
3. 若 $f(n) > O\left(n^{\log_{b}a}\right)$，则 $T(n)=O\left(f(n)\right)$

###### 生成函数

**定义**：设 $u_0 , u_1 , u_2 , \ldots , u_n ,\ldots$ 是一无穷序列，称形式幂级数 $\displaystyle G(t) = \sum_{i\geq0}u_it^i$ 为其生成函数

利用生成函数求通项的方法

1. 按照递归关系式消去无限延长的部分
2. 展开为 $t$ 的幂级数求通项

以Fibonacci数列为例

$$
\begin{dcases}
F_{0} =0 & \\
F_{1} =1 & \\
F_{n} =F_{n-1} +F_{n-2} & 
\end{dcases}
$$

$$
\begin{aligned}
  &G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \cdots \\
  &G(t) = t + t^2 + t^3 + \cdots \\
  &tG(t)=t^2 + t^3 + t^4 + \cdots \\
  &t^2G(t)=t^3 + t^4 + t^5 + \cdots \\
  &(1-t-t^2)G(t) = t \\
  &G(t) = \frac{t}{1-t-t^2} = \frac{1}{\sqrt{5}} \left(\frac{1}{1-\frac{1+\sqrt{5}}{2}t} - \frac{1}{1-\frac{1-\sqrt{5}}{2}t}\right) \\
\end{aligned}
$$

令 $\Phi = \frac{1}{2}(1+\sqrt{5})$，$\hat{\Phi}=\frac{1}{2}(1-\sqrt{5})$

$$
G(t) =\frac{1}{\sqrt{5}}(\frac{1}{1-\Phi t} - \frac{1}{1-\hat{\Phi}t})
$$

有 $\displaystyle\frac{1}{1-\Phi t} = \sum_{n=0}^{\infty} \Phi^n t^n$

$$
G(t) = \frac{1}{\sqrt{5}} \sum_{n=0}^{\infty} (\Phi^n t^n - \hat{\Phi}^n t^n)
$$

则

$$
F_n = \frac{1}{\sqrt{5}}(\Phi^n - \hat{\Phi}^n)
$$

#### 递归消除

以打印正整数为例

##### 递归实现

###### 代码

```cpp
void printNum(int num)
{
  if (num >= 10)
  {
    printNum(num / 10);
    cout.put(num % 10 + '0');
  }
  else
  {
    cout.put(num + '0');
  }
}
```

###### 代码运行过程中栈的变化

1. `push(1234)`
2. `pop(1234)`，`push(4)`，`push(123)`
3. `pop(123)`，`push(3)`，`push(12)`
4. `pop(12)`，`push(2)`，`push(1)`
5. `pop(1)`，`pop(2)`，`pop(3)`，`pop(4)`

##### 非递归实现

```cpp
void printNum(int num)
{
  LinkStack<int> s;
  int tmp;
  s.push(num);
  while (!isEmpty())
  {
    tmp = s.pop();
    if (tmp > 9)
    {
      s.push(tmp % 10);
      s.push(tmp / 10);
    }
    else
    {
      cout.put(tmp + '0');
    }
  }
}
```

### 括号匹配

- 判断一个表达式中的括号是否匹配
- 遇到左括号就入栈，遇到右括号就出栈

判断错误的原则
1. 栈空时遇到右括号
2. 出栈时遇到不匹配的括号
3. 栈不空时结束

### 简单的计算数学表达式

#### 前缀式、中缀式和后缀式

对于一个表达式 $a+b$
- 前缀式 `+ab`，波兰式
- 中缀式 `a+b`
- 后缀式 `ab+`，逆波兰式

#### 后缀式的优点

- 不需要括号
- 不需要考虑运算符的优先级
- 计算机容易处理

#### 后缀式的计算

- 使用栈来存储操作数
- 遇到操作数就入栈
- 遇到操作符就出栈两个操作数，进行计算，将结果入栈
- 最后栈中只剩下一个元素，就是结果

#### 中缀式转换为后缀式的算法

操作方法见[中缀计算式转换为后缀计算式](/本科/编程/数据结构/中缀计算式转换为后缀计算式.md)

## 队列

- 队列的定义

- 先进先出（FIFO，First In First Out）
- 只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作

![队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png)

#### 队列的基本操作

- **创建 `create()`**：创建一个空队列
- **入队 `enQueue(x)`**：将元素 `x` 入队
- **出队 `deQueue()`**：删除队首元素并返回其值
- **访问队首元素 `getHead()`**：返回队首元素的值但不删除
- **判断是否为空 `isEmpty()`**：若队列空返回 `true`，否则返回 `false`

#### 队列的抽象类

```cpp
template <class elemType>
class queue
{
  public:
    virtual void enQueue(const elemType &x) = 0;       // 入队
    virtual elemType deQueue() = 0;                    // 出队
    virtual elemType getHead() const = 0;              // 访问队首元素
    virtual bool isEmpty() const = 0;                  // 是否为空
    virtual ~queue() {}                                 // 析构函数
};
```

### 队列的顺序实现

- 使用数组来存储队列中的元素
- 元素下标的范围为 $0$ 到 `maxSize - 1`
- 存储队里的三种组织方法
  1. 队头位置固定
  2. 队头位置不固定
  3. 循环队列

#### 队头位置固定

![队头位置固定](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png)

**缺点**：出队的时间复杂度为 $O(n)$，因为出队时需要将所有元素向前移动一位

#### 队头位置不固定

![队头位置不固定](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png)

**优点**：所有操作的时间复杂度均为 $O(1)$
**缺点**：浪费大量的空间

#### 循环队列

![循环队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png)

- 入队
  - `rear = (rear + 1) % maxSize`; `elem[rear] = x`
- 出队
  - `front = (front + 1) % maxSize`; `return elem[front]`

为了解决队列空和队列满的判断问题，令 `front` 指向的单元不能存储队列元素，只能起到标志作用

- 队列空：`front == rear`
- 队列满：`(rear + 1) % maxSize == front`

###### 循环队列类的定义

```cpp
template <class elemType>
class seqQueue:public queue<elemType>
{
  private:
    elemType *elem;
    int maxSize;
    int front , rear;
    void doubleSpace();
  public:
    seqQueue(int initSize = 10);        // 构造函数
    ~seqQueue();                        // 析构函数
    bool isEmpty();                     // 是否为空
    void enQueue(const elemType &x);    // 入队
    elemType deQueue();                 // 出队
    elemType getHead();                 // 访问队首元素
};
```

##### 构造函数

- 申请一块空间，将 `front` 和 `rear` 初始化为 $0$

```cpp
template <class elemType>
seqQueue<elemType>::seqQueue(int initSize)
{
  elem = new elemType[initSize];
  maxSize = initSize;
  front = rear = 0;
}
```

##### 析构函数

```cpp
template <class elemType>
seqQueue<elemType>::~seqQueue()
{
  delete[] elem;
}
```

##### `enQueue`

- 先判断队列是否已满，若满则调用 `doubleSpace` 扩大队列的容量
- 将 `rear` 加1，指向队尾元素

```cpp
template <class elemType>
void seqQueue<elemType>::enQueue(const elemType &x)
{
  if ((rear + 1) % maxSize == front)
  {
    doubleSpace();
  }
  rear = (rear + 1) % maxSize;
  elem[rear] = x;
}
```

##### `doubleSpace`

```cpp
template <class elemType>
void seqQueue<elemType>::doubleSpace()
{
  elemType *tmp = elem;
  elem = new elemType[maxSize * 2];
  for (int i = 0 ; i < maxSize ; ++i)
  {
    elem[i] = tmp[(front + i) % maxSize];
  }
  front = 0;
  rear = maxSize - 1;
  maxSize *= 2;
  delete[] tmp;
}
```

##### `deQueue`

- 将 `front` 加1，指向队首元素
- 返回 `elem[front]`

```cpp
template <class elemType>
elemType seqQueue<elemType>::deQueue()
{
  front = (front + 1) % maxSize;
  return elem[front];
}
```

##### `getHead`

- 返回 `elem[(front + 1) % maxSize]`

```cpp
template <class elemType>
elemType seqQueue<elemType>::getHead()
{
  return elem[(front + 1) % maxSize];
}
```

##### `isEmpty`

- 判断 `front` 是否等于 `rear`

```cpp
template <class elemType>
bool seqQueue<elemType>::isEmpty()
{
  return front == rear;
}
```

### 队列的链接实现

- 为了方便操作，使用含头节点和尾节点的单链表实现

![链接队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png)

**链接队列的特点**

- 不会出现队列满的情况，但是会出现队列空的情况
- 队列为空时，单链表中没有节点存在，即头尾指针都为 `nullptr`
- 保存一个链接队列只需要两个分别指向单链表节点的指针 `front` 和 `rear`
  - `front` 指向队首元素
  - `rear` 指向队尾元素

#### 连接队列类

```cpp
template <class elemType>
class linkQueue:public queue<elemType>
{
  private:
    struct node
    {
      elemType data;
      node *next;
      node(const elemType &x , node *n = nullptr)
      {
        data = x;
        next = n;
      }
      node():next(nullptr){}
      ~node(){}
    };
    node *front , *rear;                // 队头和队尾指针
  public:
    linkQueue();                       // 构造函数
    ~linkQueue();                      // 析构函数
    bool isEmpty() ;              // 是否为空
    void enQueue(const elemType &x);   // 入队
    elemType deQueue();                // 出队
    elemType getHead() const;          // 访问队首元素
};
```

##### 构造函数

- 将 `front` 和 `rear` 初始化为 `nullptr`

```cpp
template <class elemType>
linkQueue<elemType>::linkQueue()
{
  front = rear = nullptr;
}
```

##### `enQueue`

1. 申请一个节点空间 `x`
2. 将 `rear` 指向的节点的 `next` 指向 `x`
3. 将 `rear` 指向 `x`

**注意**：存在队列为空的情况，此时我们只需要将 `front` 和 `rear` 都指向 `x` 即可

```cpp
template <class elemType>
void linkQueue<elemType>::enQueue(const elemType &x)
{
  if (rear == nullptr)
  {
    front = rear = new node(x);
  }
  else
  {
    rear = rear->next = new node(x);
  }
}
```

##### `deQueue`

1. 返回 `front` 指向的节点的 `data`
2. 将 `front` 指向的节点从链表中摘下
3. 释放空间

**注意**：当队列中只有一个元素时，删除后队列为空，此时需要将 `front` 和 `rear` 都置为 `nullptr`


```cpp
template <class elemType>
void LinkQueue<elemType>::deQueue()
{
  node *tmp = front;
  if (front)
  {
    emelType value = front->data;
    front = front->next;
    if (front == nullptr)
    {
      rear = nullptr;
    }
    delete tmp;
    return value;
  }
}
```

##### `getHead`

- 返回 `front` 指向的节点的 `data`

```cpp
template <class elemType>
elemType linkQueue<elemType>::getHead() const
{
  return front->data;
}
```

##### `isEmpty`

- 判断 `front` 或 `rear` 是否为 `nullptr`

```cpp
template <class elemType>
bool linkQueue<elemType>::isEmpty()
{
  return front == nullptr;
}
```

##### 析构函数

```cpp
template <class elemType>
linkQueue<elemType>::~linkQueue()
{
  node *tmp;
  while (front != nullptr)
  {
    tmp = front;
    front = front->next;
    delete tmp;
  }
}
```

## 树

### 树的定义

#### 树的递归定义

- 树是 $n$ 个节点的有限集合，它或者是空集，或者满足
  - 有一个特殊的节点称为根节点
  - 除根节点外，其他节点分为 $m$ 个互不相交的有限集合 $T_1 , T_2 , \ldots , T_m$，每个集合都是一棵树

#### 树的术语

- **根节点、叶节点、内部节点**：
  - 根节点：没有父节点的节点
  - 叶节点：没有子节点的节点
  - 内部节点：有子节点的节点
- **节点的度和树的度**：
  - 节点的度：节点的子树个数
  - 树的度：树中所有节点的度的最大值
- **儿子节点**
- **父亲节点**
- **兄弟节点**
- **祖先节点**
- **子孙节点**
- **节点所处层次**
- **树的高度**
- **有序树**
- **无序树**
- **森林**

#### 树的运算

- **建树 `create()`**：创建一个空树
- **清空 `clear()`**：删除树中所有节点
- **判空 `IsEmpty()`**：判断是否为空树
- **找根节点 `root()`**：找出树的根节点值，若为空树则返回特殊值
- **找父节点 `parent()`**：找到节点的父节点，若该节点不存在或为根节点则返回特殊值
- **找子节点 `child()`**：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值
- **剪枝 `remove()`**：删除节点的某棵子树
- **遍历 `traverse()`**：访问树上的每个节点

#### 树的抽象类

```cpp
template <class T>
class tree
{
  public:
    virtual void clear() = 0;
    virtual bool isEmpty() const = 0;
    virtual T root(T flag) const = 0;
    virtual T parent(T x , T flag) const = 0;
    virtual T child(T x , int i , T flag) const = 0;
    virtual void remove(T x) = 0;
    virtual void traverse() const = 0;
};
```

### 二叉树

#### 二叉树的定义

- 二叉树（Binary Tree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树

**注意**：二叉树是**有序树**，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树

二叉树有五种基本形态
1. 空树
2. 只有一个节点的树
3. 只有左子树的树
4. 只有右子树的树
5. 左右子树都有的树

##### 满二叉树

![满二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png)

- 每个节点的度都为 $0$ 或 $2$ 的二叉树称为满二叉树
- 性质
  - 高度为 $h$ 的满二叉树有 $2^h - 1$ 个节点
  - 任意一层的节点个数达到了上限 $2^{n-1}$

##### 完全二叉树

![完全二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png)

- 在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树
- 满二叉树是完全二叉树，完全二叉树不一定是满二叉树
- 性质
  - 所有的叶节点都出现在最低的两层生
  - 对于任意节点，如果其右子树的高度为 $h$，则其左子树的高度为 $h$ 或 $h+1$

#### 二叉树的性质

1. 二叉树的第 $i$ 层最多有 $2^{i-1}$ 个节点
2. 二叉树的深度为 $h$，则最多有 $2^h - 1$ 个节点
3. 对于一棵非空二叉树，若其叶节点个数为 $n_0$，则其度为 $2$ 的节点个数为 $n_2$，则有 $n_0 = n_2 + 1$
4. 具有 $n$ 个节点的二叉树的高度为 $h$，则 $h = \lfloor \log_2n \rfloor +1$
5. 对于一棵具有 $n$ 个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为 $1$，则对任一编号为 $u$ 的节点，有
   1. 如果 $i=1$，则 $u$ 为根节点
   2. 如果 $i>1$，则 $u$ 的父节点编号为 $\lfloor \frac{u}{2} \rfloor$
   3. 如果 $2i \geq n$，则编号为 $i$ 的节点为叶子节点，没有儿子；否则，其左子编号为 $2i$
   4. 如果 $2i+1 \geq n$，则编号为 $i$ 的节点无右儿子；否则，其右子编号为 $2i+1$

#### 二叉树的基本运算

- **建树 `create()`**：创建一棵空树
- **清空 `clear()`**：删除树中所有节点
- **判空 `isEmpty()`**：判断是否为空树
- **找根节点 `root()`**：找出树的根节点值，若为空树则返回特殊值
- **找父节点 `parent()`**：找到节点的父节点，若该节点不存在或为根节点则返回特殊值
- **找左子节点 `lchild()`**：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值
- **找右子节点 `rchild()`**：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值
- **删除左子树 `delLeft()`**：删除节点的左子树
- **删除右子树 `delRight()`**：删除节点的右子树
- **遍历 `traverse()`**：访问树上的每个节点

#### 二叉树的遍历

##### 前序遍历

- 如果树为空，则操作为空
- 如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树

##### 中序遍历

- 如果树为空，则操作为空
- 如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树

##### 后序遍历

- 如果树为空，则操作为空
- 如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点

##### 层次遍历

- 从上到下，从左到右访问树的每个节点

##### 性质

- 由前序遍历和中序遍历可以唯一确定一棵二叉树
- 由中序遍历和后序遍历可以唯一确定一棵二叉树
- 由前序遍历和后序遍历**不能**唯一确定一棵二叉树

#### 二叉树抽象类

```cpp
template <class T>
class binaryTree
{
  public:
    virtual void clear() = 0;                     // 清空
    virtual bool isEmpty() const = 0;             // 是否为空
    virtual T root(T flag) const = 0;             // 找根节点
    virtual T parent(T x , T flag) const = 0;     // 找父节点
    virtual T lchild(T x , T flag) const = 0;     // 找左子节点
    virtual T rchild(T x , T flag) const = 0;     // 找右子节点
    virtual void delLeft(T x) = 0;                // 删除左子树
    virtual void delRight(T x) = 0;               // 删除右子树
    virtual void preOrder() const = 0;            // 前序遍历
    virtual void midOrder() const = 0;            // 中序遍历
    virtual void postOrder() const = 0;           // 后序遍历
    virtual void levelOrder() const = 0;          // 层次遍历
};
```

#### 二叉树的实现

##### 二叉树的顺序实现

- 使用数组来存储二叉树中的节点
- 将二叉树补全为完全二叉树再进行存储
- 会导致空间浪费

![顺序二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png)

##### 二叉树的链接实现

- 使用链表来存储二叉树中的节点
  - 标准形式：`left`，`data`，`right`

![标准形式](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png)

  - 广义标准形式：`data`，`left`，`parent`，`right`

![广义标准形式](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png)

#### 二叉树类

##### 节点类

```cpp
template <class T>
struct Node
{
  public:
    Node *left *right;                                                                // 左右子树指针
    T data;                                                                           // 节点数据
    Node():left(nullptr),right(nullptr){}                                             // 默认构造函数
    Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R){}  // 带参数的构造函数
    ~Node(){}                                                                         // 析构函数
};
```

##### 二叉树类

```cpp
template <class T>
class binaryTree:public tree<T>
{
    friend void printTree(const binaryTree &t, t flag);
  private:
    struct Node
    {
      public:
        Node *left *right;
        T data;
        Node():left(nullptr),right(nullptr){}
        Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R){}
        ~Node(){}
    }
    Node *root;
  public:
    binaryTree():root(nullptr){}                    // 构造函数,创建空树
    binaryTree(T x):root(new Node(x)){}             // 构造函数,创建只有根节点的树
    ~binaryTree(){}                                 // 析构函数
    void clear();                                   // 清空
    bool isEmpty() const;                           // 是否为空
    T Root(T flag) const;                           // 找根节点
    T lchild(const T &x , T flag) const;            // 找左子节点
    T rchild(const T &x , T flag) const;            // 找右子节点
    void delLeft(const T &x);                       // 删除左子树
    void delRight(const T &x);                      // 删除右子树
    void preOrder() const;                          // 前序遍历
    void midOrder() const;                          // 中序遍历
    void postOrder() const;                         // 后序遍历
    void levelOrder() const;                        // 层次遍历
    coid creatTree(T flag);                         // 创建树
    T parent(const T &x , T flag) const             // 找父节点
    {
      return flag;
    }
  private:
    Node *Find(const T &x, Node *t) const;            // 查找节点
    void clear(Node *&x);                             // 清空
    void preOrder(Node *t) const;                     // 前序遍历
    void midOrder(Node *t) const;                     // 中序遍历
    void postOrder(Node *t) const;                    // 后序遍历
};
```

##### 构造函数

将 `root` 初始化为 `nullptr`

```cpp
template <class T>
binaryTree<T>::binaryTree()
{
  root = nullptr;
}
```

##### `isEmpty`

- 判断 `root` 是否为 `nullptr`

```cpp
template <class T>
bool binaryTree<T>::isEmpty() const
{
  return root == nullptr;
}
```

##### `Root`

返回 `Root` 指向的节点的数据，若为空树则返回特殊值

```cpp
template <class T>
T binaryTree<T>::Root(T flag)const
{
  if (root == nullptr)
  {
    return flag;
  }
  else
  {
    return root->data;
  }
}
```

##### 二叉树的遍历

###### 前序遍历

1. 访问根节点
2. 前序遍历左子树
3. 前序遍历右子树

```cpp
template <class T>
void binaryTree<T>::preOrder(binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return;
  }
  else 
  {
    cout << t -> data << " ";
    preorder(t -> left);
    preorder(t -> right);
  }
}
```

```cpp
template <class T>
void binaryTree<T>::preOrder() const
{
  cout << "\n前序遍历："
  preOrder(root);
}
```

###### 中序遍历

1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树

```cpp
template <class T>
void binaryTree<T>::midOrder(binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return;
  }
  else
  {
    midOrder(t -> left);
    cout << t -> data << " ";
    midOrder(t -> right);
  }
}
```

```cpp
template <class T>
void binaryTree<T>::midOrder() const
{
  cout << "\n中序遍历："
  midOrder(root);
}
```

###### 后序遍历

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根节点

```cpp
template <class T>
void binaryTree<T>::postOrder(binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return;
  }
  else
  {
    postOrder(t -> left);
    postOrder(t -> right);
    cout << t -> data << " ";
  }
}
```

```cpp
template <class T>
void binaryTree<T>::postOrder() const
{
  cout << "\n后序遍历："
  postOrder(root);
}
```

##### `size`

```cpp
template <class T>
int binaryTree<t>::size(binarytree<t>::Node *t) const
{
  if (t = nullptr)
  {
    return 0;
  }
  else
  {
    return 1+sizze(t -> left)+size(t -> right);
  }
}
```

```cpp
template <class T>
int binaryTree<T>::size() const
{
  return size(root);
}
```

##### `height`

```cpp
template <class T>
int binaryTree<T>::size(binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return 0;
  }
  else
  {
    int lt = height(t -> left);
    int rt = height(t -> right);
    return (lt > rt ? lt : rt) + 1;
  }
}
```

```cpp
template <class T>
int binaryTree<T>::height() const
{
  return height(root);
}
```

##### 层次遍历

- 使用链接队列实现

```cpp
template <class T>
void binaryTree<T>::levelOrder() const
{
  linkQueue<Node *> que;
  Node *tmp;
  cout << "\n层次遍历：";
  que.enQueue(root);
  while (!que.isEmpty())
  {
    tmp = que.deQueue();
    cout << tmp -> data << " ";
    if (tmp.left)
    {
      que.enQueue(tmp -> left);
    }
    if (tmp.right)
    {
      que.enQueue(tmp -> right);
    }
  }
}
```

##### `clear`

- 递归删除树中所有节点

```cpp
template <class T>
void binaryTree<T>::clear(Node *&t)
{
  if (t == nullptr)
  {
    return;
  }
  else
  {
    clear(t -> left);
    clear(t -> right);
    delete t;
    t = nullptr;
  }
}
```

```cpp
template <class T>
void binaryTree<T>::clear()
{
  clear(root);
}
```

##### 析构函数

- 调用 `clear` 函数删除树中所有节点

```cpp
template <class T>
binaryTree<T>::~binaryTree()
{
  clear();
}
```

##### `Find`

- 使用前序遍历查找 `x` 节点
- 首先检查根节点是否存放 `x` 的值，若是则返回根节点地址
- 对左子树递归调用 `Find` 函数，若返回空指针则说明 `x` 不在左子树中
- 对右子树递归调用 `Find` 函数，若返回空指针则说明 `x` 不在右子树中

```cpp
template <class T>
struct binaryTree<T>:: Node *binaryTree<T>::Find(const T &x ,binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return nullptr;
  }
  else if (t -> data == x)
  {
    return t;
  }
  else
  {
    if (tmp = Find(x,t->left))
    {
      return tmp;
    }
    else
    {
      return Find(x,t->right);
    }
  }
}
```

##### `delLeft`

```cpp
template <class T>
void binaryTree<T>::delLeft(const T &x)
{
  Node *tmp = Find(x,root);
  if (tmp == nullptr)
  {
    return;
  }
  clear(tmp -> left);
}
```

##### `delRight`

```cpp
template <class T>
void binaryTree<T>::delRight(const T &x)
{
  Node *tmp = Find(x,root);
  if (tmp == nullptr)
  {
    return;
  }
  clear(tmp -> right);
}
```

##### `lchild`

```cpp
template <class T>
T binaryTree<T>::lchild(const T &x ,T flag) const
{
  Node *tmp = Find(x,root)
  if (tmp == nullptr || tmp -> left ==nullptr)
  {
    return flag;
  }
  else
  {
    return tmp -> left;
  }
}
```

##### `rchild`

```cpp
template <class T>
T binaryTree<T>::rchild(const T &x ,T flag) const
{
  Node *tmp = Find(x,root)
  if (tmp == nullptr || tmp -> right ==nullptr)
  {
    return flag;
  }
  else
  {
    return tmp -> right;
  }
}
```

##### `createTree`

- 创建过程（类似层次遍历？）
  1. 输入根节点的值，创建根节点
  2. 对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入 `flag`
- 实现过程
  - 使用队列，将新加入到书中的节点添加到队列中
  - 依次出队，对每个出队的元素输入它的儿子

```cpp
template <class T>
void binaryTree<T>::createTree(T flag)
{
  linkQueue<Node *> que;
  Node *tmp;
  T x , ldata , rdata;

  // 创建树，flag表示空
  cout << "\n输入根节点："
  cin >> x;
  root = new Node(x);
  que.enQueue(root);
  while (!que.isEmpty())
  {
    tmp = que,deQueue();
    cout << "\n输入" << tmp -> data << "的两个儿子（"<<flag<<"表示空节点）：";
    cin >> ldata >> rdata;
    if (ldata != flag)
    {
      tmp -> left = new Node(ldata);
      que.enQueue(tmp -> left);
    }
    if (rdata != flag)
    {
      tmp -> right = new Node(rdata);
      que.enQueue(tmp -> right);
    }
  }
  cout << "that's good!\n";
}
```

##### `printTree`

- 层次遍历输出每个节点和它的左右孩子

```cpp
template <class T>
void printTree(const binaryTree<T> &t,T flag)
{
  linkQueue<T> que;
  que.enQueue(t.root());
  while(!que.isEmpty())
  {
    T tmp = que.deQueue();
    T l = tmp.lchild(tmp , flag);
    T r = tmp.rchild(tmp , flag);
    cout << p << " " << l << " " << r << endl;
    if (l != flag)
    {
      que.enQueue(l);
    }
    if (r != flag)
    {
      que.enQueue(r);
    }
  }
}
```

#### 二叉树遍历的非递归实现

##### 前序遍历

1. 将根节点入栈
2. 栈顶元素出栈并输出值
3. 将左右子树入栈（先右后左，以便输出时先输出左子树）
4. 循环直至栈为空

```cpp
template <class T>
void binaryTree<T>::preOrder(const binaryTree<T>::Node *t) const
{
  linkStack<Node *> s;
  Node *tmp = t;

  cout << "\n前序遍历：";
  while (!s.isEmpty())
  {
    tmp = s.pop();
    cout << tm -> data << " ";
    if (tmp -> right != nullptr)
    {
      s.push(tmp -> right);
    }
    if (tmp -> left != nullptr)
    {
      s.push(tmp -> left);
    }
  }
}
```

##### 中序遍历

1. 根节点入栈
2. 左子树入栈
3. 栈顶元素出栈并输出值
4. 左子树出栈完成之后根节点出栈
5. 右子树入栈
6. 循环直至栈为空

栈的设计
- 根节点入栈出栈两次
  - 第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈
  - 第二次出栈后返回值，并且将右子树入栈
- 对于根节点要记住
  - 在哪棵树上
  - 第几次出栈
- 每个节点在某种意义上都是根节点

###### `StNode` 类定义

```cpp
struct StNode
{
  Node *node;
  int TimesPop;
  StNode(Node *N=Null):node(N),TimesPop(0){}
};
```

###### 中序遍历的非递归实现

```cpp
template <class T>
void binaryTree<T>::midOrder(const binaryTree<T>::Node *t) const
{
  linkStack<Node *t> s;
  StNode current(root);

  cout << "\n中序遍历：";
  s.push(current);
  while(!s.isEmpty())
  {
    current = s.pop();
    if (++current.TimesPop == 2)
    {
      cout << current.node -> data;
      if (current.node -> right != nullptr)
      {
        s.push(StNode(current.node -> right));
      }
    }
    else
    {
      s.push(current);
      if (current.node -> left != nullptr)
      {
        s.push(StNode(current.node -> left));
      }
    }
  }
}
```

##### 后序遍历

1. 根节点入栈
2. 左子树入栈
3. 右子树入栈
4. 栈顶元素出栈并输出值
5. 循环直至栈为空

```cpp
template <class T>
void binaryTree<T>::postOrder(const binaryTree<T>::Node *t) const
{
  linkStack<Node *> s;
  StNode current(root);

  cout << "\n后序遍历：";
  s.push(current);
  while(!s.isEmpty())
  {
    current = s.pop();
    if (++current.TimesPop == 3)
    {
      cout << current.node -> data;
      continue; 
    }
    else
    {
      s.push(current);
      if (current.node -> right != nullptr)
      {
        s.push(StNode(current.node -> right));
      }
      if (current.node -> left != nullptr)
      {
        s.push(StNode(current.node -> left));
      }
    }
  }
}
```

### 哈夫曼树和哈夫曼编码

#### 字符的机内表示

- 用二进制数来表示字符
- 前缀编码
  - 字符只放在叶结点中
  - 字符编码可以有不同的长度
  - 每个字符的编码都不可能是其他字符编码的前缀
  - 可以被唯一解码

#### 哈夫曼树

- 最小代价，即带权路径长度最小的二叉树
- 所有字符都在叶结点上
- 权值大的字符离根节点近，权值小的字符离根节点远
- 哈夫曼编码是一种前缀编码

![huffmanTree](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png)

#### 哈夫曼算法

1. 给定一个具有 $n$ 个权值 $\{w_1 , w_2 , \ldots , w_4\}$ 的节点的集合 $\mathbb{A}$
   $\mathbb{F} = \{T_1 , T_2 , \ldots , T_n\}$
2. 初始时，设集合 $\mathbb{A} = \mathbb{F}$
3. 执行从 $i$ 到 $n-1$ 的循环
   1. 从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点 $b_i$ 的左右儿子，$b_i$ 的权值为这两个节点的权值之和
   2. 集合中去除这两个节点，将 $b_i$ 加入其中
4. 循环结束后，集合 $\mathbb{A}$中只剩下一个节点 $b_n$，即为哈夫曼树的根节点

#### 哈夫曼编码

- 每个节点的编码是从根节点到该节点的路径
- 左子树为 `0`，右子树为 `1`

#### 哈夫曼树类的实现

1. 接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码
2. 有两个公有的成员函数
   1. 构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树
   2. `getCode`：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码

##### 哈夫曼树的存储

- 在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为 $2$ 的节点
- 若待编码的元素个数为 $n$，则哈夫曼树的节点数为 $2n-1$
- 哈夫曼树使用一个大小为 $2n$ 的数组来存储，不使用 $0$ 节点，将根节点存储在下标为 $1$ 的位置，叶节点依次存储在下标为 $n+1$ 到 $2n$ 的位置，$0$ 结点作为结束的判断依据
- 每个数组保存 **节点的数据**，**节点的权值**，**节点的父节点下标**，**左子节点下标**，**右子节点下标**

```cpp
template <class Type>
class hfTree
{
  private:
    struct Node
    {
      Type data; //节点数据
      int weight; //节点权值
      int parent; //父节点下标
      int left , right; //左右子节点下标
    };

    Node *elem;
    int length;
  
  public:
    struct hfCode
    {
      Type data; //节点数据
      string code; //哈夫曼编码
    };

    hfTree(const Type *v , const int *w , int size);
    void getCode(hfCode result[]);
    ~hfTree()
    {
      delete [] elem;
    }
};
```

##### 构造函数

```cpp
template <class Type>
hfTree<Type>::hfTree(const Type *v , const int *w , int size)
{
  const int MAX_INT = 32767;
  int min1 , min2; // 最小树、次最小树的权值
  int x , y ; // 最小树、次最小树的下标

  /* 初始化 */    
  length = 2 * size ;                                            // 哈夫曼树的节点数为 $2\text{size}-1$，但我们只需要存储 $2\text{size}$ 个节点
  elem = new Node[length];                                       // 创建一个大小为 $2\text{size}$ 的数组来存储哈夫曼树的节点
  for (int i = size ; i < length ; i++)                          // 对数组 `elem` 中的节点进行初始化，前 $\text{size}$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值
  {
    elem[i].weight = w[i-size]; // 储存权值
    elem[i].data = v[i-size]; // 储存待编码的元素
    elem[i].parent = elem[i].left = elem[i].right = 0;           // 初始化父节点、左子节点和右子节点的下标为 `0`
  }

  /* 构造新的二叉树 */
  for (int i = size - 1 ; i > 0 ; i--)                           // 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点
  {
    min1 = min2 = MAX_INT;                                       // 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值
    x = y = 0;
    for (int j = i + 1 ; j < length ; j++)                       // 遍历当前节点之后的所有节点
    {
      if (elem[j].parent == 0)                                   // 判断是否未加入树中
      {
        if (elem[j].weight < min1)                               // 找到真正的最小值和次小值以及他们对应的下标
        {
          min2 = min1;
          min1 = elem[j].weight;
          x = y;
          y = j;
        }
        else if(elem[j].weight < min2)
        {
          min2 = elem[j].weight;
          x = j;
        }
      }
    }
    elem[i].weight = min1 + min2;                                // 将最小值和次小值的权值相加，作为当前节点的权值
    elem[i].left = x;                                            // 将最小值的节点作为当前节点的左子节点
    elem[i].right = y;                                           // 将次小值的节点作为当前节点的右子节点
    elem[x].parent = i;                                          // 将当前节点作为最小值节点的父节点
    elem[y].parent = i;                                          // 将当前节点作为次小值节点的父节点
  }
}
```

##### `getCode`

```cpp
template <class Type>
void hdTree<Type>::getcode(hfCode result[])
{
  int size = length / 2 ; 
  int p , s ;
  for (int i = size; i < length; ++i)
  {
    result[i -size].data = elem[i].data;
    result[i -size].code = "";
    p = elem[i].parent; s = i;
    while (p)
    {
      if (elem[p].left == s)
      {
        result[i -size].code = '0' + result[i -size].code;
      }
      else
      {
        result[i -size].code = '1' + result[i -size].code;
      }
      s = p;
      p = elem[p].parent;
    }
  }
}
```

### 树和森林

## 优先级队列

### 优先级队列的定义

- 节点之间的关系是由节点的优先级决定的
- 节点的优先级高的节点在队列中排在前面
- 节点的优先级低的节点在队列中排在后面
- 节点的优先级相同的节点在队列中的顺序与它们入队的顺序相同

### 优先级队列的简单实现

1. 入队时进行排序，出队操作不变
   入队时间复杂度为 $O(n)$，出队时间复杂度为 $O(1)$
2. 出队时进行排序，入队操作不变
   入队时间复杂度为 $O(1)$，出队时间复杂度为 $O(n)$

### 二叉堆

- 二叉堆是一个完全二叉树
- 二叉堆满足下述关系之一（下标是按层次遍历的次序）
  1. **最大化堆**：$k_i > k_{2i},\quad k_i > k{2i+1} \quad (i = 1,2,\ldots,\lfloor \frac{n}{2}\rfloor$
  2. **最小化堆**：$k_i < k_{2i},\quad k_i < k{2i+1} \quad (i = 1,2,\ldots,\lfloor \frac{n}{2}\rfloor)$
- 后面的讨论都以最小化堆为例

![binaryHeap](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png)

#### 二叉堆的特性

- **结构性**
  - 符合完全二叉树的结构
- **有序性**
  - 父节点小于子节点（最小化堆）
  - 父节点大于子节点（最大化堆）

### 基于二叉堆的优先级队列

- 如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列
- 最小化堆中，最小元素为根元素，存放在数组下标为 `1` 的位置
  - 获取队头元素的操作为返回下标为 `1` 的元素值
  - 出队操作为删除下标为 `1` 的元素，重新调整堆
  - 入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆

### 优先级队列类的定义

```cpp
template <class T>
class priorityQueue:public quque<T>
{
  private:
    int currentSize;
    T *array;
    int maxSize;
    void doubleSpace();
    voif buildHeap();  // 建堆，被 priorityQueue() 调用
    void percolateDown(int hole); // 向下过滤
  public:
    priorityQueue(int capacity = 100) // 构造函数
    {
      array = new T[capacity];
      maxSize = capacity;
      currentSize = 0;
    }
    priorityQueue(const T data[] , int size); // 构造函数
    ~priorityQueue(); // 析构函数
    bool isEmpty() const // 是否为空
    {
      return currentSize == 0;
    }
    void enQueue(const T &x); //入队
    T deQueue(); // 出队
    T getHead() const // 获取队头元素
    {
      return array[1];
    }
};
```

#### `enQueue`

- 在堆中插入一个新元素
- 在最大序号中的元素之后插入新的元素或者节点
- 如果没有违反堆的**有序性**，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点

```cpp
template <class T>
void priorityQueue<T>::enQueue(const T &x)
{
  if (currentSize == maxSize - 1)
  {
    doubleSpace();
  }

  // 向上过滤
  int hole = ++currentSize;
  for (;hole > 1 && x < array[hole/2] ; hole /= 2)
  {
    array[hole] = array[hole/2];
  }
  array[hole] = x;
}
```

- 最坏情况时间复杂度为 $O(\log n)$
- 平均情况来说，过滤会提前结束。资料表明平均为 $2.6$ 次比较，即平均上移 $1.6$ 层

#### `deQueue`

- 删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树
- 空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点

```cpp
template <class T>
T priorityQueue<T>::deQueue()
{
  T minItem;
  minItem = array[1];
  array[1] = array[currentSize--];
  percolateDown(1);
  return minItem;
}
```

#### `percolateDown`

```cpp
template <class T>
void priorityQueue<T>::precolateDown(int hole)
{
  int child;
  T tmp = array[hole];

  for (;hole * 2 <= currentSize; hole = child)
  {
    child = hole * 2;
    if (child != currentSIze && array[child + 1] < array[child])
    {
      child++;
    }
    if (array[child] < tmp)
    {
      array[hole] = array[child];
    }
    else
    {
      break;
    }
  }
  array[hole] = tmp;
}
```

## 集合与静态查找表

### 集合的基本概念

1. 数据元素除了属于同意集合之外，没有任何逻辑关系
2. 每个数据元素有一个区别于其他元素的唯一标识，称为**键值**或者**关键字值**

### 集合的存储

- 唯一一个仅适合于存储和处理集合的数据结构是**散列表**

### 查找

#### 查找的基本概念

- 用于查找的集合称之为**查找表**
- 查找表的分类
  - 静态查找表
  - 动态查找表
  - 内部查找
  - 外部查找

#### 静态查找表

- 数据元素的个数和值不允许变化的查找表称为静态查找表
- 不允许插入和删除操作
- 实例：字典
- 可以用顺序表 `seqList` 存储，或直接存储在C++的原始数组中

#### 无序表的查找

- 只能做顺序查找
- 时间复杂度为 $O(n)$

#### 有序表的查找

##### 顺序查找

- 时间复杂度为 $O(n)$

##### 二分查找

- 时间复杂度为 $O(\log n)$

##### 插值查找

$$
\text{next} = \text{low} + \frac{(x - a[\text{low}])}{(a[\text{high}] - a[\text{low}])} \times (\text{high} - \text{low}+1)
$$

- 缺点：计算量大

##### 分块查找

- 将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的
- 查找分为两个阶段
  1. 查找索引
  2. 查找块
  设表长为 $n$，块长为 $m$
  则平均所需的时间为 $\frac{m+1}{2}+\frac{\frac{n}{m}+1}{2}$
  当 $m=\sqrt{n}$ 时，平均所需的时间**最短**，为 $O(\sqrt{n})$

## 动态查找表

### 二叉查找树

#### 二叉查找树的定义

- 对于任意一个节点 `p`
  - `p` 的左子树中所有节点的值都小于 `p` 的值
  - `p` 的右子树中所有节点的值都大于 `p` 的值
  - `p` 的左子树和右子树都是二叉查找树
- 二叉查找树的**中序遍历**是排好序的，又称为**排序树**
- 最大和最小的元素不一定存放在叶节点中

### AVL树

#### AVL树的定义

- 也叫平衡树
  - 对于任意一个节点的两棵子树的高度至多相差1
- 平衡因子
  - 节点的左子树的高度减去右子树的高度
  - 平衡因子只能是 $-1$，$0$，$1$
- 优点
  - 查找，插入和删除操作的时间复杂度都是 $O(\log n)$

##### 查找性能

- 与二叉树的高度成正比

- 定理：
  - 具有 $n$ 个节点的平衡树，高度 $h$ 满足 $\log_2(n+1) \leq h \leq 1.44\log_2(n+2)-0.328$
  - 因此，平衡二叉树的操作都是 $O(\log n)$

##### 斐波那契树

- 斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为1

- 定义
  1. 空树是高度为0的斐波那契树
  2. 单个节点是高度为1的斐波那契树
  3. 若 $T_{h-1}$ 和 $T_{h-2}$ 分别为高度为 $h-1$ 和 $h-2$ 的斐波那契树，则 $T_h ={T_{h-1},x,T_{h-2}}$ 是高度为 $h$ 的斐波那契树
  4. 没有其他的树是斐波那契树

###### 斐波那契树的特点

对于高度为 $h$ 的斐波那契树，节点数 $n$ 满足

- $n_0 = 0$
- $n_1 = 1$
- $n_h = n_{h-1} + n_{h-2} + 1$

#### AVL树的存储实现

- 使用二叉链表
- 每个节点必须保存平衡信息
  - 每棵树的高度
  - 平衡度即左右子树的高度差

##### AVL树类的实现

```cpp
template <clas KEY,class OTHER>
class AvlTree:public dynamicSearchTable<KEY , OTHER>
{
    struct AvlNode
    {
      SET<KEY , OTHER> data ; // 关键字
      AvlNode *left , *right; // 左右子树指针
      int height;            // 节点高度
  
      AvlNode(const SET<KEY , OTHER> &element , AvlNode *lt ,AvlNode   *rt , int h = 1):data(elemeent) , left(lt) , right(rt) , height  (h) {} // 构造函数
    };
  
    AvlNode *root; // 根节点
  public:
    AvlTree() // 构造函数
    {
      root = nullptr;
    }
    ~AvlTree() // 析构函数
    {
      makeEmpty(root);
    }
    SET<KEY, OTHER> *find(const KEY &x) const;
    void remove(const KEY & x);
  private:
    void insert( const SET<KEY, OTHER> & x, AvlNode * & t ) ; // 插入
    bool remove( const KEY & x, AvlNode * & t ) ;
    void makeEmpty( AvlNode *t );
    int height(AvlNode *t) const  // 返回节点的高度
    {
      return t == nullptr ? 0 : t -> height;
    }
    void LL( AvlNode * & t ); // 左旋
    void RR( AvlNode * & t ); // 右旋
    void LR( AvlNode * & t ); // 左右旋
    void RL( AvlNode * & t ); // 右左旋
    int max(int a, int b)     // 返回两个数中较大的一个
    {
      return a > b ? a : b;
    }
    bool adjust(AvlNode *&t, int subTree); //用于删除
};  
```

#### AVL树的查找

- 与二叉查找树相同
- 二叉查找树类采用递归实现
- AVL树类展示非递归实现

##### 查找的非递归实现

1. 设当前节点为根节点
2. 若当前节点非空
   1. 若当前节点的值等于 `x`，则返回当前节点
   2. 若当前节点的值大于 `x`，则将当前节点指向左子树
   3. 若当前节点的值小于 `x`，则将当前节点指向右子树
3. 若当前节点为空，则返回空

```cpp
template <class KEY,class OTHER>
SET<KEY, OTHER> *AvlTree<KEY, OTHER>::find(const KEY & x) const
{
  AvlNode *t = root; 
  while (t!=NULL && t->data.key != x) 
  {
    if (x < t->data.key) 
    {
      t = t->left;
    }
    else
    {
      t = t->right;
    }
  }
  if (t == NULL)
  {
    return NULL;
  }
  else
  {
    return t->data;
  }
}
```

#### AVL树的插入

- 与二叉查找树相同
  - 可能改变了根到插入节点的路径上某些节点的平衡度
  - 需要向上修改树的结构

##### 可能引起节点不平衡的情况

- 节点的左孩子的左子树上插入（LL）
- 节点的左孩子的右子树上插入（LR）
- 节点的右孩子的左子树上插入（RL）
- 节点的右孩子的右子树上插入（RR）

##### 重构的方法

- 指针调整
  - 按照投影序保持结点相邻关系不变
  - 辈分可以改变

###### LL问题

![LL](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png)

- **左旋**
  1. 将失衡点的左儿子作为新的根节点
  2. 左儿子的右儿子作为原根节点的左儿子
- 若为RR问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为**右旋**
- 左旋和右旋统称为**单旋转**，保留了树的有序性和原先的高度

###### LR问题

![LR](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png)

- **双旋转**
  1. 将失衡点的左儿子右旋
  2. 将失衡点左旋
- 若为RL问题，则将失衡点的右儿子左旋，再将失衡点右旋
- 先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使**原先的孙子变成根**

##### 私有的`insert` 函数

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY, OTHER>::insert(const SET<KEY, OTHER> & x, AvlNode * & t)
{
  if (t == NULL)
  {
    t = new AvlNode(x , NULL , NULL);
  }
  else if (x.key < t->data.key)
  {
    insert(x , t->left);
    if (height(t->left) - height(t->right) == 2)
    {
      if (x.key < t->left->data.key)
      {
        LL(t);
      }
      else
      {
        LR(t);
      }
    }
  }
  else if (x.key > t->data.key)
  {
    insert(x , t->right);
    if (height(t->right) - height(t->left) == 2)
    {
      if (x.key > t->right->data.key)
      {
        RR(t);
      }
      else
      {
        RL(t);
      }
    }
  }
  t->height = max(height(t->left) , height(t->right)) + 1; // 更新高度
}
```

###### `LL`

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY,OTHER>::LL(AvlNode *& t)
{
  AvlNode *t1 = t->left;
  t->left = t1->right;
  t1->right = t;
  t->height = max(height(t->left) , height(t->right)) + 1;
  t1->height = max(height(t1->left) , height(t1->right)) + 1;
  t = t1;
}
```

###### `RR`

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY,OTHER>::RR(AvlNode *& t)
{
  AvlNode *t1 = t->right;
  t->right = t1->left;
  t1->left = t;
  t->height = max(height(t->left) , height(t->right)) + 1;
  t1->height = max(height(t1->left) , height(t1->right)) + 1;
  t = t1;
}
```

###### `LR`

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY,OTHER>::LR(AvlNode *& t)
{
  RR(t->left);
  LL(t);
}
```
###### `RL`

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY,OTHER>::RL(AvlNode *& t)
{
  LL(t->right);
  RR(t);
}
```

所有旋转的算法时间复杂度都是 $O(1)$，且只运行一次，所以 `insert` 的时间复杂度为 $O(\log n)$

#### AVL树的删除

1. 在AVL树上删除节点 `x`，删除操作和二叉查找树相同
2. 调整平衡，与插入操作相同

#### 调整

- 与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度
- 删除时无法保证子树在平衡调整之后的高度不变
- 递归的删除函数有一个 bool 型的返回值，当返回值为 `true` 时，调整停止

#### 五种情况

##### 情况a

![Sitiationa](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png)

此时没有失衡，高度也没有改变，返回`true`

##### 情况b

![Situationb](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png)

此时没有失衡，但是高度变矮，返回`false`

##### 情况c

![Situationc](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png)

经过RR旋转后高度变矮，返回`false`

##### 情况d

![Situationd](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png)

经过RL旋转后高度变矮，返回`false`

##### 情况e

![Situatione](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png)

经过RR或RL旋转后高度不变，返回`true`

#### 删除总结

- 节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回 `false`
- 在每次调用后，检查返回值，如果是 `true`，则返回 `true`，否则分5种情况进行处理

#### 私有的 `remove` 函数

```cpp
template<class KEY,class OTHER>
void AvlTree<KEY , OTHER>::remove(const KEY &x , AvlNOde *&x)
{
  if (t = nullptr) // 被删除节点不存在
  {
    return true;
  }
  if (x == t-> data.key)
  {
    if (t->left == nullptr || t-> right == nullptr)
  }
}
```
