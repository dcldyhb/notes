<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

# 数据结构笔记

[oiWiki中的数据结构](https://oi-wiki.org/ds)

## 引言

### 算法与数据结构

数据结构的研究内容

1. 数据之间的**逻辑关系**，以及这种关系对应的操作
2. **储存实现**：数据及逻辑关系的存储
3. **运算实现**：具体存储模式下，运算的实现，即**算法**

#### 数据的逻辑结构

- **集合结构**
  次序任意，元素之间除了**同处于一个集合内**之外没有任意其他的关系.
- **线性结构**
  数据元素的**有序**排列，除了头尾的元素外其余元素都有一个前趋和一个后继.
- **树形结构**
  除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.
- **图形结构**
  每个元素的前趋和后继数量都不限
  ![FourLogicalDataStructures](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png)

#### 数据结构的操作

- **创造**
- **清除**
- **插入**
- **删除**
- **更新**
- **搜索**
- **访问**
- **遍历（traverse）**：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次
- 每一种数据结构的特定操作

数据结构的**五大类**：构建类、属性类、数据操纵类、遍历类、特定类

### 存储实现

### 算法分析

#### 时间复杂度的概念

- 是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，$T(n)$
- 算法的时间复杂度也与被处理的数据分布有关
- 算法的时间复杂度分为三种
  - 最好的
  - 最坏的
  - 平均

#### 算法运算量的计算

#### 渐进时间复杂度

#### 算法的优化

#### 空间复杂度的概念

- 渐进的空间复杂度
- 一般只考虑**辅助**空间的占用情况
- 空间复杂度一般按照最坏情况处理
- 空间复杂度的计算、表示方法与时间复杂度相同

### 面向对象方法

#### 类模板的定义

类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型

##### 定义格式

```cpp
template <class 标识符>
class 类名
{
    // 类成员声明
};
```

##### 类定义的一般格式

```cpp
class 类名
{
  [private:]
    // 私有数据成员和成员函数声明
  public:
    // 公有数据成员和成员函数声明
};
```

#### 虚函数

- 在基类中用关键词 `virtual` 声明的成员函数，并在派生类中重新定义的函数称为虚函数
- 虚函数的一般格式
  
  ```cpp
  virtual 返回类型 函数名(参数表)
  {
    // 函数体
  };
  ```

- 在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（**继承**）
- 当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数
- 虚函数在基类中有默认实现，派生类可以选择性地对其进行重写

#### 纯虚函数

- 是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数
- 纯虚函数的一般形式
  
  ```cpp
  virtual 返回类型 函数名(参数表) = 0;
  ```

- 纯虚函数在基类中无实现，只有函数原型，派生类必须实现

#### 抽象类

- 如果一个类中**至少有一个纯虚函数**，那么这个类就是抽象类
- 抽象类只能作为其他类的基类，不能建立抽象类的对象

#### 继承

- 在已有类的基础上建立新的类
- 基类（父类）和派生类（子类）
- 继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题

##### 派生类

- 一般格式

  ```cpp
  class 派生类名 : [派生方式] 基类名
  {
    // 派生类新增的数据成员和成员函数
  };
  ```

- 派生方法
  - 公有派生：`public`
  - 私有派生：`protected`
  - 保护派生：`private`
- `class` 默认是 `private` 继承， `struct` 默认是 `public` 继承

###### 派生类对基类成员的访问性

|  |`public` 继承|`protected` 继承|`private` 继承|
|:---:|:---:|:---:|:---:|
|`public` 成员|public|protected|private|
|`protected` 成员|protected|protected|private|
|`private` 成员|不可访问|不可访问|不可访问|

#### 类定义时常见的两种`const`用法

以函数 `int search(constelemType&x) const` 为例

1. 修饰参数 `x` 的 `const` 和 `&` 组合
   - `const` 修饰参数 `x`，表示函数 `search` 不会修改参数 `x` 的值
   - 参数加了 `const` 之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数 `x` 的修改操作，若有则会报错
   - **如果确认函数实现中不准备改变 `x` 的值，养成加 `const`的习惯**
   - `&` 修饰参数 `x`，表示参数 `x` 是引用传递，即传递的是实参的地址，而不是实参的值
2. 修饰函数 `search` 的 `const`
   - 参数表后的 `const` 保护调用对象的值不被修改
   - 如果没有 `const` 修饰，那么在调用对象为 `const` 类型时，不能调用该函数
     常量对象只能调用参数表后带 `const` 的常量成员函数

## 线性表

### 线性表的定义

#### 线性表的概念

- 是一种**线性结构**，是由 $n(n\geq0)$ 个数据元素组成的有限序列
- 除了首节点 $A_0$ 和尾节点 $A_{n-1}$ 之外，每个节点 $A_i$ 有且仅有一个前趋 $A_{i-1}$ 和一个后继 $A_{i+1}$
- $A_0$ 只有后趋，$A_{n-1}$ 只有前趋

  ![线性表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png)

#### 表的基本操作

- **创建 `create()`**：创建一个空的线性表
- **清除 `clear()`**：删除线性表中的所有数据元素
- **长度 `length()`**：返回线性表的长度
- **插入 `insert(i,x)`**：在线性表的第 $i$ 个位置插入一个新元素 `x`
- **删除 `remove(i)`**：删除线性表中第 $i$ 个位置的元素
- **搜索 `search(x)`**：在线性表中搜索元素 `x`，返回其位置
- **访问 `visit(i)`**：返回线性表中第 $i$ 个位置的元素
- **遍历 `traverse()`**：依次访问线性表中的每个元素

#### 线性表的抽象类

```cpp
template <class elemType>
class list
{
  public:
    virtual void clear() = 0;                           // 清空
    virtual int length() const = 0;                     // 返回长度
    virtual void insert(int i, const elemType &x) = 0;  // 插入
    virtual void remove(int i) = 0;                     // 删除
    virtual int search(const elemType &x) const = 0;    // 搜索
    virtual elemType visit(int i) const = 0;            // 访问
    virtual void traverse() const = 0;                  // 遍历
    virtual ~list() {}                                  // 析构函数
};
```

- 抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现
- **抽象类无构造函数**

### 线性表的顺序实现

#### 顺序存储结构

- 节点存储在存储器的一块**连续**的空间中
- 节点依照逻辑顺序依次**存放**
- 节点存放的物理位置和逻辑顺序是对应的
- 线性表的顺序实现通常被称为**顺序表**

#### 顺序表类的定义

```cpp
template <class elemType>
class seqList : public list<elemtype>
{
  private:
    elemType *data;
    int currentLength;
    int maxSize;
    void doubleSpace();
  public:
    seqList(int initSize = 10);             // 构造函数
    ~seqList()                              // 析构函数
    {
      delete[] data;
    }
    void clear()                            //清空
    {
      currentLength = 0;
    }
    int length() const                      // 返回长度
    {
      return currentLength;
    }
    void insert(int i, const elemType &x);  // 插入
    void remove(int i);                     // 删除
    int search(const elemType &x) const;    // 搜索
    elemType visit(int i) const;            // 访问
    void traverse() const;                  // 遍历
};
```

#### 函数实现

##### 构造函数

- 定义对象时自动调用，用于初始化对象的数据成员
- **函数名与类名相同**
- 可以有任何类型的参数，也可以没有参数，但是**不能有返回类型**，所以定义时不能说明类型
- 若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数

```cpp
template<class elemType>
seqList<elemType>::seqList(int initSize)
{
  data = new elemType[initSize];
  maxSize = initSize;
  currentLength = 0;
}
```

![seqList](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png)

##### 析构函数

- 用于释放对象所占用的内存空间，由编译系统自动调用
- **函数名与类名相同，前面加 `~`**
- 不能有参数，也不能有返回类型
- 若没有给出析构函数，编译器会自动生成一个默认的析构函数
- 不是所有类都要由析构函数
- 一般在构造函数中动态申请内存的，必须有析构函数

```cpp
~seqList()
{
  delete[] data;
}  //在线性表的类中已经实现了，不用到类外定义
```

##### 顺序表的运算实现

###### `search`

从数组的第0个下标变量开始一次往后检查每一个元素，直到找到 `x` 或找到表尾

```cpp
template<class elemType>
int seqList<elemType>::search(const elemType &x) const
{
  int i ;
  for (i = 0 ; i < currentLength && data[i] != x ; ++i);
  if (i == currentLength) 
  {
    return -1;
  }
  else
  {
    return i;
  }
}
```

###### `traverse`

从数组的第0个下标变量开始一次往后访问每一个元素，直到表尾

```cpp
template<class elemtype>
void seqList<elemType>::traverse() const
{
  for (int i = 0 ; i < currentLength ; ++i)
  {
    cout << data[i] << ' ';
  }
}
```

###### `insert`

- 在第 `i` 个位置插入元素 `x`
- 若插入后表长超过 `maxSize`，则将 `maxSize` 扩大一倍

![seqList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png)

```cpp
template<class elemType>
void seqList<elemType>::insert(int i , const elemType &x)
{
  if (currentSize = maxSize)
  {
    doubleSpace();
  }
  for (int j = currentLength ; j > i ; --j)
  {
    data[j] = data[j - 1];
  }
  data[i] = x;
  ++currentLength;
}
```

###### `doubleSpace` 操作的实现

- 重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区

![seqList::doublespace](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png)

```cpp
template<class elemType>
void seqList<elemType>::doublespace()
{
  elemtype *tmp = data;
  maxSize *= 2;
  data = new elemtype[maxSize];
  for (int i = 0 ; i < currentLength ; ++1)
  {
    data[i] = tmp[i];
  }
  delete[] tmp;
}
```

###### `remove`

![seqlist::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png)

```cpp
template<class elemType>
void seqList<elemType>::remove(int i)
{
  if (i < 0 ||i > currentlength)
  {
    throw OutOfBound();
  }
  for (int j = i ; j < currentlength -1 ; ++j)
  {
    data[j] = data[j + 1];
  }
  --currentLength;
}
```

### 线性表的链接存储

#### 单链表

- 每个节点附加指针字段，如 `next`，指向直接后继节点，最后一个节点的 `next` 指向 `nullptr`

![单链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png)

##### 头节点、头指针

- 在表头额外增加一个相同类型的特殊结点
- 不是线性表中的组成部分
- 头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化

![带头节点的单链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png)

##### 结点及其组成

- 链表的节点包含两个部分
  - 数据字段
    - 可以存储任何类型的数据，仍然使用 `elemType` 表示
  - 指针字段
    - 用于存储**后继节点**的地址值
  - 结点类型是链表专用的，可以设为内嵌类
  - 将节点类定义为 `struct` 方便链表类访问

##### 单链表类的定义

```cpp
template <class elemType>
class sLinkList:public list<elemtype>
{
  private:
    struct node                                    // 节点类
    {
      elemType data;
      node *next;
      node(const elemType &x , node *n = nullptr)
      {
        data = x;
        next = n;
      }
      node():next(nullptr){}
      ~node(){}
    };

    node *head;
    int currentLength;
    node *move(int i) const;
  public:
    sLinkList();
    ~sLinkList();
    void clear();
    int length() const
    {
      return currentLength;
    }
    void insert(int i , const elemType &x);
    void remove(int i);
    int search(const elemType &x) const;
    elemType visit(int i) const;
    void traverse() const;
};
```

##### 构造函数

![sLinklist](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png)

```cpp
template <class elemType>
sLinkList<elemType>::sLinkList()
{
  head = new node();
  currentLength = 0;
}
```

##### `clear`

- 将单链表变成一个空表
- 回收节点空间

![sLinkList::clear](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png)

```cpp
template <class elemType>
void sLinkList<elemType>::clear()
{
  node *p = head->next , *q;

  while (p != nullptr)        // 删除节点
  {
    q = p->next;
    delete p;
    p = q;
  }
  currentLength = 0;
}
```

##### `move`

- 返回第 $i$ 个元素的指针

```cpp
template <class elemType>
struct sLinkList<elemType>::node *sLinkList<elemType>::move(int i) const
{
  node *p = head;
  for (int j = 0 ; j < i ; ++j)
  {
    p = p->next;
  }
  return p;
}
```

##### `insert`

1. 指针 `p` 指向要插入的位置 `i` 的前一个节点
2. 申请一个新节点 `s`
3. 将 `s` 的 `next` 指向 `p` 的 `next`
4. 将 `p` 的 `next` 指向 `s`

![sLinkList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png)

```cpp
template <class elemType>
void sinkList<elemtype>::insert(int i , const elemType &x)
{
  if (i < 0 || i > currentLength)
  {
    throw OutOfBound();
  }
  node *p = move(i-1);
  node *s = new node(x , p->next);
  p->next = s;
  ++currentLength;
}
```

##### `remove`

1. 找到被删除节点的前一个节点 `pos`
2. 让 `delp` 指向被删除节点
3. 让 `pos` 的 `next` 指向 `delp` 的 `next`
4. 释放 `delp` 的空间

![sLinkList::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png)

```cpp
template <class elemType>
void sLinkList<elemType>::remove(int i)
{
  if (i < 0 || i >= currentLength)
  {
    throw OutOfBound();
  }
  node *pos = move(i-1);
  node *delp = pos->next;
  pos->next = delp->next;
  delete delp;
  --currentLength;
}
```

##### `search`

- 从头节点开始，依次访问每个节点，直到找到 `x` 或到达表尾

```cpp
template <class elemType>
int sLinkList<elemType>::search(const elemtype 7x) const
{
  node *p = head -> next;
  int i = 0;
  while (p != nullptr && p->data != x) // 访问每个节点，条件的顺序不能交换
  {
    p = p->next;
    ++i;
  }
  if (p == nullptr)
  {
    return -1;
  }
  else
  {
    return i;
  }
}
```

- 如果判定条件改为 `p->data != x && p != nullptr`，会在 `p` 为空时试图访问 `p->data`，导致访问空指针，从而产生未定义行为

##### `visit`

1. 找到第 `i` 个节点
2. 返回 `p->data`

```cpp
template <class elemType>
elemType sLinkList<elemType>::visit(int i) const
{
  if (i < 0 || i >= currentLength)
  {
    throw OutOfBound();
  }
  return move(i)->data;
}
```

##### `traverse`

```cpp
template <class elemType>
void sLinkList<elemType>::traverse() const
{
  node *p = head->next;
  while (p != nullptr)
  {
    cout << p->data << ' ';
    p = p->next;
  }
}
```

#### 双链表

- 每个节点有两个指针字段
  - `next` 指向直接后继节点
  - `prev` 指向直接前驱节点

##### 双链表的头尾节点

- 头节点
  - `prev` 指向 `nullptr`
  - `next` 指向首节点
- 尾节点 `tail`
  - `prev` 指向最后一个节点
  - `next` 指向 `nullptr`

![双链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png)

##### 双链表类的定义

```cpp
template <class elemType>
class dLinkList:public list<elemType>
{
  private:
    struct node                                                         // 双链表中的节点类
    {
      elemType data;
      node *next;
      node *prev;
      node(const elemType &x , node *p = nullptr , node *n = nullptr)
      {
        data = x;
        prev = p;
        next = n;
      }
      node():next(nullptr),prev(nullptr){}
      ~node(){}
    };
    node *head , *tail;                                                  // 头节点和尾节点
    int currentLength;                                                   // 当前长度
    node *move(int i) const;                                             // 返回第 i 个节点的指针
  public:
    dLinkList();
    ~dLinkList();
    void clear();
    int length() const
    {
      return currentLength;
    }
    void insert(int i , const elemType &x);
    void remove(int i);
    int search(const elemType &x) const;
    elemType visit(int i) const;
    void traverse() const;
};
```

##### 构造函数

- 申请头节点和尾节点

![dLinkList](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png)

```cpp
template <class elemType>
dLinkList<elemType>::dLinkList()
{
  head = new node();
  tail = new node();
  head->next = tail;
  tail->prev = head;
  currentLength = 0;
}
```

##### `insert`

1. 申请一个新节点 `tmp`，找到要插入的位置 `pos`
2. 将 `tmp` 的 `prev` 指向 `pos` 的 `prev`，`tmp` 的 `next` 指向 `pos`
3. 将 `pos` 的前一个结点的 `next` 指向 `tmp`
4. 将 `pos` 的 `prev` 指向 `tmp`

![dLinkList::insert](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png)

```cpp
template <class elemType>
void dLinkList<elemtype>::insert(int i ,const elemTypr &x)
[
  node *pos , *tmp;

  pos = move(i);
  temp = new node(x,pos -> prev , pos);
  pos->prev->next = tmp;
  pos->prev = tmp;

  ++currentLength;
]
```

##### `remove`

1. 找到要删除的节点 `pos`
2. 将 `pos` 的前一个节点的 `next` 指向 `pos` 的后一个节点
3. 将 `pos` 的后一个节点的 `prev` 指向 `pos` 的前一个节点

![dLinkList::remove](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png)

```cpp
template <class elemType>
void dLinkList<elemType>::remove(int i)
{
  node *pos = move(i);

  pos->prev->next = pos->next;
  pos->next->prev = pos->prev;

  delete pos;
  --currentLength;
}
```

#### 单循环链表

- 一般单循环链表不带头节点

![单循环链表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png)

#### 双循环链表

- 头结点中 `prev` 字段给出尾结点的地址，尾结点中 `next` 字段给出头结点的地址
- 一般也不设置头尾节点

## 栈

### 栈的定义

- 栈是一种特殊的线性表
- 只允许在一段进行插入和删除操作
- 先进后出（LIFO，Last In First Out）

![栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png)

#### 栈的基本操作

- **创建 `create()`**：创建一个空栈
- **进栈 `push(x)`**：将元素 `x` 压入栈顶
- **出栈 `pop()`**：删除栈顶元素并返回其值
- **访问栈顶元素 `top()`**：返回栈顶元素的值但是不删除
- **判断是否为空 `isEmpty()`**：若栈空返回 `true`，否则返回 `false`

#### 栈的抽象类

```cpp
template <class elemType>
class stack
{
  public:
    virtual void push(const elemType &x) = 0;       // 进栈
    virtual elemType pop() = 0;                     // 出栈
    virtual elemType top() const = 0;               // 访问栈顶元素
    virtual bool isEmpty() const = 0;               // 是否为空
    virtual ~stack() {}                             // 析构函数
};
```

### 栈的顺序实现

- 使用数组储存栈中的节点
- 进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶

![顺序栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png)

#### 顺序栈类

```cpp
template <class elemType>
class seqStack:public stack<elemType>
{
  private:
    elemType *data;                     // 数据域
    int top_p;                          // 栈顶指针
    int maxSize;                        // 栈的最大容量
    void doubleSpace();                
  public:
    seqStack(int initSize = 10);        // 构造函数
    ~seqStack();                        // 析构函数
    bool isEmpty() const;               // 是否为空
    void push(const elemType &x);       // 进栈
    elemType pop();                    // 出栈
    elemType top() const;               // 访问栈顶元素
};
```

#### 顺序存储的运算实现

##### 构造函数

- 按照用户估计的栈的规模申请一个动态数组，将数组地址保存在 `elem` 中，数组规模保存在 `maxSize` 中，并设 `top_p` 的值为$-1$

```cpp
template <class elemType>
seqStack<elemType>::seqStack(int initSize)
{
  elem = new elemType[initSize];
  maxSize = initSize;
  top_p = -1;
}
```

#### `push`

- 先判断栈是否已满，若满则调用 `doubleSpace` 扩大栈的容量
- 将 `top_p` 加1，指向栈顶元素
- 将 `x` 压入栈顶

```cpp
template <class elemType>
void seqStack<elemType>::push(const elemType &x)
{
  if (top_p == maxSize - 1)
  {
    doubleSpace();
  }
  elem[++top_p] = x;
}
```

##### `doubleSpace`

```cpp
template <class elemType>
void seqStack<elemType>::doubleSpace()
{
  elemType *tmp = elem;
  elem = new elemType[maxSize * 2];
  for (int i = 0 ; i <= maxSize ; ++i)
  {
    elem[i] = tmp[i];
  }
  maxSize *= 2;
  delete[] tmp;
}
```

##### `pop`

- 返回 `top_p` 指向的元素
- 将 `top_p` 减1

```cpp
template <class elemType>
elemType seqStack<elemType>::pop()
{
  return elem[top_p--];
}
```

##### `top`

- 返回 `top_p` 指向的元素

```cpp
template <class elemType>
elemType seqStack<elemType>::top() const
{
  return elem[top_p];
}
```

##### `isEmpty`

- 判断 `top_p` 是否为 $-1$，若是则栈空

```cpp
template <class elemType>
bool seqStack<elemType>::isEmpty() const
{
  return top_p == -1;
}
```

#### 析构函数

```cpp
template <class elemType>
seqStack<elemType>::~seqStack()
{
  delete[] elem;
}
```

#### 性能分析

- 所有运算实现的时间复杂度都为 $O(1)$
- 进栈运算在最坏的情况下的时间复杂度为 $O(n)$ （需要 `doublespace` 时）

### 栈的链接实现

- 使用**不含头结点的单链表**实现栈
- 从使用方便性上看，将单链表的头指针指向栈顶

![链接栈](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png)

#### 链接栈类

```cpp
template <class elemType>
class LinkedStack:public stack<elemType>
{
  private:
    struct node
    {
      elemType data;
      node *next;
      node(const elemType &x , node *n = nullptr)
      {
        data = x;
        next = n;
      }
      node():next(nullptr){}
      ~node(){}
    };
    node *top_p;                       // 栈顶指针
  public:
    LinkedStack();                    // 构造函数
    ~LinkedStack();                   // 析构函数
    bool isEmpty() const;             // 是否为空
    void push(const elemType &x);     // 进栈
    elemType pop();                   // 出栈
    elemType top() const;             // 访问栈顶元素
};
```

#### 链接存储的运算实现

##### 构造函数

- 将 `top_p` 初始化为 `nullptr`

```cpp
template <class elemType>
LinkedStack<elemType>::LinkedStack()
{
  top_p = nullptr;
}
```

##### 析构函数

```cpp
template <class elemType>
LinkStack<elemType>::~LinkStack()
{
  node *tmp;
  while (top_p != nullptr)
  {
    tmp = top_p;
    top_p = top_p->next;
    delete tmp;
  }
}
```

##### `push`

- 在表头插入

```cpp
template <class elemType>
void LinkedStack<elemType>::push(const elemType &x)
{
  top_p = new node(x , top_p);
}
```

##### `pop`

- 删除表头节点

```cpp
template <class elemType>
elemType LinkedStack<elemType>::pop()
{
  node *tmp = top_p;
  elemType x = top_p->data;
  top_p = top_p->next;
  delete tmp;
  return x;
}
```

##### `top`

- 返回 `top_p` 指向的节点的 `data`

```cpp
template <class elemType>
elemType LinkedStack<elemType>::top() const
{
  return top_p->data;
}
```

##### `isEmpty`

- 判断 `top_p` 是否为 `nullptr`

```cpp
template <class elemType>
bool LinkedStack<elemType>::isEmpty() const
{
  return top_p == nullptr;
}
```

#### 性能分析

- 所有运算实现的时间复杂度都为 $O(1)$，因为都是对栈顶进行操作

### 栈的应用

#### 递归函数的非递归实现

##### 函数调用

- 递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈

```cpp
void main()
{
  ...
  r1:f1();
  r2:
  ..
}

void f1()
{
  ...
  t1:f2();
  t2:
  ...
}

void f2()
{
  ...
  ...
}
```

![函数执行过程](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png)

- 设置一个栈模拟函数调用，当调用发生时，将函数压入栈中
- 函数返回时，将栈顶元素弹出

###### 递归算法的例子

hanoi塔算法

```cpp
void Move(int Height , int FromNeedle ,int ToNeedle ,int UsingNeedle) // FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针
{
  if (Height > 0)
  {
    Move(Height - 1，FromNeedle , UsingNeeedle,ToNeedle); // 将上面n-1个盘子从FromNeedle移动到UsingNeedle
    cout << FromNeedle << "->" << ToNeedle << endl; // 将最底下的盘子从FromNeedle移动到ToNeedle>
    Move(Height - 1,UsingNeedle , ToNeedle , FromNeedle); // 将上面的盘子从UsingNeedle移动到ToNeedle
  }
}
```

##### 递归算法的时间复杂度

###### 数学归纳法

以Hanio塔问题为例
  
$$
\begin{dcases}
T(n) = 2T(n-1) + 1 &\\
T(1) = 1 &
\end{dcases}
$$
  
可以使用数学归纳法证明 $T(n) = 2^n - 1$

###### 递归方程

**主定理**：设 $a \geq 1$，$b > 1$ 为常数，$f(n)$ 是一个函数，则递归方程

$$
T(n) = aT(\frac{n}{b}) + f(n) \quad (n > 1)
$$

的解为

1. 若 $f(n) < O\left(n^{\log_{b}a}\right)$，则 $T(n)=O\left(n^{\log_{b}a}\right)$
2. 若 $f(n) = O\left(n^{\log_{b}a}\right)$，则 $T(n)=O\left(n^{\log_{b}a}\log_{2}n\right)$
3. 若 $f(n) > O\left(n^{\log_{b}a}\right)$，则 $T(n)=O\left(f(n)\right)$

###### 生成函数

**定义**：设 $u_0 , u_1 , u_2 , \ldots , u_n ,\ldots$ 是一无穷序列，称形式幂级数 $\displaystyle G(t) = \sum_{i\geq0}u_it^i$ 为其生成函数

利用生成函数求通项的方法

1. 按照递归关系式消去无限延长的部分
2. 展开为 $t$ 的幂级数求通项

以Fibonacci数列为例

$$
\begin{dcases}
F_{0} =0 & \\
F_{1} =1 & \\
F_{n} =F_{n-1} +F_{n-2} & 
\end{dcases}
$$

$$
\begin{aligned}
  &G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \cdots \\
  &G(t) = t + t^2 + t^3 + \cdots \\
  &tG(t)=t^2 + t^3 + t^4 + \cdots \\
  &t^2G(t)=t^3 + t^4 + t^5 + \cdots \\
  &(1-t-t^2)G(t) = t \\
  &G(t) = \frac{t}{1-t-t^2} = \frac{1}{\sqrt{5}} \left(\frac{1}{1-\frac{1+\sqrt{5}}{2}t} - \frac{1}{1-\frac{1-\sqrt{5}}{2}t}\right) \\
\end{aligned}
$$

令 $\Phi = \frac{1}{2}(1+\sqrt{5})$，$\hat{\Phi}=\frac{1}{2}(1-\sqrt{5})$

$$
G(t) =\frac{1}{\sqrt{5}}(\frac{1}{1-\Phi t} - \frac{1}{1-\hat{\Phi}t})
$$

有 $\displaystyle\frac{1}{1-\Phi t} = \sum_{n=0}^{\infty} \Phi^n t^n$

$$
G(t) = \frac{1}{\sqrt{5}} \sum_{n=0}^{\infty} (\Phi^n t^n - \hat{\Phi}^n t^n)
$$

则

$$
F_n = \frac{1}{\sqrt{5}}(\Phi^n - \hat{\Phi}^n)
$$

#### 递归消除

以打印正整数为例

##### 递归实现

###### 代码

```cpp
void printNum(int num)
{
  if (num >= 10)
  {
    printNum(num / 10);
    cout.put(num % 10 + '0');
  }
  else
  {
    cout.put(num + '0');
  }
}
```

###### 代码运行过程中栈的变化

1. `push(1234)`
2. `pop(1234)`，`push(4)`，`push(123)`
3. `pop(123)`，`push(3)`，`push(12)`
4. `pop(12)`，`push(2)`，`push(1)`
5. `pop(1)`，`pop(2)`，`pop(3)`，`pop(4)`

##### 非递归实现

```cpp
void printNum(int num)
{
  LinkStack<int> s;
  int tmp;
  s.push(num);
  while (!isEmpty())
  {
    tmp = s.pop();
    if (tmp > 9)
    {
      s.push(tmp % 10);
      s.push(tmp / 10);
    }
    else
    {
      cout.put(tmp + '0');
    }
  }
}
```

### 括号匹配

- 判断一个表达式中的括号是否匹配
- 遇到左括号就入栈，遇到右括号就出栈

判断错误的原则
1. 栈空时遇到右括号
2. 出栈时遇到不匹配的括号
3. 栈不空时结束

### 简单的计算数学表达式

#### 前缀式、中缀式和后缀式

对于一个表达式 $a+b$
- 前缀式 `+ab`，波兰式
- 中缀式 `a+b`
- 后缀式 `ab+`，逆波兰式

#### 后缀式的优点

- 不需要括号
- 不需要考虑运算符的优先级
- 计算机容易处理

#### 后缀式的计算

- 使用栈来存储操作数
- 遇到操作数就入栈
- 遇到操作符就出栈两个操作数，进行计算，将结果入栈
- 最后栈中只剩下一个元素，就是结果

#### 中缀式转换为后缀式的算法

操作方法见[中缀计算式转换为后缀计算式](/本科/编程/数据结构/中缀计算式转换为后缀计算式.md)

## 队列

- 队列的定义

- 先进先出（FIFO，First In First Out）
- 只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作

![队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png)

#### 队列的基本操作

- **创建 `create()`**：创建一个空队列
- **入队 `enQueue(x)`**：将元素 `x` 入队
- **出队 `deQueue()`**：删除队首元素并返回其值
- **访问队首元素 `getHead()`**：返回队首元素的值但不删除
- **判断是否为空 `isEmpty()`**：若队列空返回 `true`，否则返回 `false`

#### 队列的抽象类

```cpp
template <class elemType>
class queue
{
  public:
    virtual void enQueue(const elemType &x) = 0;       // 入队
    virtual elemType deQueue() = 0;                    // 出队
    virtual elemType getHead() const = 0;              // 访问队首元素
    virtual bool isEmpty() const = 0;                  // 是否为空
    virtual ~queue() {}                                 // 析构函数
};
```

### 队列的顺序实现

- 使用数组来存储队列中的元素
- 元素下标的范围为 $0$ 到 `maxSize - 1`
- 存储队里的三种组织方法
  1. 队头位置固定
  2. 队头位置不固定
  3. 循环队列

#### 队头位置固定

![队头位置固定](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png)

**缺点**：出队的时间复杂度为 $O(n)$，因为出队时需要将所有元素向前移动一位

#### 队头位置不固定

![队头位置不固定](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png)

**优点**：所有操作的时间复杂度均为 $O(1)$
**缺点**：浪费大量的空间

#### 循环队列

![循环队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png)

- 入队
  - `rear = (rear + 1) % maxSize`; `elem[rear] = x`
- 出队
  - `front = (front + 1) % maxSize`; `return elem[front]`

为了解决队列空和队列满的判断问题，令 `front` 指向的单元不能存储队列元素，只能起到标志作用

- 队列空：`front == rear`
- 队列满：`(rear + 1) % maxSize == front`

###### 循环队列类的定义

```cpp
template <class elemType>
class seqQueue:public queue<elemType>
{
  private:
    elemType *elem;
    int maxSize;
    int front , rear;
    void doubleSpace();
  public:
    seqQueue(int initSize = 10);        // 构造函数
    ~seqQueue();                        // 析构函数
    bool isEmpty();                     // 是否为空
    void enQueue(const elemType &x);    // 入队
    elemType deQueue();                 // 出队
    elemType getHead();                 // 访问队首元素
};
```

##### 构造函数

- 申请一块空间，将 `front` 和 `rear` 初始化为 $0$

```cpp
template <class elemType>
seqQueue<elemType>::seqQueue(int initSize)
{
  elem = new elemType[initSize];
  maxSize = initSize;
  front = rear = 0;
}
```

##### 析构函数

```cpp
template <class elemType>
seqQueue<elemType>::~seqQueue()
{
  delete[] elem;
}
```

##### `enQueue`

- 先判断队列是否已满，若满则调用 `doubleSpace` 扩大队列的容量
- 将 `rear` 加1，指向队尾元素

```cpp
template <class elemType>
void seqQueue<elemType>::enQueue(const elemType &x)
{
  if ((rear + 1) % maxSize == front)
  {
    doubleSpace();
  }
  rear = (rear + 1) % maxSize;
  elem[rear] = x;
}
```

##### `doubleSpace`

```cpp
template <class elemType>
void seqQueue<elemType>::doubleSpace()
{
  elemType *tmp = elem;
  elem = new elemType[maxSize * 2];
  for (int i = 0 ; i < maxSize ; ++i)
  {
    elem[i] = tmp[(front + i) % maxSize];
  }
  front = 0;
  rear = maxSize - 1;
  maxSize *= 2;
  delete[] tmp;
}
```

##### `deQueue`

- 将 `front` 加1，指向队首元素
- 返回 `elem[front]`

```cpp
template <class elemType>
elemType seqQueue<elemType>::deQueue()
{
  front = (front + 1) % maxSize;
  return elem[front];
}
```

##### `getHead`

- 返回 `elem[(front + 1) % maxSize]`

```cpp
template <class elemType>
elemType seqQueue<elemType>::getHead()
{
  return elem[(front + 1) % maxSize];
}
```

##### `isEmpty`

- 判断 `front` 是否等于 `rear`

```cpp
template <class elemType>
bool seqQueue<elemType>::isEmpty()
{
  return front == rear;
}
```

### 队列的链接实现

- 为了方便操作，使用含头节点和尾节点的单链表实现

![链接队列](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png)

**链接队列的特点**

- 不会出现队列满的情况，但是会出现队列空的情况
- 队列为空时，单链表中没有节点存在，即头尾指针都为 `nullptr`
- 保存一个链接队列只需要两个分别指向单链表节点的指针 `front` 和 `rear`
  - `front` 指向队首元素
  - `rear` 指向队尾元素

#### 连接队列类

```cpp
template <class elemType>
class linkQueue:public queue<elemType>
{
  private:
    struct node
    {
      elemType data;
      node *next;
      node(const elemType &x , node *n = nullptr)
      {
        data = x;
        next = n;
      }
      node():next(nullptr){}
      ~node(){}
    };
    node *front , *rear;                // 队头和队尾指针
  public:
    linkQueue();                       // 构造函数
    ~linkQueue();                      // 析构函数
    bool isEmpty() ;              // 是否为空
    void enQueue(const elemType &x);   // 入队
    elemType deQueue();                // 出队
    elemType getHead() const;          // 访问队首元素
};
```

##### 构造函数

- 将 `front` 和 `rear` 初始化为 `nullptr`

```cpp
template <class elemType>
linkQueue<elemType>::linkQueue()
{
  front = rear = nullptr;
}
```

##### `enQueue`

1. 申请一个节点空间 `x`
2. 将 `rear` 指向的节点的 `next` 指向 `x`
3. 将 `rear` 指向 `x`

**注意**：存在队列为空的情况，此时我们只需要将 `front` 和 `rear` 都指向 `x` 即可

```cpp
template <class elemType>
void linkQueue<elemType>::enQueue(const elemType &x)
{
  if (rear == nullptr)
  {
    front = rear = new node(x);
  }
  else
  {
    rear = rear->next = new node(x);
  }
}
```

##### `deQueue`

1. 返回 `front` 指向的节点的 `data`
2. 将 `front` 指向的节点从链表中摘下
3. 释放空间

**注意**：当队列中只有一个元素时，删除后队列为空，此时需要将 `front` 和 `rear` 都置为 `nullptr`


```cpp
template <class elemType>
void LinkQueue<elemType>::deQueue()
{
  node *tmp = front;
  if (front)
  {
    emelType value = front->data;
    front = front->next;
    if (front == nullptr)
    {
      rear = nullptr;
    }
    delete tmp;
    return value;
  }
}
```

##### `getHead`

- 返回 `front` 指向的节点的 `data`

```cpp
template <class elemType>
elemType linkQueue<elemType>::getHead() const
{
  return front->data;
}
```

##### `isEmpty`

- 判断 `front` 或 `rear` 是否为 `nullptr`

```cpp
template <class elemType>
bool linkQueue<elemType>::isEmpty()
{
  return front == nullptr;
}
```

##### 析构函数

```cpp
template <class elemType>
linkQueue<elemType>::~linkQueue()
{
  node *tmp;
  while (front != nullptr)
  {
    tmp = front;
    front = front->next;
    delete tmp;
  }
}
```

## 树

### 树的定义

#### 树的递归定义

- 树是 $n$ 个节点的有限集合，它或者是空集，或者满足
  - 有一个特殊的节点称为根节点
  - 除根节点外，其他节点分为 $m$ 个互不相交的有限集合 $T_1 , T_2 , \ldots , T_m$，每个集合都是一棵树

#### 树的术语

- **根节点、叶节点、内部节点**：
  - 根节点：没有父节点的节点
  - 叶节点：没有子节点的节点
  - 内部节点：有子节点的节点
- **节点的度和树的度**：
  - 节点的度：节点的子树个数
  - 树的度：树中所有节点的度的最大值
- **儿子节点**
- **父亲节点**
- **兄弟节点**
- **祖先节点**
- **子孙节点**
- **节点所处层次**
- **树的高度**
- **有序树**
- **无序树**
- **森林**

#### 树的运算

- **建树 `create()`**：创建一个空树
- **清空 `clear()`**：删除树中所有节点
- **判空 `IsEmpty()`**：判断是否为空树
- **找根节点 `root()`**：找出树的根节点值，若为空树则返回特殊值
- **找父节点 `parent()`**：找到节点的父节点，若该节点不存在或为根节点则返回特殊值
- **找子节点 `child()`**：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值
- **剪枝 `remove()`**：删除节点的某棵子树
- **遍历 `traverse()`**：访问树上的每个节点

#### 树的抽象类

```cpp
template <class T>
class tree
{
  public:
    virtual void clear() = 0;
    virtual bool isEmpty() const = 0;
    virtual T root(T flag) const = 0;
    virtual T parent(T x , T flag) const = 0;
    virtual T child(T x , int i , T flag) const = 0;
    virtual void remove(T x) = 0;
    virtual void traverse() const = 0;
};
```

### 二叉树

#### 二叉树的定义

- 二叉树（Binary Tree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树

**注意**：二叉树是**有序树**，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树

二叉树有五种基本形态
1. 空树
2. 只有一个节点的树
3. 只有左子树的树
4. 只有右子树的树
5. 左右子树都有的树

##### 满二叉树

![满二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png)

- 每个节点的度都为 $0$ 或 $2$ 的二叉树称为满二叉树
- 性质
  - 高度为 $h$ 的满二叉树有 $2^h - 1$ 个节点
  - 任意一层的节点个数达到了上限 $2^{n-1}$

##### 完全二叉树

![完全二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png)

- 在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树
- 满二叉树是完全二叉树，完全二叉树不一定是满二叉树
- 性质
  - 所有的叶节点都出现在最低的两层生
  - 对于任意节点，如果其右子树的高度为 $h$，则其左子树的高度为 $h$ 或 $h+1$

#### 二叉树的性质

1. 二叉树的第 $i$ 层最多有 $2^{i-1}$ 个节点
2. 二叉树的深度为 $h$，则最多有 $2^h - 1$ 个节点
3. 对于一棵非空二叉树，若其叶节点个数为 $n_0$，则其度为 $2$ 的节点个数为 $n_2$，则有 $n_0 = n_2 + 1$
4. 具有 $n$ 个节点的二叉树的高度为 $h$，则 $h = \lfloor \log_2n \rfloor +1$
5. 对于一棵具有 $n$ 个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为 $1$，则对任一编号为 $u$ 的节点，有
   1. 如果 $i=1$，则 $u$ 为根节点
   2. 如果 $i>1$，则 $u$ 的父节点编号为 $\lfloor \frac{u}{2} \rfloor$
   3. 如果 $2i \geq n$，则编号为 $i$ 的节点为叶子节点，没有儿子；否则，其左子编号为 $2i$
   4. 如果 $2i+1 \geq n$，则编号为 $i$ 的节点无右儿子；否则，其右子编号为 $2i+1$

#### 二叉树的基本运算

- **建树 `create()`**：创建一棵空树
- **清空 `clear()`**：删除树中所有节点
- **判空 `isEmpty()`**：判断是否为空树
- **找根节点 `root()`**：找出树的根节点值，若为空树则返回特殊值
- **找父节点 `parent()`**：找到节点的父节点，若该节点不存在或为根节点则返回特殊值
- **找左子节点 `lchild()`**：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值
- **找右子节点 `rchild()`**：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值
- **删除左子树 `delLeft()`**：删除节点的左子树
- **删除右子树 `delRight()`**：删除节点的右子树
- **遍历 `traverse()`**：访问树上的每个节点

#### 二叉树的遍历

##### 前序遍历

- 如果树为空，则操作为空
- 如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树

##### 中序遍历

- 如果树为空，则操作为空
- 如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树

##### 后序遍历

- 如果树为空，则操作为空
- 如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点

##### 层次遍历

- 从上到下，从左到右访问树的每个节点

##### 性质

- 由前序遍历和中序遍历可以唯一确定一棵二叉树
- 由中序遍历和后序遍历可以唯一确定一棵二叉树
- 由前序遍历和后序遍历**不能**唯一确定一棵二叉树

#### 二叉树抽象类

```cpp
template <class T>
class binaryTree
{
  public:
    virtual void clear() = 0;                     // 清空
    virtual bool isEmpty() const = 0;             // 是否为空
    virtual T root(T flag) const = 0;             // 找根节点
    virtual T parent(T x , T flag) const = 0;     // 找父节点
    virtual T lchild(T x , T flag) const = 0;     // 找左子节点
    virtual T rchild(T x , T flag) const = 0;     // 找右子节点
    virtual void delLeft(T x) = 0;                // 删除左子树
    virtual void delRight(T x) = 0;               // 删除右子树
    virtual void preOrder() const = 0;            // 前序遍历
    virtual void midOrder() const = 0;            // 中序遍历
    virtual void postOrder() const = 0;           // 后序遍历
    virtual void levelOrder() const = 0;          // 层次遍历
};
```

#### 二叉树的实现

##### 二叉树的顺序实现

- 使用数组来存储二叉树中的节点
- 将二叉树补全为完全二叉树再进行存储
- 会导致空间浪费

![顺序二叉树](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png)

##### 二叉树的链接实现

- 使用链表来存储二叉树中的节点
  - 标准形式：`left`，`data`，`right`

![标准形式](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png)

  - 广义标准形式：`data`，`left`，`parent`，`right`

![广义标准形式](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png)

#### 二叉树类

##### 节点类

```cpp
template <class T>
struct Node
{
  public:
    Node *left *right;                                                                // 左右子树指针
    T data;                                                                           // 节点数据
    Node():left(nullptr),right(nullptr){}                                             // 默认构造函数
    Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R){}  // 带参数的构造函数
    ~Node(){}                                                                         // 析构函数
};
```

##### 二叉树类

```cpp
template <class T>
class binaryTree:public tree<T>
{
    friend void printTree(const binaryTree &t, t flag);
  private:
    struct Node
    {
      public:
        Node *left *right;
        T data;
        Node():left(nullptr),right(nullptr){}
        Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R){}
        ~Node(){}
    }
    Node *root;
  public:
    binaryTree():root(nullptr){}                    // 构造函数,创建空树
    binaryTree(T x):root(new Node(x)){}             // 构造函数,创建只有根节点的树
    ~binaryTree(){}                                 // 析构函数
    void clear();                                   // 清空
    bool isEmpty() const;                           // 是否为空
    T Root(T flag) const;                           // 找根节点
    T lchild(const T &x , T flag) const;            // 找左子节点
    T rchild(const T &x , T flag) const;            // 找右子节点
    void delLeft(const T &x);                       // 删除左子树
    void delRight(const T &x);                      // 删除右子树
    void preOrder() const;                          // 前序遍历
    void midOrder() const;                          // 中序遍历
    void postOrder() const;                         // 后序遍历
    void levelOrder() const;                        // 层次遍历
    coid creatTree(T flag);                         // 创建树
    T parent(const T &x , T flag) const             // 找父节点
    {
      return flag;
    }
  private:
    Node *Find(const T &x, Node *t) const;            // 查找节点
    void clear(Node *&x);                             // 清空
    void preOrder(Node *t) const;                     // 前序遍历
    void midOrder(Node *t) const;                     // 中序遍历
    void postOrder(Node *t) const;                    // 后序遍历
};
```

##### 构造函数

将 `root` 初始化为 `nullptr`

```cpp
template <class T>
binaryTree<T>::binaryTree()
{
  root = nullptr;
}
```

##### `isEmpty`

- 判断 `root` 是否为 `nullptr`

```cpp
template <class T>
bool binaryTree<T>::isEmpty() const
{
  return root == nullptr;
}
```

##### `Root`

返回 `Root` 指向的节点的数据，若为空树则返回特殊值

```cpp
template <class T>
T binaryTree<T>::Root(T flag)const
{
  if (root == nullptr)
  {
    return flag;
  }
  else
  {
    return root->data;
  }
}
```

##### 二叉树的遍历

###### 前序遍历

1. 访问根节点
2. 前序遍历左子树
3. 前序遍历右子树

```cpp
template <class T>
void binaryTree<T>::preOrder(binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return;
  }
  else 
  {
    cout << t -> data << " ";
    preorder(t -> left);
    preorder(t -> right);
  }
}
```

```cpp
template <class T>
void binaryTree<T>::preOrder() const
{
  cout << "\n前序遍历："
  preOrder(root);
}
```

###### 中序遍历

1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树

```cpp
template <class T>
void binaryTree<T>::midOrder(binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return;
  }
  else
  {
    midOrder(t -> left);
    cout << t -> data << " ";
    midOrder(t -> right);
  }
}
```

```cpp
template <class T>
void binaryTree<T>::midOrder() const
{
  cout << "\n中序遍历："
  midOrder(root);
}
```

###### 后序遍历

1. 后序遍历左子树
2. 后序遍历右子树
3. 访问根节点

```cpp
template <class T>
void binaryTree<T>::postOrder(binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return;
  }
  else
  {
    postOrder(t -> left);
    postOrder(t -> right);
    cout << t -> data << " ";
  }
}
```

```cpp
template <class T>
void binaryTree<T>::postOrder() const
{
  cout << "\n后序遍历："
  postOrder(root);
}
```

##### `size`

```cpp
template <class T>
int binaryTree<t>::size(binarytree<t>::Node *t) const
{
  if (t = nullptr)
  {
    return 0;
  }
  else
  {
    return 1+sizze(t -> left)+size(t -> right);
  }
}
```

```cpp
template <class T>
int binaryTree<T>::size() const
{
  return size(root);
}
```

##### `height`

```cpp
template <class T>
int binaryTree<T>::size(binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return 0;
  }
  else
  {
    int lt = height(t -> left);
    int rt = height(t -> right);
    return (lt > rt ? lt : rt) + 1;
  }
}
```

```cpp
template <class T>
int binaryTree<T>::height() const
{
  return height(root);
}
```

##### 层次遍历

- 使用链接队列实现

```cpp
template <class T>
void binaryTree<T>::levelOrder() const
{
  linkQueue<Node *> que;
  Node *tmp;
  cout << "\n层次遍历：";
  que.enQueue(root);
  while (!que.isEmpty())
  {
    tmp = que.deQueue();
    cout << tmp -> data << " ";
    if (tmp.left)
    {
      que.enQueue(tmp -> left);
    }
    if (tmp.right)
    {
      que.enQueue(tmp -> right);
    }
  }
}
```

##### `clear`

- 递归删除树中所有节点

```cpp
template <class T>
void binaryTree<T>::clear(Node *&t)
{
  if (t == nullptr)
  {
    return;
  }
  else
  {
    clear(t -> left);
    clear(t -> right);
    delete t;
    t = nullptr;
  }
}
```

```cpp
template <class T>
void binaryTree<T>::clear()
{
  clear(root);
}
```

##### 析构函数

- 调用 `clear` 函数删除树中所有节点

```cpp
template <class T>
binaryTree<T>::~binaryTree()
{
  clear();
}
```

##### `Find`

- 使用前序遍历查找 `x` 节点
- 首先检查根节点是否存放 `x` 的值，若是则返回根节点地址
- 对左子树递归调用 `Find` 函数，若返回空指针则说明 `x` 不在左子树中
- 对右子树递归调用 `Find` 函数，若返回空指针则说明 `x` 不在右子树中

```cpp
template <class T>
struct binaryTree<T>:: Node *binaryTree<T>::Find(const T &x ,binaryTree<T>::Node *t) const
{
  if (t == nullptr)
  {
    return nullptr;
  }
  else if (t -> data == x)
  {
    return t;
  }
  else
  {
    if (tmp = Find(x,t->left))
    {
      return tmp;
    }
    else
    {
      return Find(x,t->right);
    }
  }
}
```

##### `delLeft`

```cpp
template <class T>
void binaryTree<T>::delLeft(const T &x)
{
  Node *tmp = Find(x,root);
  if (tmp == nullptr)
  {
    return;
  }
  clear(tmp -> left);
}
```

##### `delRight`

```cpp
template <class T>
void binaryTree<T>::delRight(const T &x)
{
  Node *tmp = Find(x,root);
  if (tmp == nullptr)
  {
    return;
  }
  clear(tmp -> right);
}
```

##### `lchild`

```cpp
template <class T>
T binaryTree<T>::lchild(const T &x ,T flag) const
{
  Node *tmp = Find(x,root)
  if (tmp == nullptr || tmp -> left ==nullptr)
  {
    return flag;
  }
  else
  {
    return tmp -> left;
  }
}
```

##### `rchild`

```cpp
template <class T>
T binaryTree<T>::rchild(const T &x ,T flag) const
{
  Node *tmp = Find(x,root)
  if (tmp == nullptr || tmp -> right ==nullptr)
  {
    return flag;
  }
  else
  {
    return tmp -> right;
  }
}
```

##### `createTree`

- 创建过程（类似层次遍历？）
  1. 输入根节点的值，创建根节点
  2. 对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入 `flag`
- 实现过程
  - 使用队列，将新加入到书中的节点添加到队列中
  - 依次出队，对每个出队的元素输入它的儿子

```cpp
template <class T>
void binaryTree<T>::createTree(T flag)
{
  linkQueue<Node *> que;
  Node *tmp;
  T x , ldata , rdata;

  // 创建树，flag表示空
  cout << "\n输入根节点："
  cin >> x;
  root = new Node(x);
  que.enQueue(root);
  while (!que.isEmpty())
  {
    tmp = que,deQueue();
    cout << "\n输入" << tmp -> data << "的两个儿子（"<<flag<<"表示空节点）：";
    cin >> ldata >> rdata;
    if (ldata != flag)
    {
      tmp -> left = new Node(ldata);
      que.enQueue(tmp -> left);
    }
    if (rdata != flag)
    {
      tmp -> right = new Node(rdata);
      que.enQueue(tmp -> right);
    }
  }
  cout << "that's good!\n";
}
```

##### `printTree`

- 层次遍历输出每个节点和它的左右孩子

```cpp
template <class T>
void printTree(const binaryTree<T> &t,T flag)
{
  linkQueue<T> que;
  que.enQueue(t.root());
  while(!que.isEmpty())
  {
    T tmp = que.deQueue();
    T l = tmp.lchild(tmp , flag);
    T r = tmp.rchild(tmp , flag);
    cout << p << " " << l << " " << r << endl;
    if (l != flag)
    {
      que.enQueue(l);
    }
    if (r != flag)
    {
      que.enQueue(r);
    }
  }
}
```

#### 二叉树遍历的非递归实现

##### 前序遍历

1. 将根节点入栈
2. 栈顶元素出栈并输出值
3. 将左右子树入栈（先右后左，以便输出时先输出左子树）
4. 循环直至栈为空

```cpp
template <class T>
void binaryTree<T>::preOrder(const binaryTree<T>::Node *t) const
{
  linkStack<Node *> s;
  Node *tmp = t;

  cout << "\n前序遍历：";
  while (!s.isEmpty())
  {
    tmp = s.pop();
    cout << tm -> data << " ";
    if (tmp -> right != nullptr)
    {
      s.push(tmp -> right);
    }
    if (tmp -> left != nullptr)
    {
      s.push(tmp -> left);
    }
  }
}
```

##### 中序遍历

1. 根节点入栈
2. 左子树入栈
3. 栈顶元素出栈并输出值
4. 左子树出栈完成之后根节点出栈
5. 右子树入栈
6. 循环直至栈为空

栈的设计
- 根节点入栈出栈两次
  - 第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈
  - 第二次出栈后返回值，并且将右子树入栈
- 对于根节点要记住
  - 在哪棵树上
  - 第几次出栈
- 每个节点在某种意义上都是根节点

###### `StNode` 类定义

```cpp
struct StNode
{
  Node *node;
  int TimesPop;
  StNode(Node *N=nullptr):node(N),TimesPop(0){}
};
```

###### 中序遍历的非递归实现

```cpp
template <class T>
void binaryTree<T>::midOrder(const binaryTree<T>::Node *t) const
{
  linkStack<Node *t> s;
  StNode current(root);

  cout << "\n中序遍历：";
  s.push(current);
  while(!s.isEmpty())
  {
    current = s.pop();
    if (++current.TimesPop == 2)
    {
      cout << current.node -> data;
      if (current.node -> right != nullptr)
      {
        s.push(StNode(current.node -> right));
      }
    }
    else
    {
      s.push(current);
      if (current.node -> left != nullptr)
      {
        s.push(StNode(current.node -> left));
      }
    }
  }
}
```

##### 后序遍历

1. 根节点入栈
2. 左子树入栈
3. 右子树入栈
4. 栈顶元素出栈并输出值
5. 循环直至栈为空

```cpp
template <class T>
void binaryTree<T>::postOrder(const binaryTree<T>::Node *t) const
{
  linkStack<Node *> s;
  StNode current(root);

  cout << "\n后序遍历：";
  s.push(current);
  while(!s.isEmpty())
  {
    current = s.pop();
    if (++current.TimesPop == 3)
    {
      cout << current.node -> data;
      continue; 
    }
    else
    {
      s.push(current);
      if (current.node -> right != nullptr)
      {
        s.push(StNode(current.node -> right));
      }
      if (current.node -> left != nullptr)
      {
        s.push(StNode(current.node -> left));
      }
    }
  }
}
```

### 哈夫曼树和哈夫曼编码

#### 字符的机内表示

- 用二进制数来表示字符
- 前缀编码
  - 字符只放在叶结点中
  - 字符编码可以有不同的长度
  - 每个字符的编码都不可能是其他字符编码的前缀
  - 可以被唯一解码

#### 哈夫曼树

- 最小代价，即带权路径长度最小的二叉树
- 所有字符都在叶结点上
- 权值大的字符离根节点近，权值小的字符离根节点远
- 哈夫曼编码是一种前缀编码

![huffmanTree](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png)

#### 哈夫曼算法

1. 给定一个具有 $n$ 个权值 $\{w_1 , w_2 , \ldots , w_4\}$ 的节点的集合 $\mathbb{A}$
   $\mathbb{F} = \{T_1 , T_2 , \ldots , T_n\}$
2. 初始时，设集合 $\mathbb{A} = \mathbb{F}$
3. 执行从 $i$ 到 $n-1$ 的循环
   1. 从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点 $b_i$ 的左右儿子，$b_i$ 的权值为这两个节点的权值之和
   2. 集合中去除这两个节点，将 $b_i$ 加入其中
4. 循环结束后，集合 $\mathbb{A}$中只剩下一个节点 $b_n$，即为哈夫曼树的根节点

#### 哈夫曼编码

- 每个节点的编码是从根节点到该节点的路径
- 左子树为 `0`，右子树为 `1`

#### 哈夫曼树类的实现

1. 接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码
2. 有两个公有的成员函数
   1. 构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树
   2. `getCode`：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码

##### 哈夫曼树的存储

- 在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为 $2$ 的节点
- 若待编码的元素个数为 $n$，则哈夫曼树的节点数为 $2n-1$
- 哈夫曼树使用一个大小为 $2n$ 的数组来存储，不使用 $0$ 节点，将根节点存储在下标为 $1$ 的位置，叶节点依次存储在下标为 $n+1$ 到 $2n$ 的位置，$0$ 结点作为结束的判断依据
- 每个数组保存 **节点的数据**，**节点的权值**，**节点的父节点下标**，**左子节点下标**，**右子节点下标**

```cpp
template <class Type>
class hfTree
{
  private:
    struct Node
    {
      Type data; //节点数据
      int weight; //节点权值
      int parent; //父节点下标
      int left , right; //左右子节点下标
    };

    Node *elem;
    int length;
  
  public:
    struct hfCode
    {
      Type data; //节点数据
      string code; //哈夫曼编码
    };

    hfTree(const Type *v , const int *w , int size);
    void getCode(hfCode result[]);
    ~hfTree()
    {
      delete [] elem;
    }
};
```

##### 构造函数

```cpp
template <class Type>
hfTree<Type>::hfTree(const Type *v , const int *w , int size)
{
  const int MAX_INT = 32767;
  int min1 , min2; // 最小树、次最小树的权值
  int x , y ; // 最小树、次最小树的下标

  /* 初始化 */    
  length = 2 * size ;                                            // 哈夫曼树的节点数为 $2\text{size}-1$，但我们只需要存储 $2\text{size}$ 个节点
  elem = new Node[length];                                       // 创建一个大小为 $2\text{size}$ 的数组来存储哈夫曼树的节点
  for (int i = size ; i < length ; i++)                          // 对数组 `elem` 中的节点进行初始化，前 $\text{size}$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值
  {
    elem[i].weight = w[i-size]; // 储存权值
    elem[i].data = v[i-size]; // 储存待编码的元素
    elem[i].parent = elem[i].left = elem[i].right = 0;           // 初始化父节点、左子节点和右子节点的下标为 `0`
  }

  /* 构造新的二叉树 */
  for (int i = size - 1 ; i > 0 ; i--)                           // 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点
  {
    min1 = min2 = MAX_INT;                                       // 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值
    x = y = 0;
    for (int j = i + 1 ; j < length ; j++)                       // 遍历当前节点之后的所有节点
    {
      if (elem[j].parent == 0)                                   // 判断是否未加入树中
      {
        if (elem[j].weight < min1)                               // 找到真正的最小值和次小值以及他们对应的下标
        {
          min2 = min1;
          min1 = elem[j].weight;
          x = y;
          y = j;
        }
        else if(elem[j].weight < min2)
        {
          min2 = elem[j].weight;
          x = j;
        }
      }
    }
    elem[i].weight = min1 + min2;                                // 将最小值和次小值的权值相加，作为当前节点的权值
    elem[i].left = x;                                            // 将最小值的节点作为当前节点的左子节点
    elem[i].right = y;                                           // 将次小值的节点作为当前节点的右子节点
    elem[x].parent = i;                                          // 将当前节点作为最小值节点的父节点
    elem[y].parent = i;                                          // 将当前节点作为次小值节点的父节点
  }
}
```

##### `getCode`

```cpp
template <class Type>
void hdTree<Type>::getcode(hfCode result[])
{
  int size = length / 2 ; 
  int p , s ;
  for (int i = size; i < length; ++i)
  {
    result[i -size].data = elem[i].data;
    result[i -size].code = "";
    p = elem[i].parent; s = i;
    while (p)
    {
      if (elem[p].left == s)
      {
        result[i -size].code = '0' + result[i -size].code;
      }
      else
      {
        result[i -size].code = '1' + result[i -size].code;
      }
      s = p;
      p = elem[p].parent;
    }
  }
}
```

### 树和森林

#### 树的存储实现

- **标准形式**：除了数据字段之外，还有 $K$ 个指针字段，指向 $K$ 个孩子节点，其中 $K$ 是树的度
- **广义标准形式**：除了数据字段之外，还有 $K$ 个指针字段，指向 $K$ 个孩子节点和一个指针字段，指向父节点

![树的存储实现](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211450009.png)

#### 树的表示方法

##### 孩子链表示法

- 每个节点的所有孩子组织成一个链表
- 节点由两个部分组成
  - 储存数据元素值的数据部分
  - 指向孩子链的指针

- **静态**的孩子链表：树的所有节点存放在一个名叫表头数组的**数组**中
- **动态**的孩子链表：树的所有节点组织成一个**链表**

##### 孩子兄弟链表示法

- 将一棵树转化为二叉树
- 左子树指向第一颗子树树根的指针
- 右子树指向兄弟节点的指针

![孩子兄弟链](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211559361.png)

##### 双亲表示法

- 每一个节点由两个部分组成
  - 储存数据元素的数据字段
  - 储存父节点的父指针字段
- 便于查找节点的祖先，但是不便于查找指定节点的子孙

### 树的遍历

#### 前序遍历

1. 访问根节点
2. 依次前序遍历所有子树

#### 后序遍历

1. 依次后序遍历所有子树
2. 访问根节点

#### 层次遍历

1. 访问根节点
2. 若第 $i$ 层已被访问，且第 $i+1$ 层的结点尚未被访问，则从左到右依次访问第 $i+1$ 层的结点

#### 特点

- 树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的
- 树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的

由前序遍历和后序遍历可以唯一确定一棵树

### 树、森林和二叉树

#### 森林的定义

- 森林通常被定义为树的集合或树的序列
- 存储
  - 存储森林的每一棵树
  - 表示这些树属于同一个森林

#### 森林的二叉树存储

1. 将每棵树 $T_i$ 转化为二叉树 $B_i$
2. 将 $B_i$ 作为 $B_{i-1}$ 根节点的右子树

## 优先级队列

### 优先级队列的定义

- 节点之间的关系是由节点的优先级决定的
- 优先级高的先出队，优先级低的后出队
- 继承于队列的抽象类

### 优先级队列的简单实现

1. 入队时进行排序，出队操作不变
   入队时间复杂度为 $O(n)$，出队时间复杂度为 $O(1)$
2. 出队时进行排序，入队操作不变
   入队时间复杂度为 $O(1)$，出队时间复杂度为 $O(n)$

### 二叉堆

- 二叉堆是一个完全二叉树
- 二叉堆满足下述关系之一（下标是按层次遍历的次序）
  1. **最大化堆**：$k_i > k_{2i},\quad k_i > k{2i+1} \quad (i = 1,2,\ldots,\lfloor \frac{n}{2}\rfloor$
  2. **最小化堆**：$k_i < k_{2i},\quad k_i < k{2i+1} \quad (i = 1,2,\ldots,\lfloor \frac{n}{2}\rfloor)$
- 后面的讨论都以最小化堆为例

![binaryHeap](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png)

#### 二叉堆的特性

- **结构性**
  - 符合完全二叉树的结构
- **有序性**
  - 父节点小于子节点（最小化堆）
  - 父节点大于子节点（最大化堆）

### 基于二叉堆的优先级队列

- 如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列
- 最小化堆中，最小元素为根元素，存放在数组下标为 `1` 的位置
  - 获取队头元素的操作为返回下标为 `1` 的元素值
  - 出队操作为删除下标为 `1` 的元素，重新调整堆
  - 入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆

### 优先级队列类的定义

```cpp
template <class T>
class priorityQueue:public quque<T>
{
  private:
    int currentSize;
    T *array;
    int maxSize;
    void doubleSpace();
    voif buildHeap();  // 建堆，被 priorityQueue() 调用
    void percolateDown(int hole); // 向下过滤
  public:
    priorityQueue(int capacity = 100) // 构造函数
    {
      array = new T[capacity];
      maxSize = capacity;
      currentSize = 0;
    }
    priorityQueue(const T data[] , int size); // 构造函数
    ~priorityQueue(); // 析构函数
    bool isEmpty() const // 是否为空
    {
      return currentSize == 0;
    }
    void enQueue(const T &x); //入队
    T deQueue(); // 出队
    T getHead() const // 获取队头元素
    {
      return array[1];
    }
};
```

#### `enQueue`

- 在堆中插入一个新元素
- 在最大序号中的元素之后插入新的元素或者节点
- 如果没有违反堆的**有序性**，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点

```cpp
template <class T>
void priorityQueue<T>::enQueue(const T &x)
{
  if (currentSize == maxSize - 1)
  {
    doubleSpace();
  }

  // 向上过滤
  int hole = ++currentSize;
  for (;hole > 1 && x < array[hole/2] ; hole /= 2)
  {
    array[hole] = array[hole/2];
  }
  array[hole] = x;
}
```

- 最坏情况时间复杂度为 $O(\log n)$
- 平均情况来说，过滤会提前结束。资料表明平均为 $2.6$ 次比较，即平均上移 $1.6$ 层

#### `deQueue`

- 删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树
- 空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点

```cpp
template <class T>
T priorityQueue<T>::deQueue()
{
  T minItem;
  minItem = array[1];
  array[1] = array[currentSize--];
  percolateDown(1);
  return minItem;
}
```

#### `percolateDown`

```cpp
template <class T>
void priorityQueue<T>::precolateDown(int hole)
{
  int child;
  T tmp = array[hole];

  for (;hole * 2 <= currentSize; hole = child)
  {
    child = hole * 2;
    if (child != currentSIze && array[child + 1] < array[child])
    {
      child++;
    }
    if (array[child] < tmp)
    {
      array[hole] = array[child];
    }
    else
    {
      break;
    }
  }
  array[hole] = tmp;
}
```

#### `buildHeap`

##### 连续插入

- 时间复杂度为 $O(n \log n)$

##### 自上而下调整二叉树

- 对左子树和右子树递归调用 `buildHeaap`，再对根节点向下过滤
- 时间复杂度为 $O(n)$

##### 非递归实现

从编号最大的非叶节点 $\lfloor \frac{n}{2} \rfloor$ 开始逆层次遍历，每个节点调用 `percolateDown`，直到根节点


## 集合与静态查找表

### 集合的基本概念

1. 数据元素除了属于同一集合之外，没有任何逻辑关系
2. 每个数据元素有一个区别于其他元素的唯一标识，称为**键值**或者**关键字值**

```cpp
template<calss KEY , class OTHER>
struct SET
{
  KEY key; // 关键字值
  OTHER other; // 其他信息
}
```

运算

- **查找** 某一元素是否存在
- 将集合中的元素按照它的唯一标识排序

这些都是对 `key` 的操作

### 集合的存储

- 任何容器都能存储集合
- 常用的表达形式是借鉴于**线性表**和**树**
- 唯一一个仅适合于存储和处理集合的数据结构是**散列表**

### 查找

#### 查找的基本概念

- 用于查找的集合称之为**查找表**
- 查找表的分类
  - 静态查找表
  - 动态查找表
  - 内部查找
  - 外部查找

#### 静态查找表

- 数据元素的个数和值不允许变化的查找表称为静态查找表
- 不允许插入和删除操作
- 实例：字典
- 可以用顺序表 `seqList` 存储，或直接存储在C++的原始数组中

#### 无序表的查找

- 只能做顺序查找
- 时间复杂度为 $O(n)$
- 可以使用哨兵减少 $n$ 次查找

- 优化后的顺序查找

```cpp
template <class KEY, class OTHER>
int seqSearch(SET<KEY, OTHER> data[] , int size , const KEY &x)
{
  data[0].key = x;
  for (int i = size ; x != data[i].key; --i)
  {
    return i;
  }
}
13
```

#### 有序表的查找

##### 顺序查找

- 与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头
- 时间复杂度为 $O(n)$

- 有序表的顺序查找

```cpp
template <class KEY, class OTHER>
int seqSearch(SET<KEY , OTHER> data[] , int size , const KEY &x)
{
  data[0].key = x;
  for (int i = size ; x < data[i].key; --i);
  if (x == data[i].key)
  {
    return i;
  }
else
{
  return 0;
}
```

##### 二分查找

1. 每次检查中间的元素（向下取整）
2. 若中间的元素等于要查找的元素，则查找成功
3. 若中间的元素大于要查找的元素，则在左半部分继续查找
4. 若中间的元素小于要查找的元素，则在右半部分继续查找

- 时间复杂度为 $O(\log n)$

```cpp
template <class KEY, class OTHER>
int binarySearch(SET<KEY , OTHER>data[] , int size , const KEY &x) 
{
  int low = 1,  high = size, mid;
    while (low <= high)
    {                 //查找区间存在
      mid = (low + high) / 2;         //计算中间位置
      if ( x == data[mid].key ) 
      {
        return mid;
      }
      if (x < data[mid].key)
      {
        high = mid - 1;
      }
      else low = mid + 1;
    }	
  return 0;
}
```

##### 插值查找

- 适用于数据分布较为均匀的情况
- 计算中间位置的公式为

$$
\text{next} = \text{low} + \frac{(x - a[\text{low}])}{(a[\text{high}] - a[\text{low}])} \times (\text{high} - \text{low}+1)
$$

- 缺点：计算量大

##### 分块查找

- 将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的
- 查找分为两个阶段
  1. 查找索引
  2. 查找块
  设表长为 $n$，块长为 $m$
  则平均所需的时间为 $\frac{m+1}{2}+\frac{\frac{n}{m}+1}{2}$
  当 $m=\sqrt{n}$ 时，平均所需的时间**最短**，为 $O(\sqrt{n})$

## 动态查找表

### 二叉查找树

#### 抽象类

```cpp
template <class KEY, class OTHER>
class dynamicSearchTable
{
  public:
    virtual SET<KEY, OTHER> *find(const KEY &x) const = 0;
    virtual void insert(const SET<KEY, OTHER> &x) = 0;
    virtual void remove(const KEY &x) = 0;
    virtual ~dynamicSearchTable() {};
};
```

#### 二叉查找树的定义

- 对于任意一个节点 `p`
  - `p` 的左子树中所有节点的值都小于 `p` 的值
  - `p` 的右子树中所有节点的值都大于 `p` 的值
  - `p` 的左子树和右子树都是二叉查找树
- 二叉查找树的**中序遍历**是排好序的，又称为**排序树**
- 最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的

#### 二叉查找树的存储实现

- 使用二叉链表存储，需要一个指向根节点的数据成员

```cpp
template <class KEY, class OTHER>
class BinarySearchTree:public dynamicSearchTable<KEY , OTHER>
{
  private:
    struct BinaryNode
    {
      SET<KEY, OTHER> data;
      BinaryNode*left;
      BinaryNode*right;
      BinaryNode( const SET<KEY, OTHER> & thedata,
      BinaryNode *lt = nullptr , BinaryNode *rt = nullptr):data(thedata) , left(lt) , right(rt){}
    };
    BinaryNode*root;

  public:
    BinarySearchTree();
    ~BinarySearchTree();
    SET<KEY, OTHER> *find(const KEY &x) const ;
    void insert(const SET<KEY , OTHER> &x );
    void remove(const KEY &x);
  
  private:
    void insert(const SET<KEY , OTHER> &x, BinaryNode *&t);
    void remove(const KEY &x , BinaryNode *&t);
    SET<KEY , OTHER> *find(const KEY &x , BinaryNode *t ) const;
    void makeEmpty(BinaryNode *t);//析构用，同二叉树的clear
};
```

#### 二叉查找树的操作

##### 查找

1. 检查根节点的关键字值
2. 如果等于要查找的值，则查找成功，返回根节点地址
3. 如果小于要查找的值，则在右子树中查找
4. 如果大于要查找的值，则在左子树中查找

- 公有函数 `find(const KEY &x)`

```cpp
template <class KEY, class OTHER>
SET<KEY, OTHER> *BinarySearchTree<KEY, OTHER>::find(const KEY &x ) const
{
  return find( x, root );
}
```

- 私有辅助函数 `find(const KEY &x, BinaryNode *t)`

```cpp
template <class KEY, class OTHER>
SET<KEY, OTHER> *BinarySearchTree<KEY, OTHER>::find(const KEY &x, BinaryNode *t ) const
{
  if (t == nullptr || t->data.key == x)
  {
    return (SET<KEY , OTHER> *)t;//强制类型转换
  }
  if(x < t->data.key)
  {
    return find(x , t->left);
  }
  else
  {
    return find(x , t->right );
  }
}
```

##### 插入

- 若二叉树为空树，则插入的节点为根节点
- 若二叉树非空
  - 判断是左儿子还是右儿子，作为叶节点插入

- 公有的 `insert(const SET<KEY, OTHER> &x)`
```cpp
template <class KEY, class OTHER>
void BinarySearchTree<KEY, OTHER>::insert(const SET<KEY , OTHER> &x)
{
  insert(x, root);
}
```

- 私有的 `insert(const SET<KEY, OTHER> &x, BinaryNode *&t)`

```cpp
template <class KEY, class OTHER>
void BinarySearchTree<KEY , OTHER>::insert(const SET<KEY , OTHER> &x, BinaryNode *&t)
{
  if(t == nullptr)
  t = new BinaryNode(x , nullptr , nullptr);
  else if(x.key< t->data.key)
  {
    insert(x, t->left);
  }
  else if(x.key > t->data.key)
  {
    insert(x , t->right);
  }
  else
  {
    cout << x.key << “is exist” << endl;
  }
}
```

##### 删除

-  $P_L$ 和 $P_R$ 分别是 $P$ 的左子树和右子树
   1. 如果 $P$ 是叶节点，则直接删除
   2. 如果 $P$ 只有一个子树，则将 $P$ 的父节点指向 $P$ 的子树
   3. 如果 $P$ 有两个子树，则
      1. 找到 $P$ 的右子树中最左的节点或者左子树的最右节点 $Q$
      2. 将 $Q$ 的值赋给 $P$
      3. 删除 $Q$ 节点

- 公有的 `remove(const KEY &x)`

```cpp
template <class KEY, class OTHER>
void BinarySearchTree<KEY, OTHER>::remove(const KEY &x)
{
  remove(x , root);
}
```

- 私有的 `remove(const KEY &x, BinaryNode *&t)`

```cpp
template <class KEY, class OTHER>
void BinarySearchTree<KEY , OTHER>::remove(const KEY &x , BinaryNode *&t)
{
  if(t == nullptr)
  {
    cout << x.key << "is not exist" << endl;
  }
  else if(x.key < t->data.key)
  {
    remove(x , t->left);
  }
  else if(x.key > t->data.key)
  {
    remove(x , t->right);
  }
  else if(t->left != nullptr && t->right != nullptr)
  {
    BinaryNode *p = t->right;
    while(p->left != nullptr)
    {
      p = p->left;
    }
    t->data = p->data;
    remove(p->data.key , t->right);
  }
  else
  {
    BinaryNode *oldNode = t;
    t = (t->left != nullptr) ? t->left : t->right;
    delete oldNode;
  }
}
```

#### 二叉查找树的性能

- 二叉查找树的操作的时间复杂度为树的高度
- 如果二叉查找树是平衡的，则访问的代价是 $O(\log n)$
- 最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 $O(n)$

**平均性能**

具有 $n$ 个节点的二叉查找树可能有 $n$ 种不同的形态
$(0,1,n-1) , (1 , 1 n-2) , (2 , 1 , n-3) , \ldots , (n-1 , 1 , 0)$
若设这些形态出现的概率是相同的，设 $P(n)$ 为查找 $n$ 个节点的二叉查找树的平均查找时间，则有如下递归关系式：

$$
P(n) = \frac{\sum_{i = 0}^{n-1} \left[ 1 + (P(i)+1) \cdot i + (P( n - i - 1)+1)\cdot (n-i-1)\right]}{n} \leq 2(1 + \frac{1}{n})\ln{n} \approx 1.33 \log{n}
$$

### AVL树

#### AVL树的定义

- 也叫平衡树
  - 对于任意一个节点的两棵子树的高度至多相差1
- 平衡因子
  - 节点的左子树的高度减去右子树的高度
  - 平衡因子只能是 $-1$，$0$，$1$
- 优点
  - 查找，插入和删除操作的时间复杂度都是 $O(\log n)$

##### 查找性能

- 与二叉树的高度成正比

- 定理：
  - 具有 $n$ 个节点的平衡树，高度 $h$ 满足 $\log_2(n+1) \leq h \leq 1.44\log_2(n+2)-0.328$
  - 因此，平衡二叉树的操作都是 $O(\log n)$

##### 斐波那契树

- 斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为1

- 定义
  1. 空树是高度为0的斐波那契树
  2. 单个节点是高度为1的斐波那契树
  3. 若 $T_{h-1}$ 和 $T_{h-2}$ 分别为高度为 $h-1$ 和 $h-2$ 的斐波那契树，则 $T_h ={T_{h-1},x,T_{h-2}}$ 是高度为 $h$ 的斐波那契树
  4. 没有其他的树是斐波那契树

###### 斐波那契树的特点

对于高度为 $h$ 的斐波那契树，节点数 $n$ 满足

- $n_0 = 0$
- $n_1 = 1$
- $n_h = n_{h-1} + n_{h-2} + 1$

#### AVL树的存储实现

- 使用二叉链表
- 每个节点必须保存平衡信息
  - 每棵树的高度
  - 平衡度即左右子树的高度差

##### AVL树类的实现

```cpp
template <clas KEY,class OTHER>
class AvlTree:public dynamicSearchTable<KEY , OTHER>
{
    struct AvlNode
    {
      SET<KEY , OTHER> data ; // 关键字
      AvlNode *left , *right; // 左右子树指针
      int height;            // 节点高度
  
      AvlNode(const SET<KEY , OTHER> &element , AvlNode *lt ,AvlNode   *rt , int h = 1):data(elemeent) , left(lt) , right(rt) , height  (h) {} // 构造函数
    };
  
    AvlNode *root; // 根节点
  public:
    AvlTree() // 构造函数
    {
      root = nullptr;
    }
    ~AvlTree() // 析构函数
    {
      makeEmpty(root);
    }
    SET<KEY, OTHER> *find(const KEY &x) const;
    void remove(const KEY & x);
  private:
    void insert( const SET<KEY, OTHER> & x, AvlNode * & t ) ; // 插入
    bool remove( const KEY & x, AvlNode * & t ) ;
    void makeEmpty( AvlNode *t );
    int height(AvlNode *t) const  // 返回节点的高度
    {
      return t == nullptr ? 0 : t -> height;
    }
    void LL( AvlNode * & t ); // 左旋
    void RR( AvlNode * & t ); // 右旋
    void LR( AvlNode * & t ); // 左右旋
    void RL( AvlNode * & t ); // 右左旋
    int max(int a, int b)     // 返回两个数中较大的一个
    {
      return a > b ? a : b;
    }
    bool adjust(AvlNode *&t, int subTree); //用于删除
};  
```

#### AVL树的查找

- 与二叉查找树相同
- 二叉查找树类采用递归实现
- AVL树类展示非递归实现

##### 查找的非递归实现

1. 设当前节点为根节点
2. 若当前节点非空
   1. 若当前节点的值等于 `x`，则返回当前节点
   2. 若当前节点的值大于 `x`，则将当前节点指向左子树
   3. 若当前节点的值小于 `x`，则将当前节点指向右子树
3. 若当前节点为空，则返回空

```cpp
template <class KEY,class OTHER>
SET<KEY, OTHER> *AvlTree<KEY, OTHER>::find(const KEY & x) const
{
  AvlNode *t = root; 
  while (t!=nullptr && t->data.key != x) 
  {
    if (x < t->data.key) 
    {
      t = t->left;
    }
    else
    {
      t = t->right;
    }
  }
  if (t == nullptr)
  {
    return nullptr;
  }
  else
  {
    return t->data;
  }
}
```

#### AVL树的插入

- 与二叉查找树相同
  - 可能改变了根到插入节点的路径上某些节点的平衡度
  - 需要向上修改树的结构

##### 可能引起节点不平衡的情况

- 节点的左孩子的左子树上插入（LL）
- 节点的左孩子的右子树上插入（LR）
- 节点的右孩子的左子树上插入（RL）
- 节点的右孩子的右子树上插入（RR）

##### 重构的方法

- 指针调整
  - 按照投影序保持结点相邻关系不变
  - 辈分可以改变

###### LL问题

![LL](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png)

- **左旋**
  1. 将失衡点的左儿子作为新的根节点
  2. 左儿子的右儿子作为原根节点的左儿子
- 若为RR问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为**右旋**
- 左旋和右旋统称为**单旋转**，保留了树的有序性和原先的高度

###### LR问题

![LR](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png)

- **双旋转**
  1. 将失衡点的左儿子右旋
  2. 将失衡点左旋
- 若为RL问题，则将失衡点的右儿子左旋，再将失衡点右旋
- 先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使**原先的孙子变成根**

##### 私有的`insert` 函数

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY, OTHER>::insert(const SET<KEY, OTHER> & x, AvlNode * & t)
{
  if (t == nullptr)
  {
    t = new AvlNode(x , nullptr , nullptr);
  }
  else if (x.key < t->data.key)
  {
    insert(x , t->left);
    if (height(t->left) - height(t->right) == 2)
    {
      if (x.key < t->left->data.key)
      {
        LL(t);
      }
      else
      {
        LR(t);
      }
    }
  }
  else if (x.key > t->data.key)
  {
    insert(x , t->right);
    if (height(t->right) - height(t->left) == 2)
    {
      if (x.key > t->right->data.key)
      {
        RR(t);
      }
      else
      {
        RL(t);
      }
    }
  }
  t->height = max(height(t->left) , height(t->right)) + 1; // 更新高度
}
```

###### `LL`

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY,OTHER>::LL(AvlNode *& t)
{
  AvlNode *t1 = t->left;
  t->left = t1->right;
  t1->right = t;
  t->height = max(height(t->left) , height(t->right)) + 1;
  t1->height = max(height(t1->left) , height(t1->right)) + 1;
  t = t1;
}
```

###### `RR`

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY,OTHER>::RR(AvlNode *& t)
{
  AvlNode *t1 = t->right;
  t->right = t1->left;
  t1->left = t;
  t->height = max(height(t->left) , height(t->right)) + 1;
  t1->height = max(height(t1->left) , height(t1->right)) + 1;
  t = t1;
}
```

###### `LR`

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY,OTHER>::LR(AvlNode *& t)
{
  RR(t->left);
  LL(t);
}
```
###### `RL`

```cpp
template <class KEY,class OTHER>
void AvlTree<KEY,OTHER>::RL(AvlNode *& t)
{
  LL(t->right);
  RR(t);
}
```

所有旋转的算法时间复杂度都是 $O(1)$，且只运行一次，所以 `insert` 的时间复杂度为 $O(\log n)$

#### AVL树的删除

1. 在AVL树上删除节点 `x`，删除操作和二叉查找树相同
2. 调整平衡，与插入操作相同

#### 调整

- 与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度
- 删除时无法保证子树在平衡调整之后的高度不变
- 递归的删除函数有一个 bool 型的返回值，当返回值为 `true` 时，调整停止

#### 五种情况

##### 情况a

![Sitiationa](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png)

此时没有失衡，高度也没有改变，返回`true`

##### 情况b

![Situationb](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png)

此时没有失衡，但是高度变矮，返回`false`

##### 情况c

![Situationc](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png)

经过RR旋转后高度变矮，返回`false`

##### 情况d

![Situationd](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png)

经过RL旋转后高度变矮，返回`false`

##### 情况e

![Situatione](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png)

经过RR或RL旋转后高度不变，返回`true`

#### 删除总结

- 节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回 `false`
- 在每次调用后，检查返回值，如果是 `true`，则返回 `true`，否则分5种情况进行处理

#### 私有的 `remove` 函数

```cpp
template<class KEY,class OTHER>
void AvlTree<KEY , OTHER>::remove(const KEY &x , AvlNOde *&x)
{
  if (t = nullptr) // 被删除节点不存在
  {
    return true;
  }
  if (x == t-> data.key)
  {
    if (t->left == nullptr || t-> right == nullptr)
    {
      AvlNode *oldNode = t;
      t = (t->left == nullptr) ? t->right : t->left; // 删除节点的孩子节点
      delete oldNode;
      return false; // 删除了一个节点，返回 `false`
    }
    else
    {
      AvlNode *tmp = t-> right;
      while (tmp->left != nullptr) // 找到右子树的最小节点
      {
        tmp = tmp->left;
      }
      t->data = tmp.data;
      if (remove(tmp->data,key , t->right))
      {
        return adjust(t,1);
      }
    }
  }
  if (x < t->data,key)
  {
    if (remove(x,t->left))
    {
      teturn true;
    }
    return adjust(t,0);
  }
  else
  {
    if (remove(x , t->right))
    {
      return true;
    }
    return adjust(t,1);
  }
}
```

#### `adjust`

- 进入调整函数的条件是某棵子树变矮了
- 调整函数需要检查节点是否失衡，若失衡则进行相应的调整
- 函数的返回值是子树是否变矮
  - `true`：子树没有变矮
  - `false`：子树变矮
- 需要传入两个参数
  - `AVlNode *&t`：传入的节点
  - `int subTree`：参数 `t` 变矮的子树
    - `0`：左子树
    - `1`：右子树

```cpp
template<class KEY , classs OTHER>
bool AvlTree<KEY , OTHER>::adjust(AvlNode *&t , int SubTree)
{
  if (subTree) // 在右子树上删除
  {
    if (height(t->left) - height(t->right) == 1) // Situation a
    {
      return true;
    }
    if (height(t->right) == height(t->left)) // Situation b
    {
      return false;
    }
    if (height(t->left->right) > height(t->left->left)) // Situation d
    {
      LR(t);
      return false; 
    }
    LL(t); // Situation c and e
    if (height(t->left) == height(t->right))s
    {
      return false;
    }
    else
    {
      return true;
    }
  }
  else // 在左子树上删除
  {
    if (height(t->right) - height(t->left) == 1) // Situation a
    {
      return true;
    }
    if (height(t->right) == height(t->left)) // Situation b
    {
      return false;
    }s
    if (height(t->right->left) > height(t->right->right)) // Situation d
    {
      RL(t);
      return false;
    }
    RR(t); // Situation c and e
    if (height(t->right) == height(t->left))
    {
      return false;
    }
    else
    {
      return true;
    }
  }
}
```

### 散列表

- 也叫哈希表
- 通过所求节点的关键字词 `KEY` 找到这个节点
- 时间复杂度为 $O(1)$

#### 基本概念

1. 初始化
  将数组转化为一个特殊的、表示单元为空的值
2. `insert(i)`
  将 `i` 存放到  `a[i.key]` 中
3. `find(i)`
   取出 `a[i.key]` 中的值
4. `remove(i)`
   将 `a[i.key]` 中的值置为空

#### 散列函数

将一个项映射成一个较小的下标的函数称为散列函数（hush function）

- $D = H(key)$
  D为存储地址，key为关键值，H为散列函数
- 散列函数的要求
  - 计算速度快
  - 散列地址均匀分布

#### 常用的散列函数

##### 直接地址法

$H(key) = key$ 或 $H(key) = a \times key + b$

##### **除留余数法**

$H(key) = key \mod p$ 或 $H(key) = key \mod p + c$ 这里的 $p$ 是一个小于等于 $m$ 的素数

##### 数字分析法

对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分

##### 平方取中法

如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字**平方后**，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。

##### 折叠法

- 如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法
- 选取一个长度后，将关键字按此长度分组相加

#### 冲突问题

当两个以上的关键字映射到一个存储单元时，称为**冲突或碰撞**

- 解决冲突的方法
  - 闭散列表：利用本散列表中的空余单元
    - 线性探测法
    - 二次探测法
    - 再次散列法
  - 开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）

##### 闭散列表类的实现

- 支持三种操作
  - `insert`：插入一个元素
  - `remove`：删除一个元素
  - `find`：查找一个元素
- 由一个数组实现，数组的大小由用户定义散列表时指定
- 由于删除时的迟删除，每个数组元素还要保存一个状态值
  - `0`：空
  - `1`：有效
  - `2`：删除

```cpp
template <class KEY, class OTHER>
class closeHashTable:public dynamicSearchTable<KEY, OTHER>
{
  private:
    struct node  //散列表的结点类
    { 
      SET <KEY, OTHER> data;
      int state; //0 -- empty 1 -- active 2 -- deleted
      node()
      {
        state = 0;
      }
    };
    node *array;
  
    int size;
    int (*key)(const KEY &x);//哈希函数
    static int defaultKey(const int &x)
    {
      return x;
    }
  public:
    closeHashTable(int length = 101, int (*f)(const KEY &x) = defaultKey)
    ~closeHashTable()
    {
      delete [] array;
    }
    SET<KEY, OTHER> *find(const KEY &x) const;
    void insert(const SET<KEY, OTHER> &x);
    void remove(const KEY &x);
};
```
- 构造函数

```cpp
template <class KEY, class OTHER>
closeHashTable<KEY, OTHER>::closeHashTable(int length, int (*f)(const KEY &x))
{
  size = length;
  array = new node[size];
  key = f; //哈希函数为f
}
```

- `insert`

```cpp
template <class KEY, class OTHER>
void closeHashTable<KEY, OTHER>::insert(const SET<KEY, OTHER> &x)
{
  int initPos, pos ;
  initPos= pos = key(x.key) % size; //%size保护作用，避免越界
  do
  {
    if (array[pos].state != 1)
    { // 0或2，找到空单元
      array[pos].data = x;
      array[pos].state = 1;
      return;
    }
    pos = (pos+1) % size;
  } while (pos != initPos);
}
```

- `remove`

```cpp
template <class KEY, class OTHER>
void closeHashTable<KEY, OTHER>::remove(const KEY &x)
{
  int initPos, pos ;
  initPos= pos = key(x) % size;
  do
  {
    if (array[pos].state == 0) return; //没找到
    if (array[pos].state == 1 && array[pos].data.key== x)// 找到，删除
    {
      array[pos].state = 2;
      return;
    }
    pos = (pos+1) % size; //没找到，需要往后找
  } while (pos != initPos);
}
```

- `find`

```cpp
template <class KEY, class OTHER>
SET<KEY, OTHER> *closeHashTable<KEY, OTHER>::find(const KEY &x) const
{
  int initPos, pos ;
  initPos = pos = key(x) % size;
  do
  {
    if (array[pos].state == 0) // 没有找到
    {
      return nullptr;
    }
    if (array[pos].state == 1 && array[pos].data.key == x) // 找到
    {
      return (SET<KEY,OTHER> *)&array[pos];
    }
    pos = (pos+1) % size;
  } while (pos != initPos);
}
```

###### 线性探测法

当散列发生冲突时，依次**探测下一个单元**，直到发现一个空单元

![线性探测法](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504210826498.png)

###### 二次探测法

以此向后探测 $1^2$，$2^2$，$3^2$，$4^2$，$5^2$，$\ldots$

**定理**

- 如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子 $<0.5$），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次

###### 再次散列法

- 采用一个新的散列函数 $H_2(key)$
- $H_1(x)$，$H_1(x)+H_2(x)$ ，$H_1(x)+2H_2(x)$，$H_1(x)+3H_2(x)$，$\ldots$

##### 开散列表

链地址法

- 将具有同一散列地址的结点保存于 `M` 存区的各自的链表之中

###### 开散列表的实现

- 将所有散列到同一地址的元素链接成一个单链表
- 采用不带头结点的单链表
- 散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针

```cpp
template <class KEY , class OTHER>
class openHashTable:public dynamicSearchTable<KEU , OTHER>
{
  private:
    struct node
    {
      SET<KEY , OTHER> data;
      node *next;
      node (const SET<KEY , OTHER> &d , nde *n = nullptr)
      {
        data = d;
        next = n;
      }
      node()
      {
        next = nullptr;
      }
    };
    node **array; // 散列表，指针数组
     int size;
     static int defaultKry(const int &x)
     {
        return x;
     }
  public:
    openHashTable(int length = 101,int (*f)(const KEY &x) = defaultKey);
    ~openashTable();
    SET<KEY,OTHER> *finf(const KEY &x) const;
    void insert(const SET<KEY,OTHER> &x);
    void remove(const KEY &x);
};
```

- 构造函数

```cpp
template <class KEY, class OTHER>
openHashTable<KEY, OTHER>::~openHashTable()
{
  node *p, *q;
  for (int i = 0; i< size; ++i)
  { 
    p = array[i];
    while (p!=nullptr)
    { 
      q= p->next; delete p; p = q;
    }
  }
  delete [] array；
}
```

- `insert`

```cpp
template <class KEY, class OTHER>
void openHashTable<KEY, OTHER>::insert(const SET<KEY, OTHER> &x)
{
  int pos;
  node *p;
  //插入单链表的头部
  pos = key(x.key) % size;
  array[pos] = new node(x, array[pos]);
}
```

- `remove`

```cpp
template <class KEY, class OTHER>
void openHashTable<KEY, OTHER>::remove(const KEY &x)
{
  int pos ;
  node *p, *q;
  pos = key(x) % size;
  if (array[pos] == nullptr)
  {
    return;
  }
  p = array[pos];
  if (array[pos]->data.key== x)
  { // 删除第一个结点
    array[pos] = p->next;
    delete p;
    return;
  }
  while (p->next != nullptr && !(p->next->data.key== x))
  {
    p = p->next;
  }
  if (p->next != nullptr)
  {
    q = p->next;
    p->next = q->next;
    delete q;
  }
}
```

- `find`

```cpp
template <class KEY, class OTHER>
SET<KEY, OTHER> *openHashTable<KEY, OTHER>::find(const KEY &x) const
{
  int pos ;
  node *p;
  pos = key(x) % size;
  p = array[pos];
  while (p != nullptr && !(p->data.key == x))
  {
    p = p->next;
  }
  if (p == nullptr)
  {
    return nullptr;
  }
  else
  {
    return (SET<KEY, OTHER> *)p;
  }
}
```

## 排序

### 基本概念

- 按照关键字的非递减或非递增序排成一个序列
- **稳定与非稳定排序**:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序
- 内排序与外排序
  - **内排序：**排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置
  - **外排序：**在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置

### 插入排序

首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的n-1个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的

#### 直接插入排序

```cpp
template <class KEY, class OTHER>
void simpleInsertSort(SET<KEY, OTHER>a[], int size)
{
  int k;
  SET<KEY, OTHER> tmp;
  for (int j=1; j<size; ++j)
  {
  tmp = a[j];
  for ( k = j-1; tmp.key < a[k].key && k >= 0; --k)
  {
    a[k+1] = a[k];
  }
  a[k+1] = tmp;
  }
}
```

- 空间复杂度：$O(1)$
- 稳定性：稳定
- 时间复杂度
  - 最好：$O(n)$
  - 最坏：$O(n^2)$
  - 平均：$O(n^2)$
- 适用情况：短序列或者几乎已经排好序的

#### 折半插入排序

先用二分排序找到插入位置

- 时间复杂度
  - 最好：$O(n\log n)$
  - 最坏：$O(n^2)$
  - 平均：$O(n^2)$
- 空间复杂度：$O(1)$
- 稳定性：稳定

改进很小，对于接近排好序的序列甚至**更差**

#### 希尔排序

- 相隔一定的距离的记录组成一个子序列
- 逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态
- 最后再用直接插入排序对整个序列进行一次排序

##### 步长序列的选择

- $1,2,4,8,\ldots$
- 时间复杂度：$O(n^2)$

- Knuth推荐：$1,3,7,15,31,63,\ldots$
- 时间复杂度：$O(n^{1.5})$
- 空间复杂度：$O(1)$
- 不稳定

```cpp
template <class KEY, class OTHER>
void shellSort(SET<KEY, OTHER> a[], int size)
{
  int step, i, j;
  SET<KEY, OTHER> tmp;
  for (step = size/2; step > 0; step /= 2) //step为希尔增量
  {
    for (i = step; i < size; ++i)
    {
      tmp = a[i];
      for (j = i -step; j >= 0 && a[j].key > tmp.key; j -= step)
      {
        a[j+step] = a[j];
      }
      a[j+step] = tmp;
    }
}
```

### 选择排序

1. 在 $n$ 个元素中选出最小的元素
2. 从剩下的 $n-1$ 个元素中选出最小的元素
3. 以此类推，直到最后一个元素

#### 直接选择排序

1. 在所有元素中逐个比较找到最小元素，与第一个元素交换
2. 在剩下的元素中逐个比较找到最小元素，与第二个元素交换
3. 以此类推，直到最后一个元素

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$
- 不稳定

```cpp
template <class KEY, class OTHER>
void simpleSelectSort(SET<KEY, OTHER> a[], int size)
{
  int i, j, min;
  SET<KEY, OTHER> tmp;
  for (i = 0; i < size -1; ++i)
  {
  min = i;
  for (j = i+1; j < size; ++j)
  {
    if (a[j].key < a[min].key)
    {
      min = j;
    }
  }
  tmp = a[i]; a[i] = a[min]; a[min] = tmp;
  }
}
```

#### 堆排序

1. 建立一个最大堆
2. 执行 $n$ 次 `deQuqeue` 操作取出每个项

- 时间复杂度 $O(n\log n)$

- 堆排序

```cpp
template <class KEY, class OTHER>
void heapSort(SET<KEY, OTHER> a[], int size)
{
  int i;
  SET<KEY, OTHER> tmp; // 创建初始的堆
  for( i = size / 2 -1; i >= 0; i--)
  {
    percolateDown( a, i, size );
  }
  //执行n-1次deQueue
  for ( i = size -1; i > 0; --i)\
  {
  tmp = a[0]; a[0] = a[i]; a[i] = tmp; //delete a[0]
  percolateDown( a, 0, i );
  }
}
```

- `precolateDown`

```cpp
template <class KEY, class OTHER>
void percolateDown( SET<KEY, OTHER> a[], int hole, int size)
{
  int child;
  SET<KEY, OTHER> tmp= a[ hole ];
  for( ; hole * 2 + 1 < size; hole = child )
  {
    child = hole * 2 + 1;
    if( child != size -1 && a[ child + 1 ].key > a[ child ].key )
    {
      child++;
    }
    if( a[ child ].key >tmp.key)
    {
      a[ hole ] = a[ child ];
    }
    else
    {
      break;
    }
  }
  a[ hole ] = tmp;
}
```

### 交换排序

通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动

#### 冒泡排序

从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡

然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置

依次类推，经过第 $n-1$ 趟起泡，将倒数第 $n-1$ 个大的元素放入第2个单元

```cpp
template <class KEY, class OTHER>
void bubbleSort(SET<KEY, OTHER> a[], int size)
{
  int i, j;
  SET<KEY, OTHER> tmp;
  bool flag = true; //记录一趟起泡中有没有发生过交换
  for (i = 1; i < size&& flag; ++i)
  { //size-1次起泡
    flag = false;
    for (j = 0; j < size-i; ++j) //第i次起泡
    if (a[j+1].key < a[j].key)
    {
      tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp;
      flag = true;
    }
  }
}
```

#### 快速排序

- 选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边
- 然后对基准元素左边和右边的子序列进行递归排序

##### 选择中心点

- 第一个元素
- 随机
- 中值（采样得到）

##### 划分（第一个元素为中心点）

1. 序列的下标上界为 `high`，下届为 `low`，中心点选取第一个元素，关键值为 `K`，`low` 位置空出
2. 从右向左开始检查：如果 `high` 的关键值大于 `K`，该位置中的值位置正确，`high` 减 $1$，继续往前检查，直到遇到一个小于 `K` 的值
3. 将小于 `k` 的这个值放入 `low` 的位置，此时 `high` 的位置又空出。然后从 `low` 位置开始从左向右检查，直到遇到一个大于 `K` 的值
4. 将 `low` 位置的值放入 `high` 位置，重复第2步，直到 `low` 和 `high` 重叠，将 `K` 放入此位置

划分函数的实现

```cpp
template <class KEY, class OTHER>
int divide( SET<KEY, OTHER> a[], int low, int high)
{
  SET<KEY, OTHER> k = a[low];
  do
  {
    while (low < high && a[high].key >= k.key)
    {
      --high;
    }
    if (low < high)
    {
      a[low] = a[high]; ++low;
    }
    while (low < high && a[low].key <= k.key)
    {
      ++low;
    }
    if (low < high)
    {
      a[high] = a[low]; --high;
    }
  } while (low != high);
  a[low] = k;
  return low;
}
```

### 归并排序

- 将待排序的序列分成两个子序列，分别进行排序
- 将两个有序的子序列合并成一个有序的序列
- 递归进行

### 基数排序

- 称为口袋排序法
- 通过分配的方法进行排序
- 基数（r）：子关键字的值域的元素的个数
  - 十进制数：$0,1,2,\ldots,9$，基数为 $10$
  - 二进制数：$0,1$，基数为 $2$
  - 英文字符：$A,B,C,\ldots,Z$，基数为 $26$

#### 高位优先法（MSD）

- 先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列

#### 低位优先法（LSD）

- 先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起
- 然后将次低位进入口袋进行排序，依次类推
- 最后将所有记录按照口袋的顺序收在一起

## 外存储器中的查找和排序

### 主存储器与外存储器

- 主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据
- 外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息
  - 价格低廉、存储量大、永久保存、**访问速度慢**

### 外部查找

#### B树

B树是一棵平衡的M叉查找树，需要 $M-1$ 个关键字来判断到哪个分支查找

##### B树的定义

- 一棵 $m$ 阶B树要么为空，要么满足一下条件
  - 根节点要么是叶节点，要么至少有两个儿子，至多有 $m$ 个儿子
  - 每个非根节点至少有 $\lceil m/2 \rceil$ 个儿子，至多有 $m$ 个儿子
  - 有 $s$ 个儿子的非叶节点具有 $n=s-1$ 个关键字
  - 所有的叶子节点都出现在同一层上

##### B树的插入

- 在最底层进行插入

1. 在 $m$ 阶B树上进行查找操作，确定新插入的关键字 `key` 在最底层非叶节点的插入位置
2. 如果被插入节点的关键字个数小于等于 $m-1$，则插入结束
3. 如果被插入节点的关键字个数大于 $m-1$，则需要进行分裂
  - 被插入节点分为三个部分
    - 前半部分：前 $m/2$ 个关键字
    - 中间部分：中间的关键字
    - 后半部分：后 $m/2$ 个关键字
  - 中间部分的关键字上升到父节点
  - 前后半部分生成新的两个节点

##### B树的删除 

- 采用替身法，替身为右子树的最小值或者左子树的最大值

1. 删除节点，替身进入
2. 如果删除后的替身原来在的节点满足，则直接删除
3. 如果删除后的关键字小于下限，
   - 向该节点的左或右兄弟借一个关键字
   - 如果兄弟节点的关键字个数等于下限，则需要进行合并

##### M的选择

#### B+树

B+树是既能提供随机查找，也能提供顺序访问的存储结构

##### B+树的定义

- 所有数据都记录在叶节点中，所有叶节点连成一个单链表
- 非叶节点至多保存 $m-1$ 个关键字来引导查找，键 $i$ 表示子树 $i+1$ 中键的最小值
- 根节点或者是叶节点，或者有 $2$ 到 $m$ 个子树
- 除了根节点之外的所有非叶节点至少有 $m/2$ 个儿子，最多有 $m$ 个儿子
- 所有的叶节点都在同一层上，并且每个叶子有 $\lceil L/2 \rceil$ 到 $L$ 个关键字

##### B+树的插入

- 叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序
- 叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项
  - 更新父结点
  - 如果父亲的儿子数量已经满了，就继续分裂父亲

### 外排序

一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O操作）

#### 外排序模型

- 外排序由两个阶段组成
  1. 预处理阶段：根据内存的大小将一个有n个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段
  2. 归并阶段：将这些有序片段逐步归并成一个有序文件

减少 I/O 操作的关键

1. 减少归并轮数
2. 减少有序片段数量
3. 增加合并路数

#### 预处理

##### 减少有序片段数量

- 每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少
- 最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段

##### 置换排序

置换选择可以在只能容纳 $p$ 个记录的内存中生成平均长度为 $2p$ 的初始的已排序片段

只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段

具体方法

1. 初始时，将 $m$ 个元素读入内存，用 `buildHeap` 建立一个优先级队列
2. 执行一次 `deQuqeue`，将最小的元素写入输出文件
3. 从输入磁带读入下一个元素
   - 如果它比刚才写进去的元素大，那么将它加入到优先级队列中
   - 否则，则无法写入队列，进行下一次 `deQuqeue`
4. 重复第2、3步，直到输入文件读完
5. 重新执行 `buildHeap`，使用存放在空余位置中的元素

#### 归并

##### 二路归并

- 归并时，每次将两个有序文件归并为一个有序文件
- 如果生成的有序片段数量为  $M$，则归并次数为 $\lceil \log_2 M \rceil$

##### 多路归并

- 归并时，每次将 $k$ 个有序文件归并为一个有序文件
- 优点：减少归并次数，为 $\lceil \log_k M \rceil$ 次
- 缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列

##### 多阶段归并

- 可以仅使用 $K+1$ 条磁带实现 $K$ 路归并，称为**多阶段归并**

**实现的过程**

1. 按照非均匀的方法分解原来的已排序的片段
2. 将每个片段分成 $K$ 个子片段

## 图

### 图的定义

- 图可以用 $G=(V, E)$ 表示。其中，$V$ 是顶点集，$E$ 是边集。
- 如果边是有方向的，称为**有向图**.有向图的边用 $\langle \rangle$ 表示
  - $\langle A, B \rangle$ 表示从 $A$ 到 $B$ 的一条边
- 如果边是无方向的，称为**无向图**.无向图的边用 $()$ 表示
  - $(A, B)$ 表示 $A$ 和 $B$ 之间有一条边
  - 无向图也称为双向图
- **加权图：** 边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图
  - 加权图中边的表示：$(V_i,V_j,W)$

### 图的基本术语

- 邻接
  - 若 $(V_i,V_j)$ 是图 $G$ 的一条边，则称 $V_i$ 和 $V_j$ 是邻接的；若 $\langle V_i,V_j \rangle$ 是图 $G$ 的一条边，则称 $V_i$ 邻接到 $V_j$，$V_j$ 和 $V_i$ 邻接
- 度
  无向图中邻接与某一顶点的边的总数
- 入度
  有向图中进入某一顶点的边数
- 出度
  有向图中离开某一顶点的边数
- 边与度的关系
  $\displaystyle e=\frac{1}{2}\sum_{i=1}^n d_i$，其中 $e$ 是边数，$d_i$ 是顶点 $V_i$ 的度

#### 子图

设有两个图 $G_1=(V_1,E_1)$ 和 $G_2=(V_2,E_2)$，如果 $V_1 \subseteq V_2$，$E_1 \subseteq E_2$，则称 $G_1$ 是 $G_2$ 的子图

#### 路径和路径长度

- 对于 $1<i<N$，顶点序列 $w_1,w_2,\ldots,w_N$ 中的顶点对 $(w_i,w_{i+1})$ 都有 $(W_i,w_{i+1})\in E$ 或 $\langle w_i,w_{i+1} \rangle \in E$，则称 $w_1,w_2,\ldots,w_N$ 是图中的一条**路径**
- **非加权的路径长度**就是组成路径的边数，对于路径 $w_1,w_2,\ldots,w_N$，路径长度为 $N-1$
- **加权的路径长度**是指路径上所有边的权值之和
- **简单路径和环：** 如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为 $1$

#### 无向图的连通性

- **连通：** 顶点 $V$ 和顶点 $V'$ 之间又路径存在
- **连通图：** 无向图 G 的任意两点之间都是连通的
- **连通分量：** 非连通图中的极大连通子图

#### 有向图的连通性

- **强连通图：** 有向图 G 的任意两点之间都是连通的，则称 G 是强连通图
- **强连通分量：** 极大连通子图
- **弱连通图：** 如有向图 G 不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的

#### 完全图

- **完全图：** 每两个顶点之间都有边的无向图称为完全图。完全图有 $\frac{n(n-1)}{2}$ 条边，即 $C_n^2$
- **有向完全图：** 每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 $n(n-1)$ 条边，即 $P_n^2$
- **有向无环图：** 不含环的有向图

#### 生成树与最小生成树

- **生成树**是图 G 的**极小**连通子图 G'，其中 $V(G')=V(G)$
- 用一棵树把图 G 的所有顶点都连起来，并且没有回路
- 生成树有 $n$ 个顶点，$n-1$ 条边
- 生成树可以有多个
- **最小生成树**是所有生成树中权值之和最小的生成树

### 图的运算

- 常规操作
  - 构造一个由若干个顶点、若干条边组成的图
  - 判断两个顶点之间是否有边存在
  - 在图中添加或删除一条边
  - 返回图中的顶点数或边数
  - 按某种规则**遍历**图中的所有顶点
- 和应用紧密结合的运算
  - 拓扑排序和关键路径
  - 找最小生成树
  - 找最短路径等

### 图的抽象类

```cpp
template <class TypeOfVer, class TypeOfEdge>
class graph
{
  public:
    virtual void insert(TypeOfVer x, TypeOfVer y, TypeOfEdge w) = 0;
    virtual void remove(TypeOfVer x, TypeOfVer y) = 0;
    virtual bool exist(TypeOfVer x, TypeOfVer y) const = 0;
    int numOfVer() const
    {
      return Vers;
    }
    int numOfEdge() const
    {
      return Edges;
    }
 
  protected:
    int Vers, Edges;
};
```

### 图的存储

#### 邻接矩阵和加权邻接矩阵

##### 有向图的邻接矩阵

设有向图有 $n$ 个顶点，则用一个 $n \times n$ 的布尔矩阵 $A$ 来表示该有向图

![有向图的邻接矩阵](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212328867.png)

- 分别使用 $0,1,2,\ldots,n-1$ 表示 顶点 $V_0,V_1,\ldots,V_{n-1}$，如果存在一条从 $V_i$ 到 $V_j$ 的边，则 $A[i][j]=1$，否则 $A[i][j]=0$
- 出度：$i$ 行之和
- 入度：$j$ 列之和
- 真正的顶点数据字段之值放入一个一维数组之中

##### 无向图的邻接矩阵

设无向图有 $n$ 个顶点，则用一个 $n \times n$ 的布尔矩阵 $A$ 来表示该无向图

![无向图的邻接矩阵](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212332916.png)

- 分别使用 $0,1,2,\ldots,n-1$ 表示 顶点 $V_0,V_1,\ldots,V_{n-1}$，如果存在一条从 $V_i$ 到 $V_j$ 的边，则 $A[i][j]=A[j][i]=1$，否则 $A[i][j]=A[j][i]=0$
- 顶点 $i$ 的度：第 $i$ 行或第 $i$ 列之和
- 无向图的邻接矩阵是一个三角对称矩阵

##### 邻接矩阵的特点

- 优点：判断任意两点之间是否有边方便，仅耗费 $O(1)$ 时间
- 缺点：即使 $\ll n_2$ 条边，也需内存 $n_2$ 单元，太多; 仅读入数据耗费 $O(n_2)$ 时间，太长。而大多数的图的边数远远小于 $n_2$。**适合稠密网**
- 不适合增减顶点

#### 邻接表

- 设有向图或者无向图由 $n$ 个顶点，则用**顶点表**和**边表**来表示该有向图或无向图
- **顶点表：** 用数组或单链表的形式存放所有的顶点
  - 如果顶点数 $n$ 已知，则采用数组
  - 如果顶点数未知，则采用单链表
  - 每个元素包含两个部分
    - 顶点值
    - 指向该顶点对应的边表的首地址
- **边表：** 每条边用一个节点进行表示

  同一个顶点出发的所有的边形成它的边界点单链表

![邻接表](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505222230615.png)

#### 邻接表的特点

- 邻接表是图的**标准**存储方式
- 优点
  - $\text{内存} = \text{顶点数} +\text{边数}$，时间复杂度为 $O\left(\vert V\vert +\vert E\vert \right)$，**适合稀疏网**
- 当谈及图的线性算法时，一般指的是 $O\left(\vert V\vert +\vert E\vert \right)$
- 缺点
  - 确定 $i\rightarrow j$  是否有边，最坏需耗费 $O(n)$ 时间
  - 无向图同一条边表示两次。边表空间浪费一倍
  - 有向图中寻找进入某结点的边，非常困难（逆邻接表）

### 图的遍历

按照某种次序系统地访问图中的所有顶点，并且使得**每个顶点需且只能被访问一次**

需对访问过的顶点加以**标记**

#### 深度优先搜索

1. 选中第一个被访问的顶点
2. 对顶点作已访问过的标志
3. 依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索

出现了问题

##### 存在的问题

<span id="DFSdamn">如果图不是连通或强连通，在进行 DFS 时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点</span>

##### 深度优先生成森林

在[这种情况](##图###图的遍历####深度优先搜索#####存在的问题)下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止

此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成**森林**

所以将深度优先搜索的流程改为

1. 选中第一个被访问的顶点
2. 对顶点作已访问过的标志
3. 依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索
4. 如果还有顶点未被访问，则选中一个起始顶点，转向2
5. 所有的顶点都被访问到，则结束

##### 深度优先搜索的实现

- 公有的 `dfs` 函数的伪代码

```cpp
void dfs()
{
  visited [v] =false; //对每个节点标记为未访问

  while(v=尚未访问的节点)
  {
    dfs(v,visited);
  }
}
```

- 私有的 `dfs` 函数的伪代码

```cpp
void dfs(v,visited)
{
  visited(v)=true;
  for 每个 v 的邻接点 w
  {
    if(!visited[w])
    {
      dfs(w,visited);
    }
  }
}
```

#### 广度优先搜索

1. 选中第一个被访问的顶点
2. 对顶点作已访问过的标志
3. 依次访问已访问顶点的未被访问过的第 $1$ 个、第 $2$ 个、第 $3$ 个、$\ldots$ 、第 $m$ 个邻接顶点 $W_1,W_2,W_3,\ldots,W_m$ ，进行访问且进行标记，转向3
4. 如果还有顶点未被访问，则选中一个起始顶点，转向2
5. 所有的顶点都被访问到，则结束

按照顶点序号小的先访问，大的后访问的原则以**队列**的形式实现

同样能够生成广度优先生成森林

##### 广度优先搜索的实现

1. 将序号最小的顶点放入队列
2. 重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问
   - 如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队
3. 检查是否还有顶点未被访问。如果有，重复上述两个步骤

```cpp
template <class TypeOfVer, class TypeOfEdge>
void adjListGraph<TypeOfVer, TypeOfEdge>::bfs() const
{
  bool *visited = new bool[Vers];
  int currentNode;
  linkQueue<int> q;
  edgeNode *p; 
  for (int i=0; i < Vers; ++i)
  {
   visited[i] = false;
  }
  cout << "当前图的广度优先遍历序列为："<< endl;
  for (i = 0; i < Vers; ++i)
  {
    if (visited[i] == true)
    {
      continue;
    }
    while (!q.isEmpty()) //连续访问队列的队头，将其拉出，若其后继非空则拉入队列
    {
      currentNode = q.deQueue();
      if (visited[currentNode] == true)
      {
        continue;
      }
      cout << verList[currentNode].ver <<'\t';
      visited[currentNode] = true;
      p = verList[currentNode].head;
      while (p != NULL)
      {
        if (visited[p->end] == false)
        q.enQueue(p->end);
        p = p->next;
      }
    }
    cout << endl;
  }
} 
```

### 图遍历的应用

#### 无向图的连通性

- 如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先**生成树**
- 如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先**生成森林**。每棵树就是一个**连通分量**。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量
- 在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量

#### 有向图的连通性

- 对有向图，深度优先搜索可以**测试是否强连通**，并**找出所有强连通分量**
  1. 从任意顶点开始**深度优先遍历** $G$
  2. 对森林中的每棵树进行**后序遍历**，并按遍历的顺序给每个顶点编号
  3. 将 $G$ 的每条边逆向，形成 $G_r$
  4. 从编号**最大**的顶点开始**深度优先遍历 $G_r$**。得到的深度优先遍历森林的每棵树就是 $G$ 的强连通分量

#### 欧拉回路

- 哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径

![哥尼斯堡七桥问题](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230120835.png)

#####  欧拉的证明

- 如果都是偶数桥，从任意地方出发都能回到原点 **（欧拉回路）**
- 如果都是偶数桥，从任意地方出发都能回到原点 **（欧拉路径）**
- 如果有奇数桥的地方不止两个，满足要求的路径是找不到的

##### 查找欧拉回路的基本想法

- 执行一次**不允许回溯**的 `DFS` ，也被称为一笔画问题
- 但是很多搜索都是不符合的

##### 解决方法

找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问

![欧拉回路解决方法](https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230128080.png)

#### 拓扑排序

设 $G=(V,E)$ 是一个具有 $n$ 个顶点的**有向无环图**

若 $V$ 中的顶点序列 $V_1,V_2,\ldots ,V_n$ 满足下列条件

- 在 $G$ 中，从 $V_i$ 到 $V_j$ 有一条路径
- 在序列中 $V_i$ 在 $V_j$ 之前

则称 $V_1,V_2,\ldots ,V_n$ 是 $G$ 的一个**拓扑排序**

拓扑排序将图转换为线性序，相对前去后继关系不变

##### 顶点活动网络（Activu on vertex network）

- 顶点表示各项子任务
- 有向边表示具有先决条件关系
- 仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施

**AOV**的特点

1. 有起始顶点
2. 无回路

##### 找出拓扑排序的过程

- 第一个输出的顶点必须无前驱，即入度为 $0$
- 无前驱以及后继的顶点在任何时候都可以输出
- 逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度 $-1$

##### 拓扑排序的实现

- 计算每个顶点的入度，保存在数组 `inDegree` 中
- 检查 `inDegree` 中的每个元素，将入度为 $0$ 的顶点入队
- 不断从队列中将入度为 $0$ 的顶点入队，输出此顶点，并将该顶点的入度 $-1$，如果某个邻接点的入度为 $0$，则将其入队

```cpp
template <class TypeOfVer, class TypeOfEdge>
void adjListGraph<TypeOfVer, TypeOfEdge>::topSort() const
{
  linkQueue<int> q;
  edgeNode *p;
  int current, *inDegree = new int[Vers];
  for (int i = 0; i < Vers; ++i)
  {
    inDegree[i] = 0;
  }
  for ( i = 0; i < Vers; ++i)
  {
    for (p = verList[i].head; p != NULL; p = p->next)
    {
    ++inDegree[p->end];
    }
  }                                                                 //计算入度
  for (i = 0; i < Vers; ++i)   if (inDegree[i] == 0) q.enQueue(i);  //入度0节点入队
  cout << "拓扑排序为：" << endl;
  while(!q.isEmpty())
  {
    current = q.deQueue( );
    cout << verList[current].ver << '\t';
    for (p = verList[current].head; p != NULL; p = p->next)
    if( --inDegree[p->end] == 0 )    q.enQueue( p->end );
  }                                                                 //出队，删除关联的边
  cout << endl;
} 
```

**时间复杂度：**

- 若图以邻接表表示
- 计算入度的时间复杂度为 $O(\vert V\vert +\vert E\vert)$，搜索入度为 $0$ 的顶点的时间复杂度为 $O(\vert V\vert)$，出队和删除边的时间复杂度为 $O(\vert E\vert)$，总执行时间为 $O(\vert V\vert +\vert E\vert)$

#### 关键路径

##### 边活动网络（Activity on Edge）

- **AOE网络：** 加权有向无环图
  - 顶点表示事件，边表示活动
  - 有向边的权值表示活动的持续时间
  - 有向边的方向表示事件发生的先后次序
  - 顶点的进入表示事件发生后允许开始的活动
  - 有一个源点、一个终点

##### 关键路径的定义

AOE 网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序

再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动
