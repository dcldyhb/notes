% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\documentclass[
  ignorenonframetext,
]{beamer}
\newif\ifbibliography
\usepackage{pgfpages}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\beamertemplatenavigationsymbolsempty
% remove section numbering
\setbeamertemplate{part page}{
  \centering
  \begin{beamercolorbox}[sep=16pt,center]{part title}
    \usebeamerfont{part title}\insertpart\par
  \end{beamercolorbox}
}
\setbeamertemplate{section page}{
  \centering
  \begin{beamercolorbox}[sep=12pt,center]{section title}
    \usebeamerfont{section title}\insertsection\par
  \end{beamercolorbox}
}
\setbeamertemplate{subsection page}{
  \centering
  \begin{beamercolorbox}[sep=8pt,center]{subsection title}
    \usebeamerfont{subsection title}\insertsubsection\par
  \end{beamercolorbox}
}
% Prevent slide breaks in the middle of a paragraph
\widowpenalties 1 10000
\raggedbottom
\AtBeginPart{
  \frame{\partpage}
}
\AtBeginSection{
  \ifbibliography
  \else
    \frame{\sectionpage}
  \fi
}
\AtBeginSubsection{
  \frame{\subsectionpage}
}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
\usepackage{caption}
% Make caption package work with longtable
\makeatletter
\def\fnum@table{\tablename~\thetable}
\makeatother
\usepackage{graphicx}
\usepackage{xeCJK}
\makeatletter
\newsavebox\pandoc@box
\def\pandoc@scaletofit#1{%
  \sbox\pandoc@box{\unexpanded{#1}}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={数据结构笔记},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{数据结构笔记}
\author{}
\date{}

\begin{document}
\frame{\titlepage}

\begin{frame}[fragile]{数据结构笔记}
\protect\phantomsection\label{ux6570ux636eux7ed3ux6784ux7b14ux8bb0}
\href{https://oi-wiki.org/ds}{oiWiki中的数据结构}

\begin{block}{引言}
\protect\phantomsection\label{ux5f15ux8a00}
\begin{block}{算法与数据结构}
\protect\phantomsection\label{ux7b97ux6cd5ux4e0eux6570ux636eux7ed3ux6784}
数据结构的研究内容

\begin{enumerate}
\tightlist
\item
  数据之间的\textbf{逻辑关系}，以及这种关系对应的操作
\item
  \textbf{储存实现}：数据及逻辑关系的存储
\item
  \textbf{运算实现}：具体存储模式下，运算的实现，即\textbf{算法}
\end{enumerate}

\begin{block}{数据的逻辑结构}
\protect\phantomsection\label{ux6570ux636eux7684ux903bux8f91ux7ed3ux6784}
\begin{itemize}
\tightlist
\item
  \textbf{集合结构}\\
  次序任意，元素之间除了\textbf{同处于一个集合内}之外没有任意其他的关系.
\item
  \textbf{线性结构}\\
  数据元素的\textbf{有序}排列，除了头尾的元素外其余元素都有一个前趋和一个后继.
\item
  \textbf{树形结构}\\
  除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.
\item
  \textbf{图形结构}\\
  每个元素的前趋和后继数量都不限\\
\end{itemize}
\end{block}

\begin{block}{数据结构的操作}
\protect\phantomsection\label{ux6570ux636eux7ed3ux6784ux7684ux64cdux4f5c}
\begin{itemize}
\tightlist
\item
  \textbf{创造}
\item
  \textbf{清除}
\item
  \textbf{插入}
\item
  \textbf{删除}
\item
  \textbf{更新}
\item
  \textbf{搜索}
\item
  \textbf{访问}
\item
  \textbf{遍历（traverse）}：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次
\item
  每一种数据结构的特定操作
\end{itemize}

数据结构的\textbf{五大类}：构建类、属性类、数据操纵类、遍历类、特定类
\end{block}
\end{block}

\begin{block}{存储实现}
\protect\phantomsection\label{ux5b58ux50a8ux5b9eux73b0}
\end{block}

\begin{block}{算法分析}
\protect\phantomsection\label{ux7b97ux6cd5ux5206ux6790}
\begin{block}{时间复杂度的概念}
\protect\phantomsection\label{ux65f6ux95f4ux590dux6742ux5ea6ux7684ux6982ux5ff5}
\begin{itemize}
\tightlist
\item
  是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，{}
\item
  算法的时间复杂度也与被处理的数据分布有关
\item
  算法的时间复杂度分为三种

  \begin{itemize}
  \tightlist
  \item
    最好的
  \item
    最坏的
  \item
    平均
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{算法运算量的计算}
\protect\phantomsection\label{ux7b97ux6cd5ux8fd0ux7b97ux91cfux7684ux8ba1ux7b97}
\end{block}

\begin{block}{渐进时间复杂度}
\protect\phantomsection\label{ux6e10ux8fdbux65f6ux95f4ux590dux6742ux5ea6}
\end{block}

\begin{block}{算法的优化}
\protect\phantomsection\label{ux7b97ux6cd5ux7684ux4f18ux5316}
\end{block}

\begin{block}{空间复杂度的概念}
\protect\phantomsection\label{ux7a7aux95f4ux590dux6742ux5ea6ux7684ux6982ux5ff5}
\begin{itemize}
\tightlist
\item
  渐进的空间复杂度
\item
  一般只考虑\textbf{辅助}空间的占用情况
\item
  空间复杂度一般按照最坏情况处理
\item
  空间复杂度的计算、表示方法与时间复杂度相同
\end{itemize}
\end{block}
\end{block}

\begin{block}{面向对象方法}
\protect\phantomsection\label{ux9762ux5411ux5bf9ux8c61ux65b9ux6cd5}
\begin{block}{类模板的定义}
\protect\phantomsection\label{ux7c7bux6a21ux677fux7684ux5b9aux4e49}
类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型

\begin{block}{定义格式}
\protect\phantomsection\label{ux5b9aux4e49ux683cux5f0f}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class 标识符\textgreater{}}
\NormalTok{class 类名}
\NormalTok{\{}
\NormalTok{    // 类成员声明}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{类定义的一般格式}
\protect\phantomsection\label{ux7c7bux5b9aux4e49ux7684ux4e00ux822cux683cux5f0f}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{class 类名}
\NormalTok{\{}
\NormalTok{  [private:]}
\NormalTok{    // 私有数据成员和成员函数声明}
\NormalTok{  public:}
\NormalTok{    // 公有数据成员和成员函数声明}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{虚函数}
\protect\phantomsection\label{ux865aux51fdux6570}
\begin{itemize}
\item
  在基类中用关键词 \texttt{virtual}
  声明的成员函数，并在派生类中重新定义的函数称为虚函数
\item
  虚函数的一般格式

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{virtual 返回类型 函数名(参数表)}
\NormalTok{\{}
\NormalTok{  // 函数体}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\item
  在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（\textbf{继承}）
\item
  当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数
\item
  虚函数在基类中有默认实现，派生类可以选择性地对其进行重写
\end{itemize}
\end{block}

\begin{block}{纯虚函数}
\protect\phantomsection\label{ux7eafux865aux51fdux6570}
\begin{itemize}
\item
  是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数
\item
  纯虚函数的一般形式

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{virtual 返回类型 函数名(参数表) = 0;}
\end{Highlighting}
\end{Shaded}
\item
  纯虚函数在基类中无实现，只有函数原型，派生类必须实现
\end{itemize}
\end{block}

\begin{block}{抽象类}
\protect\phantomsection\label{ux62bdux8c61ux7c7b}
\begin{itemize}
\tightlist
\item
  如果一个类中\textbf{至少有一个纯虚函数}，那么这个类就是抽象类
\item
  抽象类只能作为其他类的基类，不能建立抽象类的对象
\end{itemize}
\end{block}

\begin{block}{继承}
\protect\phantomsection\label{ux7ee7ux627f}
\begin{itemize}
\tightlist
\item
  在已有类的基础上建立新的类
\item
  基类（父类）和派生类（子类）
\item
  继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题
\end{itemize}

\begin{block}{派生类}
\protect\phantomsection\label{ux6d3eux751fux7c7b}
\begin{itemize}
\item
  一般格式

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{class 派生类名 : [派生方式] 基类名}
\NormalTok{\{}
\NormalTok{  // 派生类新增的数据成员和成员函数}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\item
  派生方法

  \begin{itemize}
  \tightlist
  \item
    公有派生：\texttt{public}
  \item
    私有派生：\texttt{protected}
  \item
    保护派生：\texttt{private}
  \end{itemize}
\item
  \texttt{class} 默认是 \texttt{private} 继承， \texttt{struct} 默认是
  \texttt{public} 继承
\end{itemize}

\begin{block}{派生类对基类成员的访问性}
\protect\phantomsection\label{ux6d3eux751fux7c7bux5bf9ux57faux7c7bux6210ux5458ux7684ux8bbfux95eeux6027}
\begin{longtable}[]{@{}cccc@{}}
\toprule\noalign{}
& \texttt{public} 继承 & \texttt{protected} 继承 & \texttt{private}
继承 \\
\midrule\noalign{}
\endhead
\texttt{public} 成员 & public & protected & private \\
\texttt{protected} 成员 & protected & protected & private \\
\texttt{private} 成员 & 不可访问 & 不可访问 & 不可访问 \\
\bottomrule\noalign{}
\end{longtable}
\end{block}
\end{block}
\end{block}

\begin{block}{类定义时常见的两种\texttt{const}用法}
\protect\phantomsection\label{ux7c7bux5b9aux4e49ux65f6ux5e38ux89c1ux7684ux4e24ux79cdconstux7528ux6cd5}
以函数 \texttt{int\ search(constelemType\&x)\ const} 为例

\begin{enumerate}
\tightlist
\item
  修饰参数 \texttt{x} 的 \texttt{const} 和 \texttt{\&} 组合

  \begin{itemize}
  \tightlist
  \item
    \texttt{const} 修饰参数 \texttt{x}，表示函数 \texttt{search}
    不会修改参数 \texttt{x} 的值
  \item
    参数加了 \texttt{const}
    之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数
    \texttt{x} 的修改操作，若有则会报错
  \item
    \textbf{如果确认函数实现中不准备改变 \texttt{x} 的值，养成加
    \texttt{const}的习惯}
  \item
    \texttt{\&} 修饰参数 \texttt{x}，表示参数 \texttt{x}
    是引用传递，即传递的是实参的地址，而不是实参的值
  \end{itemize}
\item
  修饰函数 \texttt{search} 的 \texttt{const}

  \begin{itemize}
  \tightlist
  \item
    参数表后的 \texttt{const} 保护调用对象的值不被修改
  \item
    如果没有 \texttt{const} 修饰，那么在调用对象为 \texttt{const}
    类型时，不能调用该函数\\
    常量对象只能调用参数表后带 \texttt{const} 的常量成员函数
  \end{itemize}
\end{enumerate}
\end{block}
\end{block}
\end{block}

\begin{block}{线性表}
\protect\phantomsection\label{ux7ebfux6027ux8868}
\begin{block}{线性表的定义}
\protect\phantomsection\label{ux7ebfux6027ux8868ux7684ux5b9aux4e49}
\begin{block}{线性表的概念}
\protect\phantomsection\label{ux7ebfux6027ux8868ux7684ux6982ux5ff5}
\begin{itemize}
\item
  是一种\textbf{线性结构}，是由 {} 个数据元素组成的有限序列
\item
  除了首节点 {} 和尾节点 {} 之外，每个节点 {} 有且仅有一个前趋 {}
  和一个后继 {}
\item
  {} 只有后趋，{} 只有前趋

\end{itemize}
\end{block}

\begin{block}{表的基本操作}
\protect\phantomsection\label{ux8868ux7684ux57faux672cux64cdux4f5c}
\begin{itemize}
\tightlist
\item
  \textbf{创建 \texttt{create()}}：创建一个空的线性表
\item
  \textbf{清除 \texttt{clear()}}：删除线性表中的所有数据元素
\item
  \textbf{长度 \texttt{length()}}：返回线性表的长度
\item
  \textbf{插入 \texttt{insert(i,x)}}：在线性表的第 {}
  个位置插入一个新元素 \texttt{x}
\item
  \textbf{删除 \texttt{remove(i)}}：删除线性表中第 {} 个位置的元素
\item
  \textbf{搜索 \texttt{search(x)}}：在线性表中搜索元素
  \texttt{x}，返回其位置
\item
  \textbf{访问 \texttt{visit(i)}}：返回线性表中第 {} 个位置的元素
\item
  \textbf{遍历 \texttt{traverse()}}：依次访问线性表中的每个元素
\end{itemize}
\end{block}

\begin{block}{线性表的抽象类}
\protect\phantomsection\label{ux7ebfux6027ux8868ux7684ux62bdux8c61ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class list}
\NormalTok{\{}
\NormalTok{  public:}
\NormalTok{    virtual void clear() = 0;                           // 清空}
\NormalTok{    virtual int length() const = 0;                     // 返回长度}
\NormalTok{    virtual void insert(int i, const elemType \&x) = 0;  // 插入}
\NormalTok{    virtual void remove(int i) = 0;                     // 删除}
\NormalTok{    virtual int search(const elemType \&x) const = 0;    // 搜索}
\NormalTok{    virtual elemType visit(int i) const = 0;            // 访问}
\NormalTok{    virtual void traverse() const = 0;                  // 遍历}
\NormalTok{    virtual \textasciitilde{}list() \{\}                                  // 析构函数}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现
\item
  \textbf{抽象类无构造函数}
\end{itemize}
\end{block}
\end{block}

\begin{block}{线性表的顺序实现}
\protect\phantomsection\label{ux7ebfux6027ux8868ux7684ux987aux5e8fux5b9eux73b0}
\begin{block}{顺序存储结构}
\protect\phantomsection\label{ux987aux5e8fux5b58ux50a8ux7ed3ux6784}
\begin{itemize}
\tightlist
\item
  节点存储在存储器的一块\textbf{连续}的空间中
\item
  节点依照逻辑顺序依次\textbf{存放}
\item
  节点存放的物理位置和逻辑顺序是对应的
\item
  线性表的顺序实现通常被称为\textbf{顺序表}
\end{itemize}
\end{block}

\begin{block}{顺序表类的定义}
\protect\phantomsection\label{ux987aux5e8fux8868ux7c7bux7684ux5b9aux4e49}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class seqList : public list\textless{}elemtype\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    elemType *data;}
\NormalTok{    int currentLength;}
\NormalTok{    int maxSize;}
\NormalTok{    void doubleSpace();}
\NormalTok{  public:}
\NormalTok{    seqList(int initSize = 10);             // 构造函数}
\NormalTok{    \textasciitilde{}seqList()                              // 析构函数}
\NormalTok{    \{}
\NormalTok{      delete[] data;}
\NormalTok{    \}}
\NormalTok{    void clear()                            //清空}
\NormalTok{    \{}
\NormalTok{      currentLength = 0;}
\NormalTok{    \}}
\NormalTok{    int length() const                      // 返回长度}
\NormalTok{    \{}
\NormalTok{      return currentLength;}
\NormalTok{    \}}
\NormalTok{    void insert(int i, const elemType \&x);  // 插入}
\NormalTok{    void remove(int i);                     // 删除}
\NormalTok{    int search(const elemType \&x) const;    // 搜索}
\NormalTok{    elemType visit(int i) const;            // 访问}
\NormalTok{    void traverse() const;                  // 遍历}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{函数实现}
\protect\phantomsection\label{ux51fdux6570ux5b9eux73b0}
\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570}
\begin{itemize}
\tightlist
\item
  定义对象时自动调用，用于初始化对象的数据成员
\item
  \textbf{函数名与类名相同}
\item
  可以有任何类型的参数，也可以没有参数，但是\textbf{不能有返回类型}，所以定义时不能说明类型
\item
  若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}class elemType\textgreater{}}
\NormalTok{seqList\textless{}elemType\textgreater{}::seqList(int initSize)}
\NormalTok{\{}
\NormalTok{  data = new elemType[initSize];}
\NormalTok{  maxSize = initSize;}
\NormalTok{  currentLength = 0;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\end{block}

\begin{block}{析构函数}
\protect\phantomsection\label{ux6790ux6784ux51fdux6570}
\begin{itemize}
\tightlist
\item
  用于释放对象所占用的内存空间，由编译系统自动调用
\item
  \textbf{函数名与类名相同，前面加 \texttt{\textasciitilde{}}}
\item
  不能有参数，也不能有返回类型
\item
  若没有给出析构函数，编译器会自动生成一个默认的析构函数
\item
  不是所有类都要由析构函数
\item
  一般在构造函数中动态申请内存的，必须有析构函数
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textasciitilde{}seqList()}
\NormalTok{\{}
\NormalTok{  delete[] data;}
\NormalTok{\}  //在线性表的类中已经实现了，不用到类外定义}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{顺序表的运算实现}
\protect\phantomsection\label{ux987aux5e8fux8868ux7684ux8fd0ux7b97ux5b9eux73b0}
\begin{block}{\texttt{search}}
\protect\phantomsection\label{search}
从数组的第0个下标变量开始一次往后检查每一个元素，直到找到 \texttt{x}
或找到表尾

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}class elemType\textgreater{}}
\NormalTok{int seqList\textless{}elemType\textgreater{}::search(const elemType \&x) const}
\NormalTok{\{}
\NormalTok{  int i ;}
\NormalTok{  for (i = 0 ; i \textless{} currentLength \&\& data[i] != x ; ++i);}
\NormalTok{  if (i == currentLength) }
\NormalTok{  \{}
\NormalTok{    return {-}1;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return i;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{traverse}}
\protect\phantomsection\label{traverse}
从数组的第0个下标变量开始一次往后访问每一个元素，直到表尾

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}class elemtype\textgreater{}}
\NormalTok{void seqList\textless{}elemType\textgreater{}::traverse() const}
\NormalTok{\{}
\NormalTok{  for (int i = 0 ; i \textless{} currentLength ; ++i)}
\NormalTok{  \{}
\NormalTok{    cout \textless{}\textless{} data[i] \textless{}\textless{} \textquotesingle{} \textquotesingle{};}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{insert}}
\protect\phantomsection\label{insert}
\begin{itemize}
\tightlist
\item
  在第 \texttt{i} 个位置插入元素 \texttt{x}
\item
  若插入后表长超过 \texttt{maxSize}，则将 \texttt{maxSize} 扩大一倍
\end{itemize}


\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}class elemType\textgreater{}}
\NormalTok{void seqList\textless{}elemType\textgreater{}::insert(int i , const elemType \&x)}
\NormalTok{\{}
\NormalTok{  if (currentSize = maxSize)}
\NormalTok{  \{}
\NormalTok{    doubleSpace();}
\NormalTok{  \}}
\NormalTok{  for (int j = currentLength ; j \textgreater{} i ; {-}{-}j)}
\NormalTok{  \{}
\NormalTok{    data[j] = data[j {-} 1];}
\NormalTok{  \}}
\NormalTok{  data[i] = x;}
\NormalTok{  ++currentLength;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{doubleSpace} 操作的实现}
\protect\phantomsection\label{doublespace-ux64cdux4f5cux7684ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区
\end{itemize}


\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}class elemType\textgreater{}}
\NormalTok{void seqList\textless{}elemType\textgreater{}::doublespace()}
\NormalTok{\{}
\NormalTok{  elemtype *tmp = data;}
\NormalTok{  maxSize *= 2;}
\NormalTok{  data = new elemtype[maxSize];}
\NormalTok{  for (int i = 0 ; i \textless{} currentLength ; ++1)}
\NormalTok{  \{}
\NormalTok{    data[i] = tmp[i];}
\NormalTok{  \}}
\NormalTok{  delete[] tmp;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{remove}}
\protect\phantomsection\label{remove}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}class elemType\textgreater{}}
\NormalTok{void seqList\textless{}elemType\textgreater{}::remove(int i)}
\NormalTok{\{}
\NormalTok{  if (i \textless{} 0 ||i \textgreater{} currentlength)}
\NormalTok{  \{}
\NormalTok{    throw OutOfBound();}
\NormalTok{  \}}
\NormalTok{  for (int j = i ; j \textless{} currentlength {-}1 ; ++j)}
\NormalTok{  \{}
\NormalTok{    data[j] = data[j + 1];}
\NormalTok{  \}}
\NormalTok{  {-}{-}currentLength;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}
\end{block}

\begin{block}{线性表的链接存储}
\protect\phantomsection\label{ux7ebfux6027ux8868ux7684ux94feux63a5ux5b58ux50a8}
\begin{block}{单链表}
\protect\phantomsection\label{ux5355ux94feux8868}
\begin{itemize}
\tightlist
\item
  每个节点附加指针字段，如
  \texttt{next}，指向直接后继节点，最后一个节点的 \texttt{next} 指向
  \texttt{nullptr}
\end{itemize}


\begin{block}{头节点、头指针}
\protect\phantomsection\label{ux5934ux8282ux70b9ux5934ux6307ux9488}
\begin{itemize}
\tightlist
\item
  在表头额外增加一个相同类型的特殊结点
\item
  不是线性表中的组成部分
\item
  头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化
\end{itemize}

\end{block}

\begin{block}{结点及其组成}
\protect\phantomsection\label{ux7ed3ux70b9ux53caux5176ux7ec4ux6210}
\begin{itemize}
\tightlist
\item
  链表的节点包含两个部分

  \begin{itemize}
  \tightlist
  \item
    数据字段

    \begin{itemize}
    \tightlist
    \item
      可以存储任何类型的数据，仍然使用 \texttt{elemType} 表示
    \end{itemize}
  \item
    指针字段

    \begin{itemize}
    \tightlist
    \item
      用于存储\textbf{后继节点}的地址值
    \end{itemize}
  \item
    结点类型是链表专用的，可以设为内嵌类
  \item
    将节点类定义为 \texttt{struct} 方便链表类访问
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{单链表类的定义}
\protect\phantomsection\label{ux5355ux94feux8868ux7c7bux7684ux5b9aux4e49}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class sLinkList:public list\textless{}elemtype\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    struct node                                    // 节点类}
\NormalTok{    \{}
\NormalTok{      elemType data;}
\NormalTok{      node *next;}
\NormalTok{      node(const elemType \&x , node *n = nullptr)}
\NormalTok{      \{}
\NormalTok{        data = x;}
\NormalTok{        next = n;}
\NormalTok{      \}}
\NormalTok{      node():next(nullptr)\{\}}
\NormalTok{      \textasciitilde{}node()\{\}}
\NormalTok{    \};}

\NormalTok{    node *head;}
\NormalTok{    int currentLength;}
\NormalTok{    node *move(int i) const;}
\NormalTok{  public:}
\NormalTok{    sLinkList();}
\NormalTok{    \textasciitilde{}sLinkList();}
\NormalTok{    void clear();}
\NormalTok{    int length() const}
\NormalTok{    \{}
\NormalTok{      return currentLength;}
\NormalTok{    \}}
\NormalTok{    void insert(int i , const elemType \&x);}
\NormalTok{    void remove(int i);}
\NormalTok{    int search(const elemType \&x) const;}
\NormalTok{    elemType visit(int i) const;}
\NormalTok{    void traverse() const;}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570-1}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{sLinkList\textless{}elemType\textgreater{}::sLinkList()}
\NormalTok{\{}
\NormalTok{  head = new node();}
\NormalTok{  currentLength = 0;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{clear}}
\protect\phantomsection\label{clear}
\begin{itemize}
\tightlist
\item
  将单链表变成一个空表
\item
  回收节点空间
\end{itemize}


\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void sLinkList\textless{}elemType\textgreater{}::clear()}
\NormalTok{\{}
\NormalTok{  node *p = head{-}\textgreater{}next , *q;}

\NormalTok{  while (p != nullptr)        // 删除节点}
\NormalTok{  \{}
\NormalTok{    q = p{-}\textgreater{}next;}
\NormalTok{    delete p;}
\NormalTok{    p = q;}
\NormalTok{  \}}
\NormalTok{  currentLength = 0;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{move}}
\protect\phantomsection\label{move}
\begin{itemize}
\tightlist
\item
  返回第 {} 个元素的指针
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{struct sLinkList\textless{}elemType\textgreater{}::node *sLinkList\textless{}elemType\textgreater{}::move(int i) const}
\NormalTok{\{}
\NormalTok{  node *p = head;}
\NormalTok{  for (int j = 0 ; j \textless{} i ; ++j)}
\NormalTok{  \{}
\NormalTok{    p = p{-}\textgreater{}next;}
\NormalTok{  \}}
\NormalTok{  return p;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{insert}}
\protect\phantomsection\label{insert-1}
\begin{enumerate}
\tightlist
\item
  指针 \texttt{p} 指向要插入的位置 \texttt{i} 的前一个节点
\item
  申请一个新节点 \texttt{s}
\item
  将 \texttt{s} 的 \texttt{next} 指向 \texttt{p} 的 \texttt{next}
\item
  将 \texttt{p} 的 \texttt{next} 指向 \texttt{s}
\end{enumerate}


\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void sinkList\textless{}elemtype\textgreater{}::insert(int i , const elemType \&x)}
\NormalTok{\{}
\NormalTok{  if (i \textless{} 0 || i \textgreater{} currentLength)}
\NormalTok{  \{}
\NormalTok{    throw OutOfBound();}
\NormalTok{  \}}
\NormalTok{  node *p = move(i{-}1);}
\NormalTok{  node *s = new node(x , p{-}\textgreater{}next);}
\NormalTok{  p{-}\textgreater{}next = s;}
\NormalTok{  ++currentLength;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{remove}}
\protect\phantomsection\label{remove-1}
\begin{enumerate}
\tightlist
\item
  找到被删除节点的前一个节点 \texttt{pos}
\item
  让 \texttt{delp} 指向被删除节点
\item
  让 \texttt{pos} 的 \texttt{next} 指向 \texttt{delp} 的 \texttt{next}
\item
  释放 \texttt{delp} 的空间
\end{enumerate}


\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void sLinkList\textless{}elemType\textgreater{}::remove(int i)}
\NormalTok{\{}
\NormalTok{  if (i \textless{} 0 || i \textgreater{}= currentLength)}
\NormalTok{  \{}
\NormalTok{    throw OutOfBound();}
\NormalTok{  \}}
\NormalTok{  node *pos = move(i{-}1);}
\NormalTok{  node *delp = pos{-}\textgreater{}next;}
\NormalTok{  pos{-}\textgreater{}next = delp{-}\textgreater{}next;}
\NormalTok{  delete delp;}
\NormalTok{  {-}{-}currentLength;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{search}}
\protect\phantomsection\label{search-1}
\begin{itemize}
\tightlist
\item
  从头节点开始，依次访问每个节点，直到找到 \texttt{x} 或到达表尾
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{int sLinkList\textless{}elemType\textgreater{}::search(const elemtype 7x) const}
\NormalTok{\{}
\NormalTok{  node *p = head {-}\textgreater{} next;}
\NormalTok{  int i = 0;}
\NormalTok{  while (p != nullptr \&\& p{-}\textgreater{}data != x) // 访问每个节点，条件的顺序不能交换}
\NormalTok{  \{}
\NormalTok{    p = p{-}\textgreater{}next;}
\NormalTok{    ++i;}
\NormalTok{  \}}
\NormalTok{  if (p == nullptr)}
\NormalTok{  \{}
\NormalTok{    return {-}1;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return i;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  如果判定条件改为
  \texttt{p-\textgreater{}data\ !=\ x\ \&\&\ p\ !=\ nullptr}，会在
  \texttt{p} 为空时试图访问
  \texttt{p-\textgreater{}data}，导致访问空指针，从而产生未定义行为
\end{itemize}
\end{block}

\begin{block}{\texttt{visit}}
\protect\phantomsection\label{visit}
\begin{enumerate}
\tightlist
\item
  找到第 \texttt{i} 个节点
\item
  返回 \texttt{p-\textgreater{}data}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{elemType sLinkList\textless{}elemType\textgreater{}::visit(int i) const}
\NormalTok{\{}
\NormalTok{  if (i \textless{} 0 || i \textgreater{}= currentLength)}
\NormalTok{  \{}
\NormalTok{    throw OutOfBound();}
\NormalTok{  \}}
\NormalTok{  return move(i){-}\textgreater{}data;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{traverse}}
\protect\phantomsection\label{traverse-1}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void sLinkList\textless{}elemType\textgreater{}::traverse() const}
\NormalTok{\{}
\NormalTok{  node *p = head{-}\textgreater{}next;}
\NormalTok{  while (p != nullptr)}
\NormalTok{  \{}
\NormalTok{    cout \textless{}\textless{} p{-}\textgreater{}data \textless{}\textless{} \textquotesingle{} \textquotesingle{};}
\NormalTok{    p = p{-}\textgreater{}next;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{双链表}
\protect\phantomsection\label{ux53ccux94feux8868}
\begin{itemize}
\tightlist
\item
  每个节点有两个指针字段

  \begin{itemize}
  \tightlist
  \item
    \texttt{next} 指向直接后继节点
  \item
    \texttt{prev} 指向直接前驱节点
  \end{itemize}
\end{itemize}

\begin{block}{双链表的头尾节点}
\protect\phantomsection\label{ux53ccux94feux8868ux7684ux5934ux5c3eux8282ux70b9}
\begin{itemize}
\tightlist
\item
  头节点

  \begin{itemize}
  \tightlist
  \item
    \texttt{prev} 指向 \texttt{nullptr}
  \item
    \texttt{next} 指向首节点
  \end{itemize}
\item
  尾节点 \texttt{tail}

  \begin{itemize}
  \tightlist
  \item
    \texttt{prev} 指向最后一个节点
  \item
    \texttt{next} 指向 \texttt{nullptr}
  \end{itemize}
\end{itemize}

\end{block}

\begin{block}{双链表类的定义}
\protect\phantomsection\label{ux53ccux94feux8868ux7c7bux7684ux5b9aux4e49}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class dLinkList:public list\textless{}elemType\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    struct node                                                         // 双链表中的节点类}
\NormalTok{    \{}
\NormalTok{      elemType data;}
\NormalTok{      node *next;}
\NormalTok{      node *prev;}
\NormalTok{      node(const elemType \&x , node *p = nullptr , node *n = nullptr)}
\NormalTok{      \{}
\NormalTok{        data = x;}
\NormalTok{        prev = p;}
\NormalTok{        next = n;}
\NormalTok{      \}}
\NormalTok{      node():next(nullptr),prev(nullptr)\{\}}
\NormalTok{      \textasciitilde{}node()\{\}}
\NormalTok{    \};}
\NormalTok{    node *head , *tail;                                                  // 头节点和尾节点}
\NormalTok{    int currentLength;                                                   // 当前长度}
\NormalTok{    node *move(int i) const;                                             // 返回第 i 个节点的指针}
\NormalTok{  public:}
\NormalTok{    dLinkList();}
\NormalTok{    \textasciitilde{}dLinkList();}
\NormalTok{    void clear();}
\NormalTok{    int length() const}
\NormalTok{    \{}
\NormalTok{      return currentLength;}
\NormalTok{    \}}
\NormalTok{    void insert(int i , const elemType \&x);}
\NormalTok{    void remove(int i);}
\NormalTok{    int search(const elemType \&x) const;}
\NormalTok{    elemType visit(int i) const;}
\NormalTok{    void traverse() const;}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570-2}
\begin{itemize}
\tightlist
\item
  申请头节点和尾节点
\end{itemize}


\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{dLinkList\textless{}elemType\textgreater{}::dLinkList()}
\NormalTok{\{}
\NormalTok{  head = new node();}
\NormalTok{  tail = new node();}
\NormalTok{  head{-}\textgreater{}next = tail;}
\NormalTok{  tail{-}\textgreater{}prev = head;}
\NormalTok{  currentLength = 0;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{insert}}
\protect\phantomsection\label{insert-2}
\begin{enumerate}
\tightlist
\item
  申请一个新节点 \texttt{tmp}，找到要插入的位置 \texttt{pos}
\item
  将 \texttt{tmp} 的 \texttt{prev} 指向 \texttt{pos} 的
  \texttt{prev}，\texttt{tmp} 的 \texttt{next} 指向 \texttt{pos}
\item
  将 \texttt{pos} 的前一个结点的 \texttt{next} 指向 \texttt{tmp}
\item
  将 \texttt{pos} 的 \texttt{prev} 指向 \texttt{tmp}
\end{enumerate}


\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void dLinkList\textless{}elemtype\textgreater{}::insert(int i ,const elemTypr \&x)}
\NormalTok{[}
\NormalTok{  node *pos , *tmp;}

\NormalTok{  pos = move(i);}
\NormalTok{  temp = new node(x,pos {-}\textgreater{} prev , pos);}
\NormalTok{  pos{-}\textgreater{}prev{-}\textgreater{}next = tmp;}
\NormalTok{  pos{-}\textgreater{}prev = tmp;}

\NormalTok{  ++currentLength;}
\NormalTok{]}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{remove}}
\protect\phantomsection\label{remove-2}
\begin{enumerate}
\tightlist
\item
  找到要删除的节点 \texttt{pos}
\item
  将 \texttt{pos} 的前一个节点的 \texttt{next} 指向 \texttt{pos}
  的后一个节点
\item
  将 \texttt{pos} 的后一个节点的 \texttt{prev} 指向 \texttt{pos}
  的前一个节点
\end{enumerate}


\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void dLinkList\textless{}elemType\textgreater{}::remove(int i)}
\NormalTok{\{}
\NormalTok{  node *pos = move(i);}

\NormalTok{  pos{-}\textgreater{}prev{-}\textgreater{}next = pos{-}\textgreater{}next;}
\NormalTok{  pos{-}\textgreater{}next{-}\textgreater{}prev = pos{-}\textgreater{}prev;}

\NormalTok{  delete pos;}
\NormalTok{  {-}{-}currentLength;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{单循环链表}
\protect\phantomsection\label{ux5355ux5faaux73afux94feux8868}
\begin{itemize}
\tightlist
\item
  一般单循环链表不带头节点
\end{itemize}

\end{block}

\begin{block}{双循环链表}
\protect\phantomsection\label{ux53ccux5faaux73afux94feux8868}
\begin{itemize}
\tightlist
\item
  头结点中 \texttt{prev} 字段给出尾结点的地址，尾结点中 \texttt{next}
  字段给出头结点的地址
\item
  一般也不设置头尾节点
\end{itemize}
\end{block}
\end{block}
\end{block}

\begin{block}{栈}
\protect\phantomsection\label{ux6808}
\begin{block}{栈的定义}
\protect\phantomsection\label{ux6808ux7684ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  栈是一种特殊的线性表
\item
  只允许在一段进行插入和删除操作
\item
  先进后出（LIFO，Last In First Out）
\end{itemize}


\begin{block}{栈的基本操作}
\protect\phantomsection\label{ux6808ux7684ux57faux672cux64cdux4f5c}
\begin{itemize}
\tightlist
\item
  \textbf{创建 \texttt{create()}}：创建一个空栈
\item
  \textbf{进栈 \texttt{push(x)}}：将元素 \texttt{x} 压入栈顶
\item
  \textbf{出栈 \texttt{pop()}}：删除栈顶元素并返回其值
\item
  \textbf{访问栈顶元素 \texttt{top()}}：返回栈顶元素的值但是不删除
\item
  \textbf{判断是否为空 \texttt{isEmpty()}}：若栈空返回
  \texttt{true}，否则返回 \texttt{false}
\end{itemize}
\end{block}

\begin{block}{栈的抽象类}
\protect\phantomsection\label{ux6808ux7684ux62bdux8c61ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class stack}
\NormalTok{\{}
\NormalTok{  public:}
\NormalTok{    virtual void push(const elemType \&x) = 0;       // 进栈}
\NormalTok{    virtual elemType pop() = 0;                     // 出栈}
\NormalTok{    virtual elemType top() const = 0;               // 访问栈顶元素}
\NormalTok{    virtual bool isEmpty() const = 0;               // 是否为空}
\NormalTok{    virtual \textasciitilde{}stack() \{\}                             // 析构函数}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{栈的顺序实现}
\protect\phantomsection\label{ux6808ux7684ux987aux5e8fux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  使用数组储存栈中的节点
\item
  进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶
\end{itemize}


\begin{block}{顺序栈类}
\protect\phantomsection\label{ux987aux5e8fux6808ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class seqStack:public stack\textless{}elemType\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    elemType *data;                     // 数据域}
\NormalTok{    int top\_p;                          // 栈顶指针}
\NormalTok{    int maxSize;                        // 栈的最大容量}
\NormalTok{    void doubleSpace();                }
\NormalTok{  public:}
\NormalTok{    seqStack(int initSize = 10);        // 构造函数}
\NormalTok{    \textasciitilde{}seqStack();                        // 析构函数}
\NormalTok{    bool isEmpty() const;               // 是否为空}
\NormalTok{    void push(const elemType \&x);       // 进栈}
\NormalTok{    elemType pop();                    // 出栈}
\NormalTok{    elemType top() const;               // 访问栈顶元素}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{顺序存储的运算实现}
\protect\phantomsection\label{ux987aux5e8fux5b58ux50a8ux7684ux8fd0ux7b97ux5b9eux73b0}
\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570-3}
\begin{itemize}
\tightlist
\item
  按照用户估计的栈的规模申请一个动态数组，将数组地址保存在 \texttt{elem}
  中，数组规模保存在 \texttt{maxSize} 中，并设 \texttt{top\_p} 的值为 {}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{seqStack\textless{}elemType\textgreater{}::seqStack(int initSize)}
\NormalTok{\{}
\NormalTok{  elem = new elemType[initSize];}
\NormalTok{  maxSize = initSize;}
\NormalTok{  top\_p = {-}1;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{\texttt{push}}
\protect\phantomsection\label{push}
\begin{itemize}
\tightlist
\item
  先判断栈是否已满，若满则调用 \texttt{doubleSpace} 扩大栈的容量
\item
  将 \texttt{top\_p} 加1，指向栈顶元素
\item
  将 \texttt{x} 压入栈顶
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void seqStack\textless{}elemType\textgreater{}::push(const elemType \&x)}
\NormalTok{\{}
\NormalTok{  if (top\_p == maxSize {-} 1)}
\NormalTok{  \{}
\NormalTok{    doubleSpace();}
\NormalTok{  \}}
\NormalTok{  elem[++top\_p] = x;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{block}{\texttt{doubleSpace}}
\protect\phantomsection\label{doublespace}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void seqStack\textless{}elemType\textgreater{}::doubleSpace()}
\NormalTok{\{}
\NormalTok{  elemType *tmp = elem;}
\NormalTok{  elem = new elemType[maxSize * 2];}
\NormalTok{  for (int i = 0 ; i \textless{} maxSize ; ++i)}
\NormalTok{  \{}
\NormalTok{    elem[i] = tmp[i];}
\NormalTok{  \}}
\NormalTok{  maxSize *= 2;}
\NormalTok{  delete[] tmp;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{pop}}
\protect\phantomsection\label{pop}
\begin{itemize}
\tightlist
\item
  返回 \texttt{top\_p} 指向的元素
\item
  将 \texttt{top\_p} 减1
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{elemType seqStack\textless{}elemType\textgreater{}::pop()}
\NormalTok{\{}
\NormalTok{  return elem[top\_p{-}{-}];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{top}}
\protect\phantomsection\label{top}
\begin{itemize}
\tightlist
\item
  返回 \texttt{top\_p} 指向的元素
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{elemType seqStack\textless{}elemType\textgreater{}::top() const}
\NormalTok{\{}
\NormalTok{  return elem[top\_p];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{isEmpty}}
\protect\phantomsection\label{isempty}
\begin{itemize}
\tightlist
\item
  判断 \texttt{top\_p} 是否为 {}，若是则栈空
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{bool seqStack\textless{}elemType\textgreater{}::isEmpty() const}
\NormalTok{\{}
\NormalTok{  return top\_p == {-}1;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{析构函数}
\protect\phantomsection\label{ux6790ux6784ux51fdux6570-1}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{seqStack\textless{}elemType\textgreater{}::\textasciitilde{}seqStack()}
\NormalTok{\{}
\NormalTok{  delete[] elem;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{性能分析}
\protect\phantomsection\label{ux6027ux80fdux5206ux6790}
\begin{itemize}
\tightlist
\item
  所有运算实现的时间复杂度都为 {}
\item
  进栈运算在最坏的情况下的时间复杂度为 {} （需要 \texttt{doublespace}
  时）
\end{itemize}
\end{block}
\end{block}

\begin{block}{栈的链接实现}
\protect\phantomsection\label{ux6808ux7684ux94feux63a5ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  使用\textbf{不含头结点的单链表}实现栈
\item
  从使用方便性上看，将单链表的头指针指向栈顶
\end{itemize}


\begin{block}{链接栈类}
\protect\phantomsection\label{ux94feux63a5ux6808ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class LinkedStack:public stack\textless{}elemType\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    struct node}
\NormalTok{    \{}
\NormalTok{      elemType data;}
\NormalTok{      node *next;}
\NormalTok{      node(const elemType \&x , node *n = nullptr)}
\NormalTok{      \{}
\NormalTok{        data = x;}
\NormalTok{        next = n;}
\NormalTok{      \}}
\NormalTok{      node():next(nullptr)\{\}}
\NormalTok{      \textasciitilde{}node()\{\}}
\NormalTok{    \};}
\NormalTok{    node *top\_p;                       // 栈顶指针}
\NormalTok{  public:}
\NormalTok{    LinkedStack();                    // 构造函数}
\NormalTok{    \textasciitilde{}LinkedStack();                   // 析构函数}
\NormalTok{    bool isEmpty() const;             // 是否为空}
\NormalTok{    void push(const elemType \&x);     // 进栈}
\NormalTok{    elemType pop();                   // 出栈}
\NormalTok{    elemType top() const;             // 访问栈顶元素}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{链接存储的运算实现}
\protect\phantomsection\label{ux94feux63a5ux5b58ux50a8ux7684ux8fd0ux7b97ux5b9eux73b0}
\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570-4}
\begin{itemize}
\tightlist
\item
  将 \texttt{top\_p} 初始化为 \texttt{nullptr}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{LinkedStack\textless{}elemType\textgreater{}::LinkedStack()}
\NormalTok{\{}
\NormalTok{  top\_p = nullptr;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{析构函数}
\protect\phantomsection\label{ux6790ux6784ux51fdux6570-2}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{LinkStack\textless{}elemType\textgreater{}::\textasciitilde{}LinkStack()}
\NormalTok{\{}
\NormalTok{  node *tmp;}
\NormalTok{  while (top\_p != nullptr)}
\NormalTok{  \{}
\NormalTok{    tmp = top\_p;}
\NormalTok{    top\_p = top\_p{-}\textgreater{}next;}
\NormalTok{    delete tmp;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{push}}
\protect\phantomsection\label{push-1}
\begin{itemize}
\tightlist
\item
  在表头插入
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void LinkedStack\textless{}elemType\textgreater{}::push(const elemType \&x)}
\NormalTok{\{}
\NormalTok{  top\_p = new node(x , top\_p);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{pop}}
\protect\phantomsection\label{pop-1}
\begin{itemize}
\tightlist
\item
  删除表头节点
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{elemType LinkedStack\textless{}elemType\textgreater{}::pop()}
\NormalTok{\{}
\NormalTok{  node *tmp = top\_p;}
\NormalTok{  elemType x = top\_p{-}\textgreater{}data;}
\NormalTok{  top\_p = top\_p{-}\textgreater{}next;}
\NormalTok{  delete tmp;}
\NormalTok{  return x;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{top}}
\protect\phantomsection\label{top-1}
\begin{itemize}
\tightlist
\item
  返回 \texttt{top\_p} 指向的节点的 \texttt{data}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{elemType LinkedStack\textless{}elemType\textgreater{}::top() const}
\NormalTok{\{}
\NormalTok{  return top\_p{-}\textgreater{}data;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{isEmpty}}
\protect\phantomsection\label{isempty-1}
\begin{itemize}
\tightlist
\item
  判断 \texttt{top\_p} 是否为 \texttt{nullptr}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{bool LinkedStack\textless{}elemType\textgreater{}::isEmpty() const}
\NormalTok{\{}
\NormalTok{  return top\_p == nullptr;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{性能分析}
\protect\phantomsection\label{ux6027ux80fdux5206ux6790-1}
\begin{itemize}
\tightlist
\item
  所有运算实现的时间复杂度都为 {}，因为都是对栈顶进行操作
\end{itemize}
\end{block}
\end{block}

\begin{block}{栈的应用}
\protect\phantomsection\label{ux6808ux7684ux5e94ux7528}
\begin{block}{递归函数的非递归实现}
\protect\phantomsection\label{ux9012ux5f52ux51fdux6570ux7684ux975eux9012ux5f52ux5b9eux73b0}
\begin{block}{函数调用}
\protect\phantomsection\label{ux51fdux6570ux8c03ux7528}
\begin{itemize}
\tightlist
\item
  递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{void main()}
\NormalTok{\{}
\NormalTok{  ...}
\NormalTok{  r1:f1();}
\NormalTok{  r2:}
\NormalTok{  ..}
\NormalTok{\}}

\NormalTok{void f1()}
\NormalTok{\{}
\NormalTok{  ...}
\NormalTok{  t1:f2();}
\NormalTok{  t2:}
\NormalTok{  ...}
\NormalTok{\}}

\NormalTok{void f2()}
\NormalTok{\{}
\NormalTok{  ...}
\NormalTok{  ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}


\begin{itemize}
\tightlist
\item
  设置一个栈模拟函数调用，当调用发生时，将函数压入栈中
\item
  函数返回时，将栈顶元素弹出
\end{itemize}

\begin{block}{递归算法的例子}
\protect\phantomsection\label{ux9012ux5f52ux7b97ux6cd5ux7684ux4f8bux5b50}
hanoi塔算法

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{void Move(int Height , int FromNeedle ,int ToNeedle ,int UsingNeedle) // FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针}
\NormalTok{\{}
\NormalTok{  if (Height \textgreater{} 0)}
\NormalTok{  \{}
\NormalTok{    Move(Height {-} 1，FromNeedle , UsingNeeedle,ToNeedle); // 将上面n{-}1个盘子从FromNeedle移动到UsingNeedle}
\NormalTok{    cout \textless{}\textless{} FromNeedle \textless{}\textless{} "{-}\textgreater{}" \textless{}\textless{} ToNeedle \textless{}\textless{} endl; // 将最底下的盘子从FromNeedle移动到ToNeedle\textgreater{}}
\NormalTok{    Move(Height {-} 1,UsingNeedle , ToNeedle , FromNeedle); // 将上面的盘子从UsingNeedle移动到ToNeedle}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{递归算法的时间复杂度}
\protect\phantomsection\label{ux9012ux5f52ux7b97ux6cd5ux7684ux65f6ux95f4ux590dux6742ux5ea6}
\begin{block}{数学归纳法}
\protect\phantomsection\label{ux6570ux5b66ux5f52ux7eb3ux6cd5}
以Hanio塔问题为例

可以使用数学归纳法证明 {}
\end{block}

\begin{block}{递归方程}
\protect\phantomsection\label{ux9012ux5f52ux65b9ux7a0b}
\textbf{主定理}：设 {}，{} 为常数，{} 是一个函数，则递归方程

的解为

\begin{enumerate}
\tightlist
\item
  若 {}，则 {}
\item
  若 {}，则 {}
\item
  若 {}，则 {}
\end{enumerate}
\end{block}

\begin{block}{生成函数}
\protect\phantomsection\label{ux751fux6210ux51fdux6570}
\textbf{定义}：设 {} 是一无穷序列，称形式幂级数 {} 为其生成函数

利用生成函数求通项的方法

\begin{enumerate}
\tightlist
\item
  按照递归关系式消去无限延长的部分
\item
  展开为 {} 的幂级数求通项
\end{enumerate}

以Fibonacci数列为例

令 {}，{}

有 {}

则
\end{block}
\end{block}
\end{block}

\begin{block}{递归消除}
\protect\phantomsection\label{ux9012ux5f52ux6d88ux9664}
以打印正整数为例

\begin{block}{递归实现}
\protect\phantomsection\label{ux9012ux5f52ux5b9eux73b0}
\begin{block}{代码}
\protect\phantomsection\label{ux4ee3ux7801}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{void printNum(int num)}
\NormalTok{\{}
\NormalTok{  if (num \textgreater{}= 10)}
\NormalTok{  \{}
\NormalTok{    printNum(num / 10);}
\NormalTok{    cout.put(num \% 10 + \textquotesingle{}0\textquotesingle{});}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    cout.put(num + \textquotesingle{}0\textquotesingle{});}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{代码运行过程中栈的变化}
\protect\phantomsection\label{ux4ee3ux7801ux8fd0ux884cux8fc7ux7a0bux4e2dux6808ux7684ux53d8ux5316}
\begin{enumerate}
\tightlist
\item
  \texttt{push(1234)}
\item
  \texttt{pop(1234)}，\texttt{push(4)}，\texttt{push(123)}
\item
  \texttt{pop(123)}，\texttt{push(3)}，\texttt{push(12)}
\item
  \texttt{pop(12)}，\texttt{push(2)}，\texttt{push(1)}
\item
  \texttt{pop(1)}，\texttt{pop(2)}，\texttt{pop(3)}，\texttt{pop(4)}
\end{enumerate}
\end{block}
\end{block}

\begin{block}{非递归实现}
\protect\phantomsection\label{ux975eux9012ux5f52ux5b9eux73b0}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{void printNum(int num)}
\NormalTok{\{}
\NormalTok{  LinkStack\textless{}int\textgreater{} s;}
\NormalTok{  int tmp;}
\NormalTok{  s.push(num);}
\NormalTok{  while (!isEmpty())}
\NormalTok{  \{}
\NormalTok{    tmp = s.pop();}
\NormalTok{    if (tmp \textgreater{} 9)}
\NormalTok{    \{}
\NormalTok{      s.push(tmp \% 10);}
\NormalTok{      s.push(tmp / 10);}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      cout.put(tmp + \textquotesingle{}0\textquotesingle{});}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}

\begin{block}{括号匹配}
\protect\phantomsection\label{ux62ecux53f7ux5339ux914d}
\begin{itemize}
\tightlist
\item
  判断一个表达式中的括号是否匹配
\item
  遇到左括号就入栈，遇到右括号就出栈
\end{itemize}

判断错误的原则

\begin{enumerate}
\tightlist
\item
  栈空时遇到右括号
\item
  出栈时遇到不匹配的括号
\item
  栈不空时结束
\end{enumerate}
\end{block}

\begin{block}{简单的计算数学表达式}
\protect\phantomsection\label{ux7b80ux5355ux7684ux8ba1ux7b97ux6570ux5b66ux8868ux8fbeux5f0f}
\begin{block}{前缀式、中缀式和后缀式}
\protect\phantomsection\label{ux524dux7f00ux5f0fux4e2dux7f00ux5f0fux548cux540eux7f00ux5f0f}
对于一个表达式 {}

\begin{itemize}
\tightlist
\item
  前缀式 \texttt{+ab}，波兰式
\item
  中缀式 \texttt{a+b}
\item
  后缀式 \texttt{ab+}，逆波兰式
\end{itemize}
\end{block}

\begin{block}{后缀式的优点}
\protect\phantomsection\label{ux540eux7f00ux5f0fux7684ux4f18ux70b9}
\begin{itemize}
\tightlist
\item
  不需要括号
\item
  不需要考虑运算符的优先级
\item
  计算机容易处理
\end{itemize}
\end{block}

\begin{block}{后缀式的计算}
\protect\phantomsection\label{ux540eux7f00ux5f0fux7684ux8ba1ux7b97}
\begin{itemize}
\tightlist
\item
  使用栈来存储操作数
\item
  遇到操作数就入栈
\item
  遇到操作符就出栈两个操作数，进行计算，将结果入栈
\item
  最后栈中只剩下一个元素，就是结果
\end{itemize}
\end{block}

\begin{block}{中缀式转换为后缀式的算法}
\protect\phantomsection\label{ux4e2dux7f00ux5f0fux8f6cux6362ux4e3aux540eux7f00ux5f0fux7684ux7b97ux6cd5}
操作方法见中缀计算式转换为后缀计算式
\end{block}
\end{block}
\end{block}

\begin{block}{队列}
\protect\phantomsection\label{ux961fux5217}
\begin{itemize}
\item
  队列的定义
\item
  先进先出（FIFO，First In First Out）
\item
  只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作
\end{itemize}


\begin{block}{队列的基本操作}
\protect\phantomsection\label{ux961fux5217ux7684ux57faux672cux64cdux4f5c}
\begin{itemize}
\tightlist
\item
  \textbf{创建 \texttt{create()}}：创建一个空队列
\item
  \textbf{入队 \texttt{enQueue(x)}}：将元素 \texttt{x} 入队
\item
  \textbf{出队 \texttt{deQueue()}}：删除队首元素并返回其值
\item
  \textbf{访问队首元素 \texttt{getHead()}}：返回队首元素的值但不删除
\item
  \textbf{判断是否为空 \texttt{isEmpty()}}：若队列空返回
  \texttt{true}，否则返回 \texttt{false}
\end{itemize}
\end{block}

\begin{block}{队列的抽象类}
\protect\phantomsection\label{ux961fux5217ux7684ux62bdux8c61ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class queue}
\NormalTok{\{}
\NormalTok{  public:}
\NormalTok{    virtual void enQueue(const elemType \&x) = 0;       // 入队}
\NormalTok{    virtual elemType deQueue() = 0;                    // 出队}
\NormalTok{    virtual elemType getHead() const = 0;              // 访问队首元素}
\NormalTok{    virtual bool isEmpty() const = 0;                  // 是否为空}
\NormalTok{    virtual \textasciitilde{}queue() \{\}                                 // 析构函数}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{队列的顺序实现}
\protect\phantomsection\label{ux961fux5217ux7684ux987aux5e8fux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  使用数组来存储队列中的元素
\item
  元素下标的范围为 {} 到 \texttt{maxSize\ -\ 1}
\item
  存储队里的三种组织方法

  \begin{enumerate}
  \tightlist
  \item
    队头位置固定
  \item
    队头位置不固定
  \item
    循环队列
  \end{enumerate}
\end{itemize}

\begin{block}{队头位置固定}
\protect\phantomsection\label{ux961fux5934ux4f4dux7f6eux56faux5b9a}

\textbf{缺点}：出队的时间复杂度为
{}，因为出队时需要将所有元素向前移动一位
\end{block}

\begin{block}{队头位置不固定}
\protect\phantomsection\label{ux961fux5934ux4f4dux7f6eux4e0dux56faux5b9a}

\textbf{优点}：所有操作的时间复杂度均为 {}\\
\textbf{缺点}：浪费大量的空间
\end{block}

\begin{block}{循环队列}
\protect\phantomsection\label{ux5faaux73afux961fux5217}

\begin{itemize}
\tightlist
\item
  入队

  \begin{itemize}
  \tightlist
  \item
    \texttt{rear\ =\ (rear\ +\ 1)\ \%\ maxSize};
    \texttt{elem{[}rear{]}\ =\ x}
  \end{itemize}
\item
  出队

  \begin{itemize}
  \tightlist
  \item
    \texttt{front\ =\ (front\ +\ 1)\ \%\ maxSize};
    \texttt{return\ elem{[}front{]}}
  \end{itemize}
\end{itemize}

为了解决队列空和队列满的判断问题，令 \texttt{front}
指向的单元不能存储队列元素，只能起到标志作用

\begin{itemize}
\tightlist
\item
  队列空：\texttt{front\ ==\ rear}
\item
  队列满：\texttt{(rear\ +\ 1)\ \%\ maxSize\ ==\ front}
\end{itemize}

\begin{block}{循环队列类的定义}
\protect\phantomsection\label{ux5faaux73afux961fux5217ux7c7bux7684ux5b9aux4e49}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class seqQueue:public queue\textless{}elemType\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    elemType *elem;}
\NormalTok{    int maxSize;}
\NormalTok{    int front , rear;}
\NormalTok{    void doubleSpace();}
\NormalTok{  public:}
\NormalTok{    seqQueue(int initSize = 10);        // 构造函数}
\NormalTok{    \textasciitilde{}seqQueue();                        // 析构函数}
\NormalTok{    bool isEmpty();                     // 是否为空}
\NormalTok{    void enQueue(const elemType \&x);    // 入队}
\NormalTok{    elemType deQueue();                 // 出队}
\NormalTok{    elemType getHead();                 // 访问队首元素}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570-5}
\begin{itemize}
\tightlist
\item
  申请一块空间，将 \texttt{front} 和 \texttt{rear} 初始化为 {}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{seqQueue\textless{}elemType\textgreater{}::seqQueue(int initSize)}
\NormalTok{\{}
\NormalTok{  elem = new elemType[initSize];}
\NormalTok{  maxSize = initSize;}
\NormalTok{  front = rear = 0;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{析构函数}
\protect\phantomsection\label{ux6790ux6784ux51fdux6570-3}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{seqQueue\textless{}elemType\textgreater{}::\textasciitilde{}seqQueue()}
\NormalTok{\{}
\NormalTok{  delete[] elem;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{enQueue}}
\protect\phantomsection\label{enqueue}
\begin{itemize}
\tightlist
\item
  先判断队列是否已满，若满则调用 \texttt{doubleSpace} 扩大队列的容量
\item
  将 \texttt{rear} 加1，指向队尾元素
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void seqQueue\textless{}elemType\textgreater{}::enQueue(const elemType \&x)}
\NormalTok{\{}
\NormalTok{  if ((rear + 1) \% maxSize == front)}
\NormalTok{  \{}
\NormalTok{    doubleSpace();}
\NormalTok{  \}}
\NormalTok{  rear = (rear + 1) \% maxSize;}
\NormalTok{  elem[rear] = x;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{doubleSpace}}
\protect\phantomsection\label{doublespace-1}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void seqQueue\textless{}elemType\textgreater{}::doubleSpace()}
\NormalTok{\{}
\NormalTok{  elemType *tmp = elem;}
\NormalTok{  elem = new elemType[maxSize * 2];}
\NormalTok{  for (int i = 0 ; i \textless{} maxSize ; ++i)}
\NormalTok{  \{}
\NormalTok{    elem[i] = tmp[(front + i) \% maxSize];}
\NormalTok{  \}}
\NormalTok{  front = 0;}
\NormalTok{  rear = maxSize {-} 1;}
\NormalTok{  maxSize *= 2;}
\NormalTok{  delete[] tmp;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{deQueue}}
\protect\phantomsection\label{dequeue}
\begin{itemize}
\tightlist
\item
  将 \texttt{front} 加1，指向队首元素
\item
  返回 \texttt{elem{[}front{]}}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{elemType seqQueue\textless{}elemType\textgreater{}::deQueue()}
\NormalTok{\{}
\NormalTok{  front = (front + 1) \% maxSize;}
\NormalTok{  return elem[front];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{getHead}}
\protect\phantomsection\label{gethead}
\begin{itemize}
\tightlist
\item
  返回 \texttt{elem{[}(front\ +\ 1)\ \%\ maxSize{]}}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{elemType seqQueue\textless{}elemType\textgreater{}::getHead()}
\NormalTok{\{}
\NormalTok{  return elem[(front + 1) \% maxSize];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{isEmpty}}
\protect\phantomsection\label{isempty-2}
\begin{itemize}
\tightlist
\item
  判断 \texttt{front} 是否等于 \texttt{rear}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{bool seqQueue\textless{}elemType\textgreater{}::isEmpty()}
\NormalTok{\{}
\NormalTok{  return front == rear;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}

\begin{block}{队列的链接实现}
\protect\phantomsection\label{ux961fux5217ux7684ux94feux63a5ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  为了方便操作，使用含头节点和尾节点的单链表实现
\end{itemize}


\textbf{链接队列的特点}

\begin{itemize}
\tightlist
\item
  不会出现队列满的情况，但是会出现队列空的情况
\item
  队列为空时，单链表中没有节点存在，即头尾指针都为 \texttt{nullptr}
\item
  保存一个链接队列只需要两个分别指向单链表节点的指针 \texttt{front} 和
  \texttt{rear}

  \begin{itemize}
  \tightlist
  \item
    \texttt{front} 指向队首元素
  \item
    \texttt{rear} 指向队尾元素
  \end{itemize}
\end{itemize}

\begin{block}{连接队列类}
\protect\phantomsection\label{ux8fdeux63a5ux961fux5217ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{class linkQueue:public queue\textless{}elemType\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    struct node}
\NormalTok{    \{}
\NormalTok{      elemType data;}
\NormalTok{      node *next;}
\NormalTok{      node(const elemType \&x , node *n = nullptr)}
\NormalTok{      \{}
\NormalTok{        data = x;}
\NormalTok{        next = n;}
\NormalTok{      \}}
\NormalTok{      node():next(nullptr)\{\}}
\NormalTok{      \textasciitilde{}node()\{\}}
\NormalTok{    \};}
\NormalTok{    node *front , *rear;                // 队头和队尾指针}
\NormalTok{  public:}
\NormalTok{    linkQueue();                       // 构造函数}
\NormalTok{    \textasciitilde{}linkQueue();                      // 析构函数}
\NormalTok{    bool isEmpty() ;              // 是否为空}
\NormalTok{    void enQueue(const elemType \&x);   // 入队}
\NormalTok{    elemType deQueue();                // 出队}
\NormalTok{    elemType getHead() const;          // 访问队首元素}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570-6}
\begin{itemize}
\tightlist
\item
  将 \texttt{front} 和 \texttt{rear} 初始化为 \texttt{nullptr}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{linkQueue\textless{}elemType\textgreater{}::linkQueue()}
\NormalTok{\{}
\NormalTok{  front = rear = nullptr;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{enQueue}}
\protect\phantomsection\label{enqueue-1}
\begin{enumerate}
\tightlist
\item
  申请一个节点空间 \texttt{x}
\item
  将 \texttt{rear} 指向的节点的 \texttt{next} 指向 \texttt{x}
\item
  将 \texttt{rear} 指向 \texttt{x}
\end{enumerate}

\textbf{注意}：存在队列为空的情况，此时我们只需要将 \texttt{front} 和
\texttt{rear} 都指向 \texttt{x} 即可

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void linkQueue\textless{}elemType\textgreater{}::enQueue(const elemType \&x)}
\NormalTok{\{}
\NormalTok{  if (rear == nullptr)}
\NormalTok{  \{}
\NormalTok{    front = rear = new node(x);}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    rear = rear{-}\textgreater{}next = new node(x);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{deQueue}}
\protect\phantomsection\label{dequeue-1}
\begin{enumerate}
\tightlist
\item
  返回 \texttt{front} 指向的节点的 \texttt{data}
\item
  将 \texttt{front} 指向的节点从链表中摘下
\item
  释放空间
\end{enumerate}

\textbf{注意}：当队列中只有一个元素时，删除后队列为空，此时需要将
\texttt{front} 和 \texttt{rear} 都置为 \texttt{nullptr}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{void LinkQueue\textless{}elemType\textgreater{}::deQueue()}
\NormalTok{\{}
\NormalTok{  node *tmp = front;}
\NormalTok{  if (front)}
\NormalTok{  \{}
\NormalTok{    emelType value = front{-}\textgreater{}data;}
\NormalTok{    front = front{-}\textgreater{}next;}
\NormalTok{    if (front == nullptr)}
\NormalTok{    \{}
\NormalTok{      rear = nullptr;}
\NormalTok{    \}}
\NormalTok{    delete tmp;}
\NormalTok{    return value;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{getHead}}
\protect\phantomsection\label{gethead-1}
\begin{itemize}
\tightlist
\item
  返回 \texttt{front} 指向的节点的 \texttt{data}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{elemType linkQueue\textless{}elemType\textgreater{}::getHead() const}
\NormalTok{\{}
\NormalTok{  return front{-}\textgreater{}data;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{isEmpty}}
\protect\phantomsection\label{isempty-3}
\begin{itemize}
\tightlist
\item
  判断 \texttt{front} 或 \texttt{rear} 是否为 \texttt{nullptr}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{bool linkQueue\textless{}elemType\textgreater{}::isEmpty()}
\NormalTok{\{}
\NormalTok{  return front == nullptr;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{析构函数}
\protect\phantomsection\label{ux6790ux6784ux51fdux6570-4}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class elemType\textgreater{}}
\NormalTok{linkQueue\textless{}elemType\textgreater{}::\textasciitilde{}linkQueue()}
\NormalTok{\{}
\NormalTok{  node *tmp;}
\NormalTok{  while (front != nullptr)}
\NormalTok{  \{}
\NormalTok{    tmp = front;}
\NormalTok{    front = front{-}\textgreater{}next;}
\NormalTok{    delete tmp;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}
\end{block}

\begin{block}{树}
\protect\phantomsection\label{ux6811}
\begin{block}{树的定义}
\protect\phantomsection\label{ux6811ux7684ux5b9aux4e49}
\begin{block}{树的递归定义}
\protect\phantomsection\label{ux6811ux7684ux9012ux5f52ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  树是 {} 个节点的有限集合，它或者是空集，或者满足

  \begin{itemize}
  \tightlist
  \item
    有一个特殊的节点称为根节点
  \item
    除根节点外，其他节点分为 {} 个互不相交的有限集合
    {}，每个集合都是一棵树
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{树的术语}
\protect\phantomsection\label{ux6811ux7684ux672fux8bed}
\begin{itemize}
\tightlist
\item
  \textbf{根节点、叶节点、内部节点}：

  \begin{itemize}
  \tightlist
  \item
    根节点：没有父节点的节点
  \item
    叶节点：没有子节点的节点
  \item
    内部节点：有子节点的节点
  \end{itemize}
\item
  \textbf{节点的度和树的度}：

  \begin{itemize}
  \tightlist
  \item
    节点的度：节点的子树个数
  \item
    树的度：树中所有节点的度的最大值
  \end{itemize}
\item
  \textbf{儿子节点}
\item
  \textbf{父亲节点}
\item
  \textbf{兄弟节点}
\item
  \textbf{祖先节点}
\item
  \textbf{子孙节点}
\item
  \textbf{节点所处层次}
\item
  \textbf{树的高度}
\item
  \textbf{有序树}
\item
  \textbf{无序树}
\item
  \textbf{森林}
\end{itemize}
\end{block}

\begin{block}{树的运算}
\protect\phantomsection\label{ux6811ux7684ux8fd0ux7b97}
\begin{itemize}
\tightlist
\item
  \textbf{建树 \texttt{create()}}：创建一个空树
\item
  \textbf{清空 \texttt{clear()}}：删除树中所有节点
\item
  \textbf{判空 \texttt{IsEmpty()}}：判断是否为空树
\item
  \textbf{找根节点
  \texttt{root()}}：找出树的根节点值，若为空树则返回特殊值
\item
  \textbf{找父节点
  \texttt{parent()}}：找到节点的父节点，若该节点不存在或为根节点则返回特殊值
\item
  \textbf{找子节点
  \texttt{child()}}：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值
\item
  \textbf{剪枝 \texttt{remove()}}：删除节点的某棵子树
\item
  \textbf{遍历 \texttt{traverse()}}：访问树上的每个节点
\end{itemize}
\end{block}

\begin{block}{树的抽象类}
\protect\phantomsection\label{ux6811ux7684ux62bdux8c61ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{class tree}
\NormalTok{\{}
\NormalTok{  public:}
\NormalTok{    virtual void clear() = 0;}
\NormalTok{    virtual bool isEmpty() const = 0;}
\NormalTok{    virtual T root(T flag) const = 0;}
\NormalTok{    virtual T parent(T x , T flag) const = 0;}
\NormalTok{    virtual T child(T x , int i , T flag) const = 0;}
\NormalTok{    virtual void remove(T x) = 0;}
\NormalTok{    virtual void traverse() const = 0;}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{二叉树}
\protect\phantomsection\label{ux4e8cux53c9ux6811}
\begin{block}{二叉树的定义}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7684ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  二叉树（Binary
  Tree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树
\end{itemize}

\textbf{注意}：二叉树是\textbf{有序树}，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树

二叉树有五种基本形态

\begin{enumerate}
\tightlist
\item
  空树
\item
  只有一个节点的树
\item
  只有左子树的树
\item
  只有右子树的树
\item
  左右子树都有的树
\end{enumerate}

\begin{block}{满二叉树}
\protect\phantomsection\label{ux6ee1ux4e8cux53c9ux6811}

\begin{itemize}
\tightlist
\item
  每个节点的度都为 {} 或 {} 的二叉树称为满二叉树
\item
  性质

  \begin{itemize}
  \tightlist
  \item
    高度为 {} 的满二叉树有 {} 个节点
  \item
    任意一层的节点个数达到了上限 {}
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{完全二叉树}
\protect\phantomsection\label{ux5b8cux5168ux4e8cux53c9ux6811}

\begin{itemize}
\tightlist
\item
  在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树
\item
  满二叉树是完全二叉树，完全二叉树不一定是满二叉树
\item
  性质

  \begin{itemize}
  \tightlist
  \item
    所有的叶节点都出现在最低的两层生
  \item
    对于任意节点，如果其右子树的高度为 {}，则其左子树的高度为 {} 或 {}
  \end{itemize}
\end{itemize}
\end{block}
\end{block}

\begin{block}{二叉树的性质}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7684ux6027ux8d28}
\begin{enumerate}
\tightlist
\item
  二叉树的第 {} 层最多有 {} 个节点
\item
  二叉树的深度为 {}，则最多有 {} 个节点
\item
  对于一棵非空二叉树，若其叶节点个数为 {}，则其度为 {} 的节点个数为
  {}，则有 {}
\item
  具有 {} 个节点的二叉树的高度为 {}，则 {}
\item
  对于一棵具有 {}
  个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为
  {}，则对任一编号为 {} 的节点，有

  \begin{enumerate}
  \tightlist
  \item
    如果 {}，则 {} 为根节点
  \item
    如果 {}，则 {} 的父节点编号为 {}
  \item
    如果 {}，则编号为 {} 的节点为叶子节点，没有儿子；否则，其左子编号为
    {}
  \item
    如果 {}，则编号为 {} 的节点无右儿子；否则，其右子编号为 {}
  \end{enumerate}
\end{enumerate}
\end{block}

\begin{block}{二叉树的基本运算}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7684ux57faux672cux8fd0ux7b97}
\begin{itemize}
\tightlist
\item
  \textbf{建树 \texttt{create()}}：创建一棵空树
\item
  \textbf{清空 \texttt{clear()}}：删除树中所有节点
\item
  \textbf{判空 \texttt{isEmpty()}}：判断是否为空树
\item
  \textbf{找根节点
  \texttt{root()}}：找出树的根节点值，若为空树则返回特殊值
\item
  \textbf{找父节点
  \texttt{parent()}}：找到节点的父节点，若该节点不存在或为根节点则返回特殊值
\item
  \textbf{找左子节点
  \texttt{lchild()}}：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值
\item
  \textbf{找右子节点
  \texttt{rchild()}}：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值
\item
  \textbf{删除左子树 \texttt{delLeft()}}：删除节点的左子树
\item
  \textbf{删除右子树 \texttt{delRight()}}：删除节点的右子树
\item
  \textbf{遍历 \texttt{traverse()}}：访问树上的每个节点
\end{itemize}
\end{block}

\begin{block}{二叉树的遍历}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7684ux904dux5386}
\begin{block}{前序遍历}
\protect\phantomsection\label{ux524dux5e8fux904dux5386}
\begin{itemize}
\tightlist
\item
  如果树为空，则操作为空
\item
  如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树
\end{itemize}
\end{block}

\begin{block}{中序遍历}
\protect\phantomsection\label{ux4e2dux5e8fux904dux5386}
\begin{itemize}
\tightlist
\item
  如果树为空，则操作为空
\item
  如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树
\end{itemize}
\end{block}

\begin{block}{后序遍历}
\protect\phantomsection\label{ux540eux5e8fux904dux5386}
\begin{itemize}
\tightlist
\item
  如果树为空，则操作为空
\item
  如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点
\end{itemize}
\end{block}

\begin{block}{层次遍历}
\protect\phantomsection\label{ux5c42ux6b21ux904dux5386}
\begin{itemize}
\tightlist
\item
  从上到下，从左到右访问树的每个节点
\end{itemize}
\end{block}

\begin{block}{性质}
\protect\phantomsection\label{ux6027ux8d28}
\begin{itemize}
\tightlist
\item
  由前序遍历和中序遍历可以唯一确定一棵二叉树
\item
  由中序遍历和后序遍历可以唯一确定一棵二叉树
\item
  由前序遍历和后序遍历\textbf{不能}唯一确定一棵二叉树
\end{itemize}
\end{block}
\end{block}

\begin{block}{二叉树抽象类}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux62bdux8c61ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{class binaryTree}
\NormalTok{\{}
\NormalTok{  public:}
\NormalTok{    virtual void clear() = 0;                     // 清空}
\NormalTok{    virtual bool isEmpty() const = 0;             // 是否为空}
\NormalTok{    virtual T root(T flag) const = 0;             // 找根节点}
\NormalTok{    virtual T parent(T x , T flag) const = 0;     // 找父节点}
\NormalTok{    virtual T lchild(T x , T flag) const = 0;     // 找左子节点}
\NormalTok{    virtual T rchild(T x , T flag) const = 0;     // 找右子节点}
\NormalTok{    virtual void delLeft(T x) = 0;                // 删除左子树}
\NormalTok{    virtual void delRight(T x) = 0;               // 删除右子树}
\NormalTok{    virtual void preOrder() const = 0;            // 前序遍历}
\NormalTok{    virtual void midOrder() const = 0;            // 中序遍历}
\NormalTok{    virtual void postOrder() const = 0;           // 后序遍历}
\NormalTok{    virtual void levelOrder() const = 0;          // 层次遍历}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{二叉树的实现}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7684ux5b9eux73b0}
\begin{block}{二叉树的顺序实现}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7684ux987aux5e8fux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  使用数组来存储二叉树中的节点
\item
  将二叉树补全为完全二叉树再进行存储
\item
  会导致空间浪费
\end{itemize}

\end{block}

\begin{block}{二叉树的链接实现}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7684ux94feux63a5ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  使用链表来存储二叉树中的节点

  \begin{itemize}
  \tightlist
  \item
    标准形式：\texttt{left}，\texttt{data}，\texttt{right}
  \end{itemize}
\end{itemize}


\begin{itemize}
\tightlist
\item
  广义标准形式：\texttt{data}，\texttt{left}，\texttt{parent}，\texttt{right}
\end{itemize}

\end{block}
\end{block}

\begin{block}{二叉树类}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7c7b}
\begin{block}{节点类}
\protect\phantomsection\label{ux8282ux70b9ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{struct Node}
\NormalTok{\{}
\NormalTok{  public:}
\NormalTok{    Node *left *right;                                                                // 左右子树指针}
\NormalTok{    T data;                                                                           // 节点数据}
\NormalTok{    Node():left(nullptr),right(nullptr)\{\}                                             // 默认构造函数}
\NormalTok{    Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R)\{\}  // 带参数的构造函数}
\NormalTok{    \textasciitilde{}Node()\{\}                                                                         // 析构函数}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{二叉树类}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7c7b-1}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{class binaryTree:public tree\textless{}T\textgreater{}}
\NormalTok{\{}
\NormalTok{    friend void printTree(const binaryTree \&t, t flag);}
\NormalTok{  private:}
\NormalTok{    struct Node}
\NormalTok{    \{}
\NormalTok{      public:}
\NormalTok{        Node *left *right;}
\NormalTok{        T data;}
\NormalTok{        Node():left(nullptr),right(nullptr)\{\}}
\NormalTok{        Node(T item , Node *L = nullptr,Node *R = nullptr):data(item),left(L),right(R)\{\}}
\NormalTok{        \textasciitilde{}Node()\{\}}
\NormalTok{    \}}
\NormalTok{    Node *root;}
\NormalTok{  public:}
\NormalTok{    binaryTree():root(nullptr)\{\}                    // 构造函数,创建空树}
\NormalTok{    binaryTree(T x):root(new Node(x))\{\}             // 构造函数,创建只有根节点的树}
\NormalTok{    \textasciitilde{}binaryTree()\{\}                                 // 析构函数}
\NormalTok{    void clear();                                   // 清空}
\NormalTok{    bool isEmpty() const;                           // 是否为空}
\NormalTok{    T Root(T flag) const;                           // 找根节点}
\NormalTok{    T lchild(const T \&x , T flag) const;            // 找左子节点}
\NormalTok{    T rchild(const T \&x , T flag) const;            // 找右子节点}
\NormalTok{    void delLeft(const T \&x);                       // 删除左子树}
\NormalTok{    void delRight(const T \&x);                      // 删除右子树}
\NormalTok{    void preOrder() const;                          // 前序遍历}
\NormalTok{    void midOrder() const;                          // 中序遍历}
\NormalTok{    void postOrder() const;                         // 后序遍历}
\NormalTok{    void levelOrder() const;                        // 层次遍历}
\NormalTok{    coid creatTree(T flag);                         // 创建树}
\NormalTok{    T parent(const T \&x , T flag) const             // 找父节点}
\NormalTok{    \{}
\NormalTok{      return flag;}
\NormalTok{    \}}
\NormalTok{  private:}
\NormalTok{    Node *Find(const T \&x, Node *t) const;            // 查找节点}
\NormalTok{    void clear(Node *\&x);                             // 清空}
\NormalTok{    void preOrder(Node *t) const;                     // 前序遍历}
\NormalTok{    void midOrder(Node *t) const;                     // 中序遍历}
\NormalTok{    void postOrder(Node *t) const;                    // 后序遍历}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570-7}
将 \texttt{root} 初始化为 \texttt{nullptr}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{binaryTree\textless{}T\textgreater{}::binaryTree()}
\NormalTok{\{}
\NormalTok{  root = nullptr;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{isEmpty}}
\protect\phantomsection\label{isempty-4}
\begin{itemize}
\tightlist
\item
  判断 \texttt{root} 是否为 \texttt{nullptr}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{bool binaryTree\textless{}T\textgreater{}::isEmpty() const}
\NormalTok{\{}
\NormalTok{  return root == nullptr;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{Root}}
\protect\phantomsection\label{root}
返回 \texttt{Root} 指向的节点的数据，若为空树则返回特殊值

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{T binaryTree\textless{}T\textgreater{}::Root(T flag)const}
\NormalTok{\{}
\NormalTok{  if (root == nullptr)}
\NormalTok{  \{}
\NormalTok{    return flag;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return root{-}\textgreater{}data;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{二叉树的遍历}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux7684ux904dux5386-1}
\begin{block}{前序遍历}
\protect\phantomsection\label{ux524dux5e8fux904dux5386-1}
\begin{enumerate}
\tightlist
\item
  访问根节点
\item
  前序遍历左子树
\item
  前序遍历右子树
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::preOrder(binaryTree\textless{}T\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  if (t == nullptr)}
\NormalTok{  \{}
\NormalTok{    return;}
\NormalTok{  \}}
\NormalTok{  else }
\NormalTok{  \{}
\NormalTok{    cout \textless{}\textless{} t {-}\textgreater{} data \textless{}\textless{} " ";}
\NormalTok{    preorder(t {-}\textgreater{} left);}
\NormalTok{    preorder(t {-}\textgreater{} right);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::preOrder() const}
\NormalTok{\{}
\NormalTok{  cout \textless{}\textless{} "\textbackslash{}n前序遍历："}
\NormalTok{  preOrder(root);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{中序遍历}
\protect\phantomsection\label{ux4e2dux5e8fux904dux5386-1}
\begin{enumerate}
\tightlist
\item
  中序遍历左子树
\item
  访问根节点
\item
  中序遍历右子树
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::midOrder(binaryTree\textless{}T\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  if (t == nullptr)}
\NormalTok{  \{}
\NormalTok{    return;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    midOrder(t {-}\textgreater{} left);}
\NormalTok{    cout \textless{}\textless{} t {-}\textgreater{} data \textless{}\textless{} " ";}
\NormalTok{    midOrder(t {-}\textgreater{} right);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::midOrder() const}
\NormalTok{\{}
\NormalTok{  cout \textless{}\textless{} "\textbackslash{}n中序遍历："}
\NormalTok{  midOrder(root);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{后序遍历}
\protect\phantomsection\label{ux540eux5e8fux904dux5386-1}
\begin{enumerate}
\tightlist
\item
  后序遍历左子树
\item
  后序遍历右子树
\item
  访问根节点
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::postOrder(binaryTree\textless{}T\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  if (t == nullptr)}
\NormalTok{  \{}
\NormalTok{    return;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    postOrder(t {-}\textgreater{} left);}
\NormalTok{    postOrder(t {-}\textgreater{} right);}
\NormalTok{    cout \textless{}\textless{} t {-}\textgreater{} data \textless{}\textless{} " ";}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::postOrder() const}
\NormalTok{\{}
\NormalTok{  cout \textless{}\textless{} "\textbackslash{}n后序遍历："}
\NormalTok{  postOrder(root);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{\texttt{size}}
\protect\phantomsection\label{size}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{int binaryTree\textless{}t\textgreater{}::size(binarytree\textless{}t\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  if (t = nullptr)}
\NormalTok{  \{}
\NormalTok{    return 0;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return 1+sizze(t {-}\textgreater{} left)+size(t {-}\textgreater{} right);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{int binaryTree\textless{}T\textgreater{}::size() const}
\NormalTok{\{}
\NormalTok{  return size(root);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{height}}
\protect\phantomsection\label{height}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{int binaryTree\textless{}T\textgreater{}::size(binaryTree\textless{}T\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  if (t == nullptr)}
\NormalTok{  \{}
\NormalTok{    return 0;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    int lt = height(t {-}\textgreater{} left);}
\NormalTok{    int rt = height(t {-}\textgreater{} right);}
\NormalTok{    return (lt \textgreater{} rt ? lt : rt) + 1;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{int binaryTree\textless{}T\textgreater{}::height() const}
\NormalTok{\{}
\NormalTok{  return height(root);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{层次遍历}
\protect\phantomsection\label{ux5c42ux6b21ux904dux5386-1}
\begin{itemize}
\tightlist
\item
  使用链接队列实现
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::levelOrder() const}
\NormalTok{\{}
\NormalTok{  linkQueue\textless{}Node *\textgreater{} que;}
\NormalTok{  Node *tmp;}
\NormalTok{  cout \textless{}\textless{} "\textbackslash{}n层次遍历：";}
\NormalTok{  que.enQueue(root);}
\NormalTok{  while (!que.isEmpty())}
\NormalTok{  \{}
\NormalTok{    tmp = que.deQueue();}
\NormalTok{    cout \textless{}\textless{} tmp {-}\textgreater{} data \textless{}\textless{} " ";}
\NormalTok{    if (tmp.left)}
\NormalTok{    \{}
\NormalTok{      que.enQueue(tmp {-}\textgreater{} left);}
\NormalTok{    \}}
\NormalTok{    if (tmp.right)}
\NormalTok{    \{}
\NormalTok{      que.enQueue(tmp {-}\textgreater{} right);}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{clear}}
\protect\phantomsection\label{clear-1}
\begin{itemize}
\tightlist
\item
  递归删除树中所有节点
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::clear(Node *\&t)}
\NormalTok{\{}
\NormalTok{  if (t == nullptr)}
\NormalTok{  \{}
\NormalTok{    return;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    clear(t {-}\textgreater{} left);}
\NormalTok{    clear(t {-}\textgreater{} right);}
\NormalTok{    delete t;}
\NormalTok{    t = nullptr;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::clear()}
\NormalTok{\{}
\NormalTok{  clear(root);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{析构函数}
\protect\phantomsection\label{ux6790ux6784ux51fdux6570-5}
\begin{itemize}
\tightlist
\item
  调用 \texttt{clear} 函数删除树中所有节点
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{binaryTree\textless{}T\textgreater{}::\textasciitilde{}binaryTree()}
\NormalTok{\{}
\NormalTok{  clear();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{Find}}
\protect\phantomsection\label{find}
\begin{itemize}
\tightlist
\item
  使用前序遍历查找 \texttt{x} 节点
\item
  首先检查根节点是否存放 \texttt{x} 的值，若是则返回根节点地址
\item
  对左子树递归调用 \texttt{Find} 函数，若返回空指针则说明 \texttt{x}
  不在左子树中
\item
  对右子树递归调用 \texttt{Find} 函数，若返回空指针则说明 \texttt{x}
  不在右子树中
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{struct binaryTree\textless{}T\textgreater{}:: Node *binaryTree\textless{}T\textgreater{}::Find(const T \&x ,binaryTree\textless{}T\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  if (t == nullptr)}
\NormalTok{  \{}
\NormalTok{    return nullptr;}
\NormalTok{  \}}
\NormalTok{  else if (t {-}\textgreater{} data == x)}
\NormalTok{  \{}
\NormalTok{    return t;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    if (tmp = Find(x,t{-}\textgreater{}left))}
\NormalTok{    \{}
\NormalTok{      return tmp;}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      return Find(x,t{-}\textgreater{}right);}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{delLeft}}
\protect\phantomsection\label{delleft}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::delLeft(const T \&x)}
\NormalTok{\{}
\NormalTok{  Node *tmp = Find(x,root);}
\NormalTok{  if (tmp == nullptr)}
\NormalTok{  \{}
\NormalTok{    return;}
\NormalTok{  \}}
\NormalTok{  clear(tmp {-}\textgreater{} left);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{delRight}}
\protect\phantomsection\label{delright}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::delRight(const T \&x)}
\NormalTok{\{}
\NormalTok{  Node *tmp = Find(x,root);}
\NormalTok{  if (tmp == nullptr)}
\NormalTok{  \{}
\NormalTok{    return;}
\NormalTok{  \}}
\NormalTok{  clear(tmp {-}\textgreater{} right);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{lchild}}
\protect\phantomsection\label{lchild}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{T binaryTree\textless{}T\textgreater{}::lchild(const T \&x ,T flag) const}
\NormalTok{\{}
\NormalTok{  Node *tmp = Find(x,root)}
\NormalTok{  if (tmp == nullptr || tmp {-}\textgreater{} left ==nullptr)}
\NormalTok{  \{}
\NormalTok{    return flag;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return tmp {-}\textgreater{} left;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{rchild}}
\protect\phantomsection\label{rchild}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{T binaryTree\textless{}T\textgreater{}::rchild(const T \&x ,T flag) const}
\NormalTok{\{}
\NormalTok{  Node *tmp = Find(x,root)}
\NormalTok{  if (tmp == nullptr || tmp {-}\textgreater{} right ==nullptr)}
\NormalTok{  \{}
\NormalTok{    return flag;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return tmp {-}\textgreater{} right;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{createTree}}
\protect\phantomsection\label{createtree}
\begin{itemize}
\tightlist
\item
  创建过程（类似层次遍历？）

  \begin{enumerate}
  \tightlist
  \item
    输入根节点的值，创建根节点
  \item
    对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入
    \texttt{flag}
  \end{enumerate}
\item
  实现过程

  \begin{itemize}
  \tightlist
  \item
    使用队列，将新加入到书中的节点添加到队列中
  \item
    依次出队，对每个出队的元素输入它的儿子
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::createTree(T flag)}
\NormalTok{\{}
\NormalTok{  linkQueue\textless{}Node *\textgreater{} que;}
\NormalTok{  Node *tmp;}
\NormalTok{  T x , ldata , rdata;}

\NormalTok{  // 创建树，flag表示空}
\NormalTok{  cout \textless{}\textless{} "\textbackslash{}n输入根节点："}
\NormalTok{  cin \textgreater{}\textgreater{} x;}
\NormalTok{  root = new Node(x);}
\NormalTok{  que.enQueue(root);}
\NormalTok{  while (!que.isEmpty())}
\NormalTok{  \{}
\NormalTok{    tmp = que,deQueue();}
\NormalTok{    cout \textless{}\textless{} "\textbackslash{}n输入" \textless{}\textless{} tmp {-}\textgreater{} data \textless{}\textless{} "的两个儿子（"\textless{}\textless{}flag\textless{}\textless{}"表示空节点）：";}
\NormalTok{    cin \textgreater{}\textgreater{} ldata \textgreater{}\textgreater{} rdata;}
\NormalTok{    if (ldata != flag)}
\NormalTok{    \{}
\NormalTok{      tmp {-}\textgreater{} left = new Node(ldata);}
\NormalTok{      que.enQueue(tmp {-}\textgreater{} left);}
\NormalTok{    \}}
\NormalTok{    if (rdata != flag)}
\NormalTok{    \{}
\NormalTok{      tmp {-}\textgreater{} right = new Node(rdata);}
\NormalTok{      que.enQueue(tmp {-}\textgreater{} right);}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  cout \textless{}\textless{} "that\textquotesingle{}s good!\textbackslash{}n";}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{printTree}}
\protect\phantomsection\label{printtree}
\begin{itemize}
\tightlist
\item
  层次遍历输出每个节点和它的左右孩子
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void printTree(const binaryTree\textless{}T\textgreater{} \&t,T flag)}
\NormalTok{\{}
\NormalTok{  linkQueue\textless{}T\textgreater{} que;}
\NormalTok{  que.enQueue(t.root());}
\NormalTok{  while(!que.isEmpty())}
\NormalTok{  \{}
\NormalTok{    T tmp = que.deQueue();}
\NormalTok{    T l = tmp.lchild(tmp , flag);}
\NormalTok{    T r = tmp.rchild(tmp , flag);}
\NormalTok{    cout \textless{}\textless{} p \textless{}\textless{} " " \textless{}\textless{} l \textless{}\textless{} " " \textless{}\textless{} r \textless{}\textless{} endl;}
\NormalTok{    if (l != flag)}
\NormalTok{    \{}
\NormalTok{      que.enQueue(l);}
\NormalTok{    \}}
\NormalTok{    if (r != flag)}
\NormalTok{    \{}
\NormalTok{      que.enQueue(r);}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{二叉树遍历的非递归实现}
\protect\phantomsection\label{ux4e8cux53c9ux6811ux904dux5386ux7684ux975eux9012ux5f52ux5b9eux73b0}
\begin{block}{前序遍历}
\protect\phantomsection\label{ux524dux5e8fux904dux5386-2}
\begin{enumerate}
\tightlist
\item
  将根节点入栈
\item
  栈顶元素出栈并输出值
\item
  将左右子树入栈（先右后左，以便输出时先输出左子树）
\item
  循环直至栈为空
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::preOrder(const binaryTree\textless{}T\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  linkStack\textless{}Node *\textgreater{} s;}
\NormalTok{  Node *tmp = t;}

\NormalTok{  cout \textless{}\textless{} "\textbackslash{}n前序遍历：";}
\NormalTok{  while (!s.isEmpty())}
\NormalTok{  \{}
\NormalTok{    tmp = s.pop();}
\NormalTok{    cout \textless{}\textless{} tm {-}\textgreater{} data \textless{}\textless{} " ";}
\NormalTok{    if (tmp {-}\textgreater{} right != nullptr)}
\NormalTok{    \{}
\NormalTok{      s.push(tmp {-}\textgreater{} right);}
\NormalTok{    \}}
\NormalTok{    if (tmp {-}\textgreater{} left != nullptr)}
\NormalTok{    \{}
\NormalTok{      s.push(tmp {-}\textgreater{} left);}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{中序遍历}
\protect\phantomsection\label{ux4e2dux5e8fux904dux5386-2}
\begin{enumerate}
\tightlist
\item
  根节点入栈
\item
  左子树入栈
\item
  栈顶元素出栈并输出值
\item
  左子树出栈完成之后根节点出栈
\item
  右子树入栈
\item
  循环直至栈为空
\end{enumerate}

栈的设计

\begin{itemize}
\tightlist
\item
  根节点入栈出栈两次

  \begin{itemize}
  \tightlist
  \item
    第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈
  \item
    第二次出栈后返回值，并且将右子树入栈
  \end{itemize}
\item
  对于根节点要记住

  \begin{itemize}
  \tightlist
  \item
    在哪棵树上
  \item
    第几次出栈
  \end{itemize}
\item
  每个节点在某种意义上都是根节点
\end{itemize}

\begin{block}{\texttt{StNode} 类定义}
\protect\phantomsection\label{stnode-ux7c7bux5b9aux4e49}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{struct StNode}
\NormalTok{\{}
\NormalTok{  Node *node;}
\NormalTok{  int TimesPop;}
\NormalTok{  StNode(Node *N=nullptr):node(N),TimesPop(0)\{\}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{中序遍历的非递归实现}
\protect\phantomsection\label{ux4e2dux5e8fux904dux5386ux7684ux975eux9012ux5f52ux5b9eux73b0}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::midOrder(const binaryTree\textless{}T\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  linkStack\textless{}Node *t\textgreater{} s;}
\NormalTok{  StNode current(root);}

\NormalTok{  cout \textless{}\textless{} "\textbackslash{}n中序遍历：";}
\NormalTok{  s.push(current);}
\NormalTok{  while(!s.isEmpty())}
\NormalTok{  \{}
\NormalTok{    current = s.pop();}
\NormalTok{    if (++current.TimesPop == 2)}
\NormalTok{    \{}
\NormalTok{      cout \textless{}\textless{} current.node {-}\textgreater{} data;}
\NormalTok{      if (current.node {-}\textgreater{} right != nullptr)}
\NormalTok{      \{}
\NormalTok{        s.push(StNode(current.node {-}\textgreater{} right));}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      s.push(current);}
\NormalTok{      if (current.node {-}\textgreater{} left != nullptr)}
\NormalTok{      \{}
\NormalTok{        s.push(StNode(current.node {-}\textgreater{} left));}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{后序遍历}
\protect\phantomsection\label{ux540eux5e8fux904dux5386-2}
\begin{enumerate}
\tightlist
\item
  根节点入栈
\item
  左子树入栈
\item
  右子树入栈
\item
  栈顶元素出栈并输出值
\item
  循环直至栈为空
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void binaryTree\textless{}T\textgreater{}::postOrder(const binaryTree\textless{}T\textgreater{}::Node *t) const}
\NormalTok{\{}
\NormalTok{  linkStack\textless{}Node *\textgreater{} s;}
\NormalTok{  StNode current(root);}

\NormalTok{  cout \textless{}\textless{} "\textbackslash{}n后序遍历：";}
\NormalTok{  s.push(current);}
\NormalTok{  while(!s.isEmpty())}
\NormalTok{  \{}
\NormalTok{    current = s.pop();}
\NormalTok{    if (++current.TimesPop == 3)}
\NormalTok{    \{}
\NormalTok{      cout \textless{}\textless{} current.node {-}\textgreater{} data;}
\NormalTok{      continue; }
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      s.push(current);}
\NormalTok{      if (current.node {-}\textgreater{} right != nullptr)}
\NormalTok{      \{}
\NormalTok{        s.push(StNode(current.node {-}\textgreater{} right));}
\NormalTok{      \}}
\NormalTok{      if (current.node {-}\textgreater{} left != nullptr)}
\NormalTok{      \{}
\NormalTok{        s.push(StNode(current.node {-}\textgreater{} left));}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}

\begin{block}{哈夫曼树和哈夫曼编码}
\protect\phantomsection\label{ux54c8ux592bux66fcux6811ux548cux54c8ux592bux66fcux7f16ux7801}
\begin{block}{字符的机内表示}
\protect\phantomsection\label{ux5b57ux7b26ux7684ux673aux5185ux8868ux793a}
\begin{itemize}
\tightlist
\item
  用二进制数来表示字符
\item
  前缀编码

  \begin{itemize}
  \tightlist
  \item
    字符只放在叶结点中
  \item
    字符编码可以有不同的长度
  \item
    每个字符的编码都不可能是其他字符编码的前缀
  \item
    可以被唯一解码
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{哈夫曼树}
\protect\phantomsection\label{ux54c8ux592bux66fcux6811}
\begin{itemize}
\tightlist
\item
  最小代价，即带权路径长度最小的二叉树
\item
  所有字符都在叶结点上
\item
  权值大的字符离根节点近，权值小的字符离根节点远
\item
  哈夫曼编码是一种前缀编码
\end{itemize}

\end{block}

\begin{block}{哈夫曼算法}
\protect\phantomsection\label{ux54c8ux592bux66fcux7b97ux6cd5}
\begin{enumerate}
\tightlist
\item
  给定一个具有 {} 个权值 {} 的节点的集合 {}\\
  {}
\item
  初始时，设集合 {}
\item
  执行从 {} 到 {} 的循环

  \begin{enumerate}
  \tightlist
  \item
    从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点
    {} 的左右儿子，{} 的权值为这两个节点的权值之和
  \item
    集合中去除这两个节点，将 {} 加入其中
  \end{enumerate}
\item
  循环结束后，集合 {}中只剩下一个节点 {}，即为哈夫曼树的根节点
\end{enumerate}
\end{block}

\begin{block}{哈夫曼编码}
\protect\phantomsection\label{ux54c8ux592bux66fcux7f16ux7801}
\begin{itemize}
\tightlist
\item
  每个节点的编码是从根节点到该节点的路径
\item
  左子树为 \texttt{0}，右子树为 \texttt{1}
\end{itemize}
\end{block}

\begin{block}{哈夫曼树类的实现}
\protect\phantomsection\label{ux54c8ux592bux66fcux6811ux7c7bux7684ux5b9eux73b0}
\begin{enumerate}
\tightlist
\item
  接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码
\item
  有两个公有的成员函数

  \begin{enumerate}
  \tightlist
  \item
    构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树
  \item
    \texttt{getCode}：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码
  \end{enumerate}
\end{enumerate}

\begin{block}{哈夫曼树的存储}
\protect\phantomsection\label{ux54c8ux592bux66fcux6811ux7684ux5b58ux50a8}
\begin{itemize}
\tightlist
\item
  在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为 {}
  的节点
\item
  若待编码的元素个数为 {}，则哈夫曼树的节点数为 {}
\item
  哈夫曼树使用一个大小为 {} 的数组来存储，不使用 {}
  节点，将根节点存储在下标为 {} 的位置，叶节点依次存储在下标为 {} 到 {}
  的位置，{} 结点作为结束的判断依据
\item
  每个数组保存
  \textbf{节点的数据}，\textbf{节点的权值}，\textbf{节点的父节点下标}，\textbf{左子节点下标}，\textbf{右子节点下标}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class Type\textgreater{}}
\NormalTok{class hfTree}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    struct Node}
\NormalTok{    \{}
\NormalTok{      Type data; //节点数据}
\NormalTok{      int weight; //节点权值}
\NormalTok{      int parent; //父节点下标}
\NormalTok{      int left , right; //左右子节点下标}
\NormalTok{    \};}

\NormalTok{    Node *elem;}
\NormalTok{    int length;}
  
\NormalTok{  public:}
\NormalTok{    struct hfCode}
\NormalTok{    \{}
\NormalTok{      Type data; //节点数据}
\NormalTok{      string code; //哈夫曼编码}
\NormalTok{    \};}

\NormalTok{    hfTree(const Type *v , const int *w , int size);}
\NormalTok{    void getCode(hfCode result[]);}
\NormalTok{    \textasciitilde{}hfTree()}
\NormalTok{    \{}
\NormalTok{      delete [] elem;}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{构造函数}
\protect\phantomsection\label{ux6784ux9020ux51fdux6570-8}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class Type\textgreater{}}
\NormalTok{hfTree\textless{}Type\textgreater{}::hfTree(const Type *v , const int *w , int size)}
\NormalTok{\{}
\NormalTok{  const int MAX\_INT = 32767;}
\NormalTok{  int min1 , min2; // 最小树、次最小树的权值}
\NormalTok{  int x , y ; // 最小树、次最小树的下标}

\NormalTok{  /* 初始化 */    }
\NormalTok{  length = 2 * size ;                                            // 哈夫曼树的节点数为 $2\textbackslash{}text\{size\}{-}1$，但我们只需要存储 $2\textbackslash{}text\{size\}$ 个节点}
\NormalTok{  elem = new Node[length];                                       // 创建一个大小为 $2\textbackslash{}text\{size\}$ 的数组来存储哈夫曼树的节点}
\NormalTok{  for (int i = size ; i \textless{} length ; i++)                          // 对数组 \textasciigrave{}elem\textasciigrave{} 中的节点进行初始化，前 $\textbackslash{}text\{size\}$ 个节点存储待编码的元素，从下标 \textasciigrave{}size\textasciigrave{} 开始，依次存储待编码的元素的权值}
\NormalTok{  \{}
\NormalTok{    elem[i].weight = w[i{-}size]; // 储存权值}
\NormalTok{    elem[i].data = v[i{-}size]; // 储存待编码的元素}
\NormalTok{    elem[i].parent = elem[i].left = elem[i].right = 0;           // 初始化父节点、左子节点和右子节点的下标为 \textasciigrave{}0\textasciigrave{}}
\NormalTok{  \}}

\NormalTok{  /* 构造新的二叉树 */}
\NormalTok{  for (int i = size {-} 1 ; i \textgreater{} 0 ; i{-}{-})                           // 从下标为 \textasciigrave{}size{-}1\textasciigrave{} 的节点开始，依次向上构造哈夫曼树的节点}
\NormalTok{  \{}
\NormalTok{    min1 = min2 = MAX\_INT;                                       // 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值}
\NormalTok{    x = y = 0;}
\NormalTok{    for (int j = i + 1 ; j \textless{} length ; j++)                       // 遍历当前节点之后的所有节点}
\NormalTok{    \{}
\NormalTok{      if (elem[j].parent == 0)                                   // 判断是否未加入树中}
\NormalTok{      \{}
\NormalTok{        if (elem[j].weight \textless{} min1)                               // 找到真正的最小值和次小值以及他们对应的下标}
\NormalTok{        \{}
\NormalTok{          min2 = min1;}
\NormalTok{          min1 = elem[j].weight;}
\NormalTok{          x = y;}
\NormalTok{          y = j;}
\NormalTok{        \}}
\NormalTok{        else if(elem[j].weight \textless{} min2)}
\NormalTok{        \{}
\NormalTok{          min2 = elem[j].weight;}
\NormalTok{          x = j;}
\NormalTok{        \}}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{    elem[i].weight = min1 + min2;                                // 将最小值和次小值的权值相加，作为当前节点的权值}
\NormalTok{    elem[i].left = x;                                            // 将最小值的节点作为当前节点的左子节点}
\NormalTok{    elem[i].right = y;                                           // 将次小值的节点作为当前节点的右子节点}
\NormalTok{    elem[x].parent = i;                                          // 将当前节点作为最小值节点的父节点}
\NormalTok{    elem[y].parent = i;                                          // 将当前节点作为次小值节点的父节点}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{getCode}}
\protect\phantomsection\label{getcode}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class Type\textgreater{}}
\NormalTok{void hdTree\textless{}Type\textgreater{}::getcode(hfCode result[])}
\NormalTok{\{}
\NormalTok{  int size = length / 2 ; }
\NormalTok{  int p , s ;}
\NormalTok{  for (int i = size; i \textless{} length; ++i)}
\NormalTok{  \{}
\NormalTok{    result[i {-}size].data = elem[i].data;}
\NormalTok{    result[i {-}size].code = "";}
\NormalTok{    p = elem[i].parent; s = i;}
\NormalTok{    while (p)}
\NormalTok{    \{}
\NormalTok{      if (elem[p].left == s)}
\NormalTok{      \{}
\NormalTok{        result[i {-}size].code = \textquotesingle{}0\textquotesingle{} + result[i {-}size].code;}
\NormalTok{      \}}
\NormalTok{      else}
\NormalTok{      \{}
\NormalTok{        result[i {-}size].code = \textquotesingle{}1\textquotesingle{} + result[i {-}size].code;}
\NormalTok{      \}}
\NormalTok{      s = p;}
\NormalTok{      p = elem[p].parent;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}

\begin{block}{树和森林}
\protect\phantomsection\label{ux6811ux548cux68eeux6797}
\begin{block}{树的存储实现}
\protect\phantomsection\label{ux6811ux7684ux5b58ux50a8ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  \textbf{标准形式}：除了数据字段之外，还有 {} 个指针字段，指向 {}
  个孩子节点，其中 {} 是树的度
\item
  \textbf{广义标准形式}：除了数据字段之外，还有 {} 个指针字段，指向 {}
  个孩子节点和一个指针字段，指向父节点
\end{itemize}

\end{block}

\begin{block}{树的表示方法}
\protect\phantomsection\label{ux6811ux7684ux8868ux793aux65b9ux6cd5}
\begin{block}{孩子链表示法}
\protect\phantomsection\label{ux5b69ux5b50ux94feux8868ux793aux6cd5}
\begin{itemize}
\item
  每个节点的所有孩子组织成一个链表
\item
  节点由两个部分组成

  \begin{itemize}
  \tightlist
  \item
    储存数据元素值的数据部分
  \item
    指向孩子链的指针
  \end{itemize}
\item
  \textbf{静态}的孩子链表：树的所有节点存放在一个名叫表头数组的\textbf{数组}中
\item
  \textbf{动态}的孩子链表：树的所有节点组织成一个\textbf{链表}
\end{itemize}
\end{block}

\begin{block}{孩子兄弟链表示法}
\protect\phantomsection\label{ux5b69ux5b50ux5144ux5f1fux94feux8868ux793aux6cd5}
\begin{itemize}
\tightlist
\item
  将一棵树转化为二叉树
\item
  左子树指向第一颗子树树根的指针
\item
  右子树指向兄弟节点的指针
\end{itemize}

\end{block}

\begin{block}{双亲表示法}
\protect\phantomsection\label{ux53ccux4eb2ux8868ux793aux6cd5}
\begin{itemize}
\tightlist
\item
  每一个节点由两个部分组成

  \begin{itemize}
  \tightlist
  \item
    储存数据元素的数据字段
  \item
    储存父节点的父指针字段
  \end{itemize}
\item
  便于查找节点的祖先，但是不便于查找指定节点的子孙
\end{itemize}
\end{block}
\end{block}
\end{block}

\begin{block}{树的遍历}
\protect\phantomsection\label{ux6811ux7684ux904dux5386}
\begin{block}{前序遍历}
\protect\phantomsection\label{ux524dux5e8fux904dux5386-3}
\begin{enumerate}
\tightlist
\item
  访问根节点
\item
  依次前序遍历所有子树
\end{enumerate}
\end{block}

\begin{block}{后序遍历}
\protect\phantomsection\label{ux540eux5e8fux904dux5386-3}
\begin{enumerate}
\tightlist
\item
  依次后序遍历所有子树
\item
  访问根节点
\end{enumerate}
\end{block}

\begin{block}{层次遍历}
\protect\phantomsection\label{ux5c42ux6b21ux904dux5386-2}
\begin{enumerate}
\tightlist
\item
  访问根节点
\item
  若第 {} 层已被访问，且第 {} 层的结点尚未被访问，则从左到右依次访问第
  {} 层的结点
\end{enumerate}
\end{block}

\begin{block}{特点}
\protect\phantomsection\label{ux7279ux70b9}
\begin{itemize}
\tightlist
\item
  树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的
\item
  树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的
\end{itemize}

由前序遍历和后序遍历可以唯一确定一棵树
\end{block}
\end{block}

\begin{block}{树、森林和二叉树}
\protect\phantomsection\label{ux6811ux68eeux6797ux548cux4e8cux53c9ux6811}
\begin{block}{森林的定义}
\protect\phantomsection\label{ux68eeux6797ux7684ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  森林通常被定义为树的集合或树的序列
\item
  存储

  \begin{itemize}
  \tightlist
  \item
    存储森林的每一棵树
  \item
    表示这些树属于同一个森林
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{森林的二叉树存储}
\protect\phantomsection\label{ux68eeux6797ux7684ux4e8cux53c9ux6811ux5b58ux50a8}
\begin{enumerate}
\tightlist
\item
  将每棵树 {} 转化为二叉树 {}
\item
  将 {} 作为 {} 根节点的右子树
\end{enumerate}
\end{block}
\end{block}
\end{block}

\begin{block}{优先级队列}
\protect\phantomsection\label{ux4f18ux5148ux7ea7ux961fux5217}
\begin{block}{优先级队列的定义}
\protect\phantomsection\label{ux4f18ux5148ux7ea7ux961fux5217ux7684ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  节点之间的关系是由节点的优先级决定的
\item
  优先级高的先出队，优先级低的后出队
\item
  继承于队列的抽象类
\end{itemize}
\end{block}

\begin{block}{优先级队列的简单实现}
\protect\phantomsection\label{ux4f18ux5148ux7ea7ux961fux5217ux7684ux7b80ux5355ux5b9eux73b0}
\begin{enumerate}
\tightlist
\item
  入队时进行排序，出队操作不变\\
  入队时间复杂度为 {}，出队时间复杂度为 {}
\item
  出队时进行排序，入队操作不变\\
  入队时间复杂度为 {}，出队时间复杂度为 {}
\end{enumerate}
\end{block}

\begin{block}{二叉堆}
\protect\phantomsection\label{ux4e8cux53c9ux5806}
\begin{itemize}
\tightlist
\item
  二叉堆是一个完全二叉树
\item
  二叉堆满足下述关系之一（下标是按层次遍历的次序）

  \begin{enumerate}
  \tightlist
  \item
    \textbf{最大化堆}：{}
  \item
    \textbf{最小化堆}：{}
  \end{enumerate}
\item
  后面的讨论都以最小化堆为例
\end{itemize}


\begin{block}{二叉堆的特性}
\protect\phantomsection\label{ux4e8cux53c9ux5806ux7684ux7279ux6027}
\begin{itemize}
\tightlist
\item
  \textbf{结构性}

  \begin{itemize}
  \tightlist
  \item
    符合完全二叉树的结构
  \end{itemize}
\item
  \textbf{有序性}

  \begin{itemize}
  \tightlist
  \item
    父节点小于子节点（最小化堆）
  \item
    父节点大于子节点（最大化堆）
  \end{itemize}
\end{itemize}
\end{block}
\end{block}

\begin{block}{基于二叉堆的优先级队列}
\protect\phantomsection\label{ux57faux4e8eux4e8cux53c9ux5806ux7684ux4f18ux5148ux7ea7ux961fux5217}
\begin{itemize}
\tightlist
\item
  如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列
\item
  最小化堆中，最小元素为根元素，存放在数组下标为 \texttt{1} 的位置

  \begin{itemize}
  \tightlist
  \item
    获取队头元素的操作为返回下标为 \texttt{1} 的元素值
  \item
    出队操作为删除下标为 \texttt{1} 的元素，重新调整堆
  \item
    入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{优先级队列类的定义}
\protect\phantomsection\label{ux4f18ux5148ux7ea7ux961fux5217ux7c7bux7684ux5b9aux4e49}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{class priorityQueue:public quque\textless{}T\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    int currentSize;}
\NormalTok{    T *array;}
\NormalTok{    int maxSize;}
\NormalTok{    void doubleSpace();}
\NormalTok{    voif buildHeap();  // 建堆，被 priorityQueue() 调用}
\NormalTok{    void percolateDown(int hole); // 向下过滤}
\NormalTok{  public:}
\NormalTok{    priorityQueue(int capacity = 100) // 构造函数}
\NormalTok{    \{}
\NormalTok{      array = new T[capacity];}
\NormalTok{      maxSize = capacity;}
\NormalTok{      currentSize = 0;}
\NormalTok{    \}}
\NormalTok{    priorityQueue(const T data[] , int size); // 构造函数}
\NormalTok{    \textasciitilde{}priorityQueue(); // 析构函数}
\NormalTok{    bool isEmpty() const // 是否为空}
\NormalTok{    \{}
\NormalTok{      return currentSize == 0;}
\NormalTok{    \}}
\NormalTok{    void enQueue(const T \&x); //入队}
\NormalTok{    T deQueue(); // 出队}
\NormalTok{    T getHead() const // 获取队头元素}
\NormalTok{    \{}
\NormalTok{      return array[1];}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\begin{block}{\texttt{enQueue}}
\protect\phantomsection\label{enqueue-2}
\begin{itemize}
\tightlist
\item
  在堆中插入一个新元素
\item
  在最大序号中的元素之后插入新的元素或者节点
\item
  如果没有违反堆的\textbf{有序性}，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void priorityQueue\textless{}T\textgreater{}::enQueue(const T \&x)}
\NormalTok{\{}
\NormalTok{  if (currentSize == maxSize {-} 1)}
\NormalTok{  \{}
\NormalTok{    doubleSpace();}
\NormalTok{  \}}

\NormalTok{  // 向上过滤}
\NormalTok{  int hole = ++currentSize;}
\NormalTok{  for (;hole \textgreater{} 1 \&\& x \textless{} array[hole/2] ; hole /= 2)}
\NormalTok{  \{}
\NormalTok{    array[hole] = array[hole/2];}
\NormalTok{  \}}
\NormalTok{  array[hole] = x;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  最坏情况时间复杂度为 {}
\item
  平均情况来说，过滤会提前结束。资料表明平均为 {} 次比较，即平均上移 {}
  层
\end{itemize}
\end{block}

\begin{block}{\texttt{deQueue}}
\protect\phantomsection\label{dequeue-2}
\begin{itemize}
\tightlist
\item
  删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树
\item
  空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{T priorityQueue\textless{}T\textgreater{}::deQueue()}
\NormalTok{\{}
\NormalTok{  T minItem;}
\NormalTok{  minItem = array[1];}
\NormalTok{  array[1] = array[currentSize{-}{-}];}
\NormalTok{  percolateDown(1);}
\NormalTok{  return minItem;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{percolateDown}}
\protect\phantomsection\label{percolatedown}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class T\textgreater{}}
\NormalTok{void priorityQueue\textless{}T\textgreater{}::precolateDown(int hole)}
\NormalTok{\{}
\NormalTok{  int child;}
\NormalTok{  T tmp = array[hole];}

\NormalTok{  for (;hole * 2 \textless{}= currentSize; hole = child)}
\NormalTok{  \{}
\NormalTok{    child = hole * 2;}
\NormalTok{    if (child != currentSIze \&\& array[child + 1] \textless{} array[child])}
\NormalTok{    \{}
\NormalTok{      child++;}
\NormalTok{    \}}
\NormalTok{    if (array[child] \textless{} tmp)}
\NormalTok{    \{}
\NormalTok{      array[hole] = array[child];}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      break;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  array[hole] = tmp;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{buildHeap}}
\protect\phantomsection\label{buildheap}
\begin{block}{连续插入}
\protect\phantomsection\label{ux8fdeux7eedux63d2ux5165}
\begin{itemize}
\tightlist
\item
  时间复杂度为 {}
\end{itemize}
\end{block}

\begin{block}{自上而下调整二叉树}
\protect\phantomsection\label{ux81eaux4e0aux800cux4e0bux8c03ux6574ux4e8cux53c9ux6811}
\begin{itemize}
\tightlist
\item
  对左子树和右子树递归调用 \texttt{buildHeaap}，再对根节点向下过滤
\item
  时间复杂度为 {}
\end{itemize}
\end{block}

\begin{block}{非递归实现}
\protect\phantomsection\label{ux975eux9012ux5f52ux5b9eux73b0-1}
从编号最大的非叶节点 {} 开始逆层次遍历，每个节点调用
\texttt{percolateDown}，直到根节点
\end{block}
\end{block}
\end{block}
\end{block}

\begin{block}{集合与静态查找表}
\protect\phantomsection\label{ux96c6ux5408ux4e0eux9759ux6001ux67e5ux627eux8868}
\begin{block}{集合的基本概念}
\protect\phantomsection\label{ux96c6ux5408ux7684ux57faux672cux6982ux5ff5}
\begin{enumerate}
\tightlist
\item
  数据元素除了属于同一集合之外，没有任何逻辑关系
\item
  每个数据元素有一个区别于其他元素的唯一标识，称为\textbf{键值}或者\textbf{关键字值}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}calss KEY , class OTHER\textgreater{}}
\NormalTok{struct SET}
\NormalTok{\{}
\NormalTok{  KEY key; // 关键字值}
\NormalTok{  OTHER other; // 其他信息}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

运算

\begin{itemize}
\tightlist
\item
  \textbf{查找} 某一元素是否存在
\item
  将集合中的元素按照它的唯一标识排序
\end{itemize}

这些都是对 \texttt{key} 的操作
\end{block}

\begin{block}{集合的存储}
\protect\phantomsection\label{ux96c6ux5408ux7684ux5b58ux50a8}
\begin{itemize}
\tightlist
\item
  任何容器都能存储集合
\item
  常用的表达形式是借鉴于\textbf{线性表}和\textbf{树}
\item
  唯一一个仅适合于存储和处理集合的数据结构是\textbf{散列表}
\end{itemize}
\end{block}

\begin{block}{查找}
\protect\phantomsection\label{ux67e5ux627e}
\begin{block}{查找的基本概念}
\protect\phantomsection\label{ux67e5ux627eux7684ux57faux672cux6982ux5ff5}
\begin{itemize}
\tightlist
\item
  用于查找的集合称之为\textbf{查找表}
\item
  查找表的分类

  \begin{itemize}
  \tightlist
  \item
    静态查找表
  \item
    动态查找表
  \item
    内部查找
  \item
    外部查找
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{静态查找表}
\protect\phantomsection\label{ux9759ux6001ux67e5ux627eux8868}
\begin{itemize}
\tightlist
\item
  数据元素的个数和值不允许变化的查找表称为静态查找表
\item
  不允许插入和删除操作
\item
  实例：字典
\item
  可以用顺序表 \texttt{seqList} 存储，或直接存储在C++的原始数组中
\end{itemize}
\end{block}

\begin{block}{无序表的查找}
\protect\phantomsection\label{ux65e0ux5e8fux8868ux7684ux67e5ux627e}
\begin{itemize}
\item
  只能做顺序查找
\item
  时间复杂度为 {}
\item
  可以使用哨兵减少 {} 次查找
\item
  优化后的顺序查找
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{int seqSearch(SET\textless{}KEY, OTHER\textgreater{} data[] , int size , const KEY \&x)}
\NormalTok{\{}
\NormalTok{  data[0].key = x;}
\NormalTok{  for (int i = size ; x != data[i].key; {-}{-}i)}
\NormalTok{  \{}
\NormalTok{    return i;}
\NormalTok{  \}}
\NormalTok{\}}
\NormalTok{13}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{有序表的查找}
\protect\phantomsection\label{ux6709ux5e8fux8868ux7684ux67e5ux627e}
\begin{block}{顺序查找}
\protect\phantomsection\label{ux987aux5e8fux67e5ux627e}
\begin{itemize}
\item
  与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头
\item
  时间复杂度为 {}
\item
  有序表的顺序查找
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{int seqSearch(SET\textless{}KEY , OTHER\textgreater{} data[] , int size , const KEY \&x)}
\NormalTok{\{}
\NormalTok{  data[0].key = x;}
\NormalTok{  for (int i = size ; x \textless{} data[i].key; {-}{-}i);}
\NormalTok{  if (x == data[i].key)}
\NormalTok{  \{}
\NormalTok{    return i;}
\NormalTok{  \}}
\NormalTok{else}
\NormalTok{\{}
\NormalTok{  return 0;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{二分查找}
\protect\phantomsection\label{ux4e8cux5206ux67e5ux627e}
\begin{enumerate}
\tightlist
\item
  每次检查中间的元素（向下取整）
\item
  若中间的元素等于要查找的元素，则查找成功
\item
  若中间的元素大于要查找的元素，则在左半部分继续查找
\item
  若中间的元素小于要查找的元素，则在右半部分继续查找
\end{enumerate}

\begin{itemize}
\tightlist
\item
  时间复杂度为 {}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{int binarySearch(SET\textless{}KEY , OTHER\textgreater{}data[] , int size , const KEY \&x) }
\NormalTok{\{}
\NormalTok{  int low = 1,  high = size, mid;}
\NormalTok{    while (low \textless{}= high)}
\NormalTok{    \{                 //查找区间存在}
\NormalTok{      mid = (low + high) / 2;         //计算中间位置}
\NormalTok{      if ( x == data[mid].key ) }
\NormalTok{      \{}
\NormalTok{        return mid;}
\NormalTok{      \}}
\NormalTok{      if (x \textless{} data[mid].key)}
\NormalTok{      \{}
\NormalTok{        high = mid {-} 1;}
\NormalTok{      \}}
\NormalTok{      else low = mid + 1;}
\NormalTok{    \}   }
\NormalTok{  return 0;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{插值查找}
\protect\phantomsection\label{ux63d2ux503cux67e5ux627e}
\begin{itemize}
\tightlist
\item
  适用于数据分布较为均匀的情况
\item
  计算中间位置的公式为
\end{itemize}

\begin{itemize}
\tightlist
\item
  缺点：计算量大
\end{itemize}
\end{block}

\begin{block}{分块查找}
\protect\phantomsection\label{ux5206ux5757ux67e5ux627e}
\begin{itemize}
\tightlist
\item
  将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的
\item
  查找分为两个阶段

  \begin{enumerate}
  \tightlist
  \item
    查找索引
  \item
    查找块\\
    设表长为 {}，块长为 {}\\
    则平均所需的时间为 {}\\
    当 {} 时，平均所需的时间\textbf{最短}，为 {}
  \end{enumerate}
\end{itemize}
\end{block}
\end{block}
\end{block}
\end{block}

\begin{block}{动态查找表}
\protect\phantomsection\label{ux52a8ux6001ux67e5ux627eux8868}
\begin{block}{二叉查找树}
\protect\phantomsection\label{ux4e8cux53c9ux67e5ux627eux6811}
\begin{block}{抽象类}
\protect\phantomsection\label{ux62bdux8c61ux7c7b-1}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{class dynamicSearchTable}
\NormalTok{\{}
\NormalTok{  public:}
\NormalTok{    virtual SET\textless{}KEY, OTHER\textgreater{} *find(const KEY \&x) const = 0;}
\NormalTok{    virtual void insert(const SET\textless{}KEY, OTHER\textgreater{} \&x) = 0;}
\NormalTok{    virtual void remove(const KEY \&x) = 0;}
\NormalTok{    virtual \textasciitilde{}dynamicSearchTable() \{\};}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{二叉查找树的定义}
\protect\phantomsection\label{ux4e8cux53c9ux67e5ux627eux6811ux7684ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  对于任意一个节点 \texttt{p}

  \begin{itemize}
  \tightlist
  \item
    \texttt{p} 的左子树中所有节点的值都小于 \texttt{p} 的值
  \item
    \texttt{p} 的右子树中所有节点的值都大于 \texttt{p} 的值
  \item
    \texttt{p} 的左子树和右子树都是二叉查找树
  \end{itemize}
\item
  二叉查找树的\textbf{中序遍历}是排好序的，又称为\textbf{排序树}
\item
  最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的
\end{itemize}
\end{block}

\begin{block}{二叉查找树的存储实现}
\protect\phantomsection\label{ux4e8cux53c9ux67e5ux627eux6811ux7684ux5b58ux50a8ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  使用二叉链表存储，需要一个指向根节点的数据成员
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{class BinarySearchTree:public dynamicSearchTable\textless{}KEY , OTHER\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    struct BinaryNode}
\NormalTok{    \{}
\NormalTok{      SET\textless{}KEY, OTHER\textgreater{} data;}
\NormalTok{      BinaryNode*left;}
\NormalTok{      BinaryNode*right;}
\NormalTok{      BinaryNode( const SET\textless{}KEY, OTHER\textgreater{} \& thedata,}
\NormalTok{      BinaryNode *lt = nullptr , BinaryNode *rt = nullptr):data(thedata) , left(lt) , right(rt)\{\}}
\NormalTok{    \};}
\NormalTok{    BinaryNode*root;}

\NormalTok{  public:}
\NormalTok{    BinarySearchTree();}
\NormalTok{    \textasciitilde{}BinarySearchTree();}
\NormalTok{    SET\textless{}KEY, OTHER\textgreater{} *find(const KEY \&x) const ;}
\NormalTok{    void insert(const SET\textless{}KEY , OTHER\textgreater{} \&x );}
\NormalTok{    void remove(const KEY \&x);}
  
\NormalTok{  private:}
\NormalTok{    void insert(const SET\textless{}KEY , OTHER\textgreater{} \&x, BinaryNode *\&t);}
\NormalTok{    void remove(const KEY \&x , BinaryNode *\&t);}
\NormalTok{    SET\textless{}KEY , OTHER\textgreater{} *find(const KEY \&x , BinaryNode *t ) const;}
\NormalTok{    void makeEmpty(BinaryNode *t);//析构用，同二叉树的clear}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{二叉查找树的操作}
\protect\phantomsection\label{ux4e8cux53c9ux67e5ux627eux6811ux7684ux64cdux4f5c}
\begin{block}{查找}
\protect\phantomsection\label{ux67e5ux627e-1}
\begin{enumerate}
\tightlist
\item
  检查根节点的关键字值
\item
  如果等于要查找的值，则查找成功，返回根节点地址
\item
  如果小于要查找的值，则在右子树中查找
\item
  如果大于要查找的值，则在左子树中查找
\end{enumerate}

\begin{itemize}
\tightlist
\item
  公有函数 \texttt{find(const\ KEY\ \&x)}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{SET\textless{}KEY, OTHER\textgreater{} *BinarySearchTree\textless{}KEY, OTHER\textgreater{}::find(const KEY \&x ) const}
\NormalTok{\{}
\NormalTok{  return find( x, root );}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  私有辅助函数 \texttt{find(const\ KEY\ \&x,\ BinaryNode\ *t)}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{SET\textless{}KEY, OTHER\textgreater{} *BinarySearchTree\textless{}KEY, OTHER\textgreater{}::find(const KEY \&x, BinaryNode *t ) const}
\NormalTok{\{}
\NormalTok{  if (t == nullptr || t{-}\textgreater{}data.key == x)}
\NormalTok{  \{}
\NormalTok{    return (SET\textless{}KEY , OTHER\textgreater{} *)t;//强制类型转换}
\NormalTok{  \}}
\NormalTok{  if(x \textless{} t{-}\textgreater{}data.key)}
\NormalTok{  \{}
\NormalTok{    return find(x , t{-}\textgreater{}left);}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return find(x , t{-}\textgreater{}right );}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{插入}
\protect\phantomsection\label{ux63d2ux5165}
\begin{itemize}
\item
  若二叉树为空树，则插入的节点为根节点
\item
  若二叉树非空

  \begin{itemize}
  \tightlist
  \item
    判断是左儿子还是右儿子，作为叶节点插入
  \end{itemize}
\item
  公有的
  \texttt{insert(const\ SET\textless{}KEY,\ OTHER\textgreater{}\ \&x)}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void BinarySearchTree\textless{}KEY, OTHER\textgreater{}::insert(const SET\textless{}KEY , OTHER\textgreater{} \&x)}
\NormalTok{\{}
\NormalTok{  insert(x, root);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  私有的
  \texttt{insert(const\ SET\textless{}KEY,\ OTHER\textgreater{}\ \&x,\ BinaryNode\ *\&t)}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void BinarySearchTree\textless{}KEY , OTHER\textgreater{}::insert(const SET\textless{}KEY , OTHER\textgreater{} \&x, BinaryNode *\&t)}
\NormalTok{\{}
\NormalTok{  if(t == nullptr)}
\NormalTok{  t = new BinaryNode(x , nullptr , nullptr);}
\NormalTok{  else if(x.key\textless{} t{-}\textgreater{}data.key)}
\NormalTok{  \{}
\NormalTok{    insert(x, t{-}\textgreater{}left);}
\NormalTok{  \}}
\NormalTok{  else if(x.key \textgreater{} t{-}\textgreater{}data.key)}
\NormalTok{  \{}
\NormalTok{    insert(x , t{-}\textgreater{}right);}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    cout \textless{}\textless{} x.key \textless{}\textless{} “is exist” \textless{}\textless{} endl;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{删除}
\protect\phantomsection\label{ux5220ux9664}
\begin{itemize}
\item
  {} 和 {} 分别是 {} 的左子树和右子树

  \begin{enumerate}
  \tightlist
  \item
    如果 {} 是叶节点，则直接删除
  \item
    如果 {} 只有一个子树，则将 {} 的父节点指向 {} 的子树
  \item
    如果 {} 有两个子树，则

    \begin{enumerate}
    \tightlist
    \item
      找到 {} 的右子树中最左的节点或者左子树的最右节点 {}
    \item
      将 {} 的值赋给 {}
    \item
      删除 {} 节点
    \end{enumerate}
  \end{enumerate}
\item
  公有的 \texttt{remove(const\ KEY\ \&x)}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void BinarySearchTree\textless{}KEY, OTHER\textgreater{}::remove(const KEY \&x)}
\NormalTok{\{}
\NormalTok{  remove(x , root);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  私有的 \texttt{remove(const\ KEY\ \&x,\ BinaryNode\ *\&t)}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void BinarySearchTree\textless{}KEY , OTHER\textgreater{}::remove(const KEY \&x , BinaryNode *\&t)}
\NormalTok{\{}
\NormalTok{  if(t == nullptr)}
\NormalTok{  \{}
\NormalTok{    cout \textless{}\textless{} x.key \textless{}\textless{} "is not exist" \textless{}\textless{} endl;}
\NormalTok{  \}}
\NormalTok{  else if(x.key \textless{} t{-}\textgreater{}data.key)}
\NormalTok{  \{}
\NormalTok{    remove(x , t{-}\textgreater{}left);}
\NormalTok{  \}}
\NormalTok{  else if(x.key \textgreater{} t{-}\textgreater{}data.key)}
\NormalTok{  \{}
\NormalTok{    remove(x , t{-}\textgreater{}right);}
\NormalTok{  \}}
\NormalTok{  else if(t{-}\textgreater{}left != nullptr \&\& t{-}\textgreater{}right != nullptr)}
\NormalTok{  \{}
\NormalTok{    BinaryNode *p = t{-}\textgreater{}right;}
\NormalTok{    while(p{-}\textgreater{}left != nullptr)}
\NormalTok{    \{}
\NormalTok{      p = p{-}\textgreater{}left;}
\NormalTok{    \}}
\NormalTok{    t{-}\textgreater{}data = p{-}\textgreater{}data;}
\NormalTok{    remove(p{-}\textgreater{}data.key , t{-}\textgreater{}right);}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    BinaryNode *oldNode = t;}
\NormalTok{    t = (t{-}\textgreater{}left != nullptr) ? t{-}\textgreater{}left : t{-}\textgreater{}right;}
\NormalTok{    delete oldNode;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{二叉查找树的性能}
\protect\phantomsection\label{ux4e8cux53c9ux67e5ux627eux6811ux7684ux6027ux80fd}
\begin{itemize}
\tightlist
\item
  二叉查找树的操作的时间复杂度为树的高度
\item
  如果二叉查找树是平衡的，则访问的代价是 {}
\item
  最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 {}
\end{itemize}

\textbf{平均性能}

具有 {} 个节点的二叉查找树可能有 {} 种不同的形态\\
{}\strut \\
若设这些形态出现的概率是相同的，设 {} 为查找 {}
个节点的二叉查找树的平均查找时间，则有如下递归关系式：
\end{block}
\end{block}

\begin{block}{AVL树}
\protect\phantomsection\label{avlux6811}
\begin{block}{AVL树的定义}
\protect\phantomsection\label{avlux6811ux7684ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  也叫平衡树

  \begin{itemize}
  \tightlist
  \item
    对于任意一个节点的两棵子树的高度至多相差1
  \end{itemize}
\item
  平衡因子

  \begin{itemize}
  \tightlist
  \item
    节点的左子树的高度减去右子树的高度
  \item
    平衡因子只能是 {}，{}，{}
  \end{itemize}
\item
  优点

  \begin{itemize}
  \tightlist
  \item
    查找，插入和删除操作的时间复杂度都是 {}
  \end{itemize}
\end{itemize}

\begin{block}{查找性能}
\protect\phantomsection\label{ux67e5ux627eux6027ux80fd}
\begin{itemize}
\item
  与二叉树的高度成正比
\item
  定理：

  \begin{itemize}
  \tightlist
  \item
    具有 {} 个节点的平衡树，高度 {} 满足 {}
  \item
    因此，平衡二叉树的操作都是 {}
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{斐波那契树}
\protect\phantomsection\label{ux6590ux6ce2ux90a3ux5951ux6811}
\begin{itemize}
\item
  斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为1
\item
  定义

  \begin{enumerate}
  \tightlist
  \item
    空树是高度为0的斐波那契树
  \item
    单个节点是高度为1的斐波那契树
  \item
    若 {} 和 {} 分别为高度为 {} 和 {} 的斐波那契树，则 {} 是高度为 {}
    的斐波那契树
  \item
    没有其他的树是斐波那契树
  \end{enumerate}
\end{itemize}

\begin{block}{斐波那契树的特点}
\protect\phantomsection\label{ux6590ux6ce2ux90a3ux5951ux6811ux7684ux7279ux70b9}
对于高度为 {} 的斐波那契树，节点数 {} 满足

\begin{itemize}
\tightlist
\item
  {}
\item
  {}
\item
  {}
\end{itemize}
\end{block}
\end{block}
\end{block}

\begin{block}{AVL树的存储实现}
\protect\phantomsection\label{avlux6811ux7684ux5b58ux50a8ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  使用二叉链表
\item
  每个节点必须保存平衡信息

  \begin{itemize}
  \tightlist
  \item
    每棵树的高度
  \item
    平衡度即左右子树的高度差
  \end{itemize}
\end{itemize}

\begin{block}{AVL树类的实现}
\protect\phantomsection\label{avlux6811ux7c7bux7684ux5b9eux73b0}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}clas KEY,class OTHER\textgreater{}}
\NormalTok{class AvlTree:public dynamicSearchTable\textless{}KEY , OTHER\textgreater{}}
\NormalTok{\{}
\NormalTok{    struct AvlNode}
\NormalTok{    \{}
\NormalTok{      SET\textless{}KEY , OTHER\textgreater{} data ; // 关键字}
\NormalTok{      AvlNode *left , *right; // 左右子树指针}
\NormalTok{      int height;            // 节点高度}
  
\NormalTok{      AvlNode(const SET\textless{}KEY , OTHER\textgreater{} \&element , AvlNode *lt ,AvlNode   *rt , int h = 1):data(elemeent) , left(lt) , right(rt) , height  (h) \{\} // 构造函数}
\NormalTok{    \};}
  
\NormalTok{    AvlNode *root; // 根节点}
\NormalTok{  public:}
\NormalTok{    AvlTree() // 构造函数}
\NormalTok{    \{}
\NormalTok{      root = nullptr;}
\NormalTok{    \}}
\NormalTok{    \textasciitilde{}AvlTree() // 析构函数}
\NormalTok{    \{}
\NormalTok{      makeEmpty(root);}
\NormalTok{    \}}
\NormalTok{    SET\textless{}KEY, OTHER\textgreater{} *find(const KEY \&x) const;}
\NormalTok{    void remove(const KEY \& x);}
\NormalTok{  private:}
\NormalTok{    void insert( const SET\textless{}KEY, OTHER\textgreater{} \& x, AvlNode * \& t ) ; // 插入}
\NormalTok{    bool remove( const KEY \& x, AvlNode * \& t ) ;}
\NormalTok{    void makeEmpty( AvlNode *t );}
\NormalTok{    int height(AvlNode *t) const  // 返回节点的高度}
\NormalTok{    \{}
\NormalTok{      return t == nullptr ? 0 : t {-}\textgreater{} height;}
\NormalTok{    \}}
\NormalTok{    void LL( AvlNode * \& t ); // 左旋}
\NormalTok{    void RR( AvlNode * \& t ); // 右旋}
\NormalTok{    void LR( AvlNode * \& t ); // 左右旋}
\NormalTok{    void RL( AvlNode * \& t ); // 右左旋}
\NormalTok{    int max(int a, int b)     // 返回两个数中较大的一个}
\NormalTok{    \{}
\NormalTok{      return a \textgreater{} b ? a : b;}
\NormalTok{    \}}
\NormalTok{    bool adjust(AvlNode *\&t, int subTree); //用于删除}
\NormalTok{\};  }
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{AVL树的查找}
\protect\phantomsection\label{avlux6811ux7684ux67e5ux627e}
\begin{itemize}
\tightlist
\item
  与二叉查找树相同
\item
  二叉查找树类采用递归实现
\item
  AVL树类展示非递归实现
\end{itemize}

\begin{block}{查找的非递归实现}
\protect\phantomsection\label{ux67e5ux627eux7684ux975eux9012ux5f52ux5b9eux73b0}
\begin{enumerate}
\tightlist
\item
  设当前节点为根节点
\item
  若当前节点非空

  \begin{enumerate}
  \tightlist
  \item
    若当前节点的值等于 \texttt{x}，则返回当前节点
  \item
    若当前节点的值大于 \texttt{x}，则将当前节点指向左子树
  \item
    若当前节点的值小于 \texttt{x}，则将当前节点指向右子树
  \end{enumerate}
\item
  若当前节点为空，则返回空
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY,class OTHER\textgreater{}}
\NormalTok{SET\textless{}KEY, OTHER\textgreater{} *AvlTree\textless{}KEY, OTHER\textgreater{}::find(const KEY \& x) const}
\NormalTok{\{}
\NormalTok{  AvlNode *t = root; }
\NormalTok{  while (t!=nullptr \&\& t{-}\textgreater{}data.key != x) }
\NormalTok{  \{}
\NormalTok{    if (x \textless{} t{-}\textgreater{}data.key) }
\NormalTok{    \{}
\NormalTok{      t = t{-}\textgreater{}left;}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      t = t{-}\textgreater{}right;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  if (t == nullptr)}
\NormalTok{  \{}
\NormalTok{    return nullptr;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return t{-}\textgreater{}data;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{AVL树的插入}
\protect\phantomsection\label{avlux6811ux7684ux63d2ux5165}
\begin{itemize}
\tightlist
\item
  与二叉查找树相同

  \begin{itemize}
  \tightlist
  \item
    可能改变了根到插入节点的路径上某些节点的平衡度
  \item
    需要向上修改树的结构
  \end{itemize}
\end{itemize}

\begin{block}{可能引起节点不平衡的情况}
\protect\phantomsection\label{ux53efux80fdux5f15ux8d77ux8282ux70b9ux4e0dux5e73ux8861ux7684ux60c5ux51b5}
\begin{itemize}
\tightlist
\item
  节点的左孩子的左子树上插入（LL）
\item
  节点的左孩子的右子树上插入（LR）
\item
  节点的右孩子的左子树上插入（RL）
\item
  节点的右孩子的右子树上插入（RR）
\end{itemize}
\end{block}

\begin{block}{重构的方法}
\protect\phantomsection\label{ux91cdux6784ux7684ux65b9ux6cd5}
\begin{itemize}
\tightlist
\item
  指针调整

  \begin{itemize}
  \tightlist
  \item
    按照投影序保持结点相邻关系不变
  \item
    辈分可以改变
  \end{itemize}
\end{itemize}

\begin{block}{LL问题}
\protect\phantomsection\label{llux95eeux9898}

\begin{itemize}
\tightlist
\item
  \textbf{左旋}

  \begin{enumerate}
  \tightlist
  \item
    将失衡点的左儿子作为新的根节点
  \item
    左儿子的右儿子作为原根节点的左儿子
  \end{enumerate}
\item
  若为RR问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为\textbf{右旋}
\item
  左旋和右旋统称为\textbf{单旋转}，保留了树的有序性和原先的高度
\end{itemize}
\end{block}

\begin{block}{LR问题}
\protect\phantomsection\label{lrux95eeux9898}

\begin{itemize}
\tightlist
\item
  \textbf{双旋转}

  \begin{enumerate}
  \tightlist
  \item
    将失衡点的左儿子右旋
  \item
    将失衡点左旋
  \end{enumerate}
\item
  若为RL问题，则将失衡点的右儿子左旋，再将失衡点右旋
\item
  先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使\textbf{原先的孙子变成根}
\end{itemize}
\end{block}
\end{block}

\begin{block}{私有的\texttt{insert} 函数}
\protect\phantomsection\label{ux79c1ux6709ux7684insert-ux51fdux6570}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY,class OTHER\textgreater{}}
\NormalTok{void AvlTree\textless{}KEY, OTHER\textgreater{}::insert(const SET\textless{}KEY, OTHER\textgreater{} \& x, AvlNode * \& t)}
\NormalTok{\{}
\NormalTok{  if (t == nullptr)}
\NormalTok{  \{}
\NormalTok{    t = new AvlNode(x , nullptr , nullptr);}
\NormalTok{  \}}
\NormalTok{  else if (x.key \textless{} t{-}\textgreater{}data.key)}
\NormalTok{  \{}
\NormalTok{    insert(x , t{-}\textgreater{}left);}
\NormalTok{    if (height(t{-}\textgreater{}left) {-} height(t{-}\textgreater{}right) == 2)}
\NormalTok{    \{}
\NormalTok{      if (x.key \textless{} t{-}\textgreater{}left{-}\textgreater{}data.key)}
\NormalTok{      \{}
\NormalTok{        LL(t);}
\NormalTok{      \}}
\NormalTok{      else}
\NormalTok{      \{}
\NormalTok{        LR(t);}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  else if (x.key \textgreater{} t{-}\textgreater{}data.key)}
\NormalTok{  \{}
\NormalTok{    insert(x , t{-}\textgreater{}right);}
\NormalTok{    if (height(t{-}\textgreater{}right) {-} height(t{-}\textgreater{}left) == 2)}
\NormalTok{    \{}
\NormalTok{      if (x.key \textgreater{} t{-}\textgreater{}right{-}\textgreater{}data.key)}
\NormalTok{      \{}
\NormalTok{        RR(t);}
\NormalTok{      \}}
\NormalTok{      else}
\NormalTok{      \{}
\NormalTok{        RL(t);}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  t{-}\textgreater{}height = max(height(t{-}\textgreater{}left) , height(t{-}\textgreater{}right)) + 1; // 更新高度}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{block}{\texttt{LL}}
\protect\phantomsection\label{ll}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY,class OTHER\textgreater{}}
\NormalTok{void AvlTree\textless{}KEY,OTHER\textgreater{}::LL(AvlNode *\& t)}
\NormalTok{\{}
\NormalTok{  AvlNode *t1 = t{-}\textgreater{}left;}
\NormalTok{  t{-}\textgreater{}left = t1{-}\textgreater{}right;}
\NormalTok{  t1{-}\textgreater{}right = t;}
\NormalTok{  t{-}\textgreater{}height = max(height(t{-}\textgreater{}left) , height(t{-}\textgreater{}right)) + 1;}
\NormalTok{  t1{-}\textgreater{}height = max(height(t1{-}\textgreater{}left) , height(t1{-}\textgreater{}right)) + 1;}
\NormalTok{  t = t1;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{RR}}
\protect\phantomsection\label{rr}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY,class OTHER\textgreater{}}
\NormalTok{void AvlTree\textless{}KEY,OTHER\textgreater{}::RR(AvlNode *\& t)}
\NormalTok{\{}
\NormalTok{  AvlNode *t1 = t{-}\textgreater{}right;}
\NormalTok{  t{-}\textgreater{}right = t1{-}\textgreater{}left;}
\NormalTok{  t1{-}\textgreater{}left = t;}
\NormalTok{  t{-}\textgreater{}height = max(height(t{-}\textgreater{}left) , height(t{-}\textgreater{}right)) + 1;}
\NormalTok{  t1{-}\textgreater{}height = max(height(t1{-}\textgreater{}left) , height(t1{-}\textgreater{}right)) + 1;}
\NormalTok{  t = t1;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{LR}}
\protect\phantomsection\label{lr}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY,class OTHER\textgreater{}}
\NormalTok{void AvlTree\textless{}KEY,OTHER\textgreater{}::LR(AvlNode *\& t)}
\NormalTok{\{}
\NormalTok{  RR(t{-}\textgreater{}left);}
\NormalTok{  LL(t);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{RL}}
\protect\phantomsection\label{rl}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY,class OTHER\textgreater{}}
\NormalTok{void AvlTree\textless{}KEY,OTHER\textgreater{}::RL(AvlNode *\& t)}
\NormalTok{\{}
\NormalTok{  LL(t{-}\textgreater{}right);}
\NormalTok{  RR(t);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

所有旋转的算法时间复杂度都是 {}，且只运行一次，所以 \texttt{insert}
的时间复杂度为 {}
\end{block}
\end{block}
\end{block}

\begin{block}{AVL树的删除}
\protect\phantomsection\label{avlux6811ux7684ux5220ux9664}
\begin{enumerate}
\tightlist
\item
  在AVL树上删除节点 \texttt{x}，删除操作和二叉查找树相同
\item
  调整平衡，与插入操作相同
\end{enumerate}
\end{block}

\begin{block}{调整}
\protect\phantomsection\label{ux8c03ux6574}
\begin{itemize}
\tightlist
\item
  与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度
\item
  删除时无法保证子树在平衡调整之后的高度不变
\item
  递归的删除函数有一个 bool 型的返回值，当返回值为 \texttt{true}
  时，调整停止
\end{itemize}
\end{block}

\begin{block}{五种情况}
\protect\phantomsection\label{ux4e94ux79cdux60c5ux51b5}
\begin{block}{情况a}
\protect\phantomsection\label{ux60c5ux51b5a}

此时没有失衡，高度也没有改变，返回\texttt{true}
\end{block}

\begin{block}{情况b}
\protect\phantomsection\label{ux60c5ux51b5b}

此时没有失衡，但是高度变矮，返回\texttt{false}
\end{block}

\begin{block}{情况c}
\protect\phantomsection\label{ux60c5ux51b5c}

经过RR旋转后高度变矮，返回\texttt{false}
\end{block}

\begin{block}{情况d}
\protect\phantomsection\label{ux60c5ux51b5d}

经过RL旋转后高度变矮，返回\texttt{false}
\end{block}

\begin{block}{情况e}
\protect\phantomsection\label{ux60c5ux51b5e}

经过RR或RL旋转后高度不变，返回\texttt{true}
\end{block}
\end{block}

\begin{block}{删除总结}
\protect\phantomsection\label{ux5220ux9664ux603bux7ed3}
\begin{itemize}
\tightlist
\item
  节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回
  \texttt{false}
\item
  在每次调用后，检查返回值，如果是 \texttt{true}，则返回
  \texttt{true}，否则分5种情况进行处理
\end{itemize}
\end{block}

\begin{block}{私有的 \texttt{remove} 函数}
\protect\phantomsection\label{ux79c1ux6709ux7684-remove-ux51fdux6570}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}class KEY,class OTHER\textgreater{}}
\NormalTok{void AvlTree\textless{}KEY , OTHER\textgreater{}::remove(const KEY \&x , AvlNOde *\&x)}
\NormalTok{\{}
\NormalTok{  if (t = nullptr) // 被删除节点不存在}
\NormalTok{  \{}
\NormalTok{    return true;}
\NormalTok{  \}}
\NormalTok{  if (x == t{-}\textgreater{} data.key)}
\NormalTok{  \{}
\NormalTok{    if (t{-}\textgreater{}left == nullptr || t{-}\textgreater{} right == nullptr)}
\NormalTok{    \{}
\NormalTok{      AvlNode *oldNode = t;}
\NormalTok{      t = (t{-}\textgreater{}left == nullptr) ? t{-}\textgreater{}right : t{-}\textgreater{}left; // 删除节点的孩子节点}
\NormalTok{      delete oldNode;}
\NormalTok{      return false; // 删除了一个节点，返回 \textasciigrave{}false\textasciigrave{}}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      AvlNode *tmp = t{-}\textgreater{} right;}
\NormalTok{      while (tmp{-}\textgreater{}left != nullptr) // 找到右子树的最小节点}
\NormalTok{      \{}
\NormalTok{        tmp = tmp{-}\textgreater{}left;}
\NormalTok{      \}}
\NormalTok{      t{-}\textgreater{}data = tmp.data;}
\NormalTok{      if (remove(tmp{-}\textgreater{}data,key , t{-}\textgreater{}right))}
\NormalTok{      \{}
\NormalTok{        return adjust(t,1);}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  if (x \textless{} t{-}\textgreater{}data,key)}
\NormalTok{  \{}
\NormalTok{    if (remove(x,t{-}\textgreater{}left))}
\NormalTok{    \{}
\NormalTok{      teturn true;}
\NormalTok{    \}}
\NormalTok{    return adjust(t,0);}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    if (remove(x , t{-}\textgreater{}right))}
\NormalTok{    \{}
\NormalTok{      return true;}
\NormalTok{    \}}
\NormalTok{    return adjust(t,1);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{\texttt{adjust}}
\protect\phantomsection\label{adjust}
\begin{itemize}
\tightlist
\item
  进入调整函数的条件是某棵子树变矮了
\item
  调整函数需要检查节点是否失衡，若失衡则进行相应的调整
\item
  函数的返回值是子树是否变矮

  \begin{itemize}
  \tightlist
  \item
    \texttt{true}：子树没有变矮
  \item
    \texttt{false}：子树变矮
  \end{itemize}
\item
  需要传入两个参数

  \begin{itemize}
  \tightlist
  \item
    \texttt{AVlNode\ *\&t}：传入的节点
  \item
    \texttt{int\ subTree}：参数 \texttt{t} 变矮的子树

    \begin{itemize}
    \tightlist
    \item
      \texttt{0}：左子树
    \item
      \texttt{1}：右子树
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template\textless{}class KEY , classs OTHER\textgreater{}}
\NormalTok{bool AvlTree\textless{}KEY , OTHER\textgreater{}::adjust(AvlNode *\&t , int SubTree)}
\NormalTok{\{}
\NormalTok{  if (subTree) // 在右子树上删除}
\NormalTok{  \{}
\NormalTok{    if (height(t{-}\textgreater{}left) {-} height(t{-}\textgreater{}right) == 1) // Situation a}
\NormalTok{    \{}
\NormalTok{      return true;}
\NormalTok{    \}}
\NormalTok{    if (height(t{-}\textgreater{}right) == height(t{-}\textgreater{}left)) // Situation b}
\NormalTok{    \{}
\NormalTok{      return false;}
\NormalTok{    \}}
\NormalTok{    if (height(t{-}\textgreater{}left{-}\textgreater{}right) \textgreater{} height(t{-}\textgreater{}left{-}\textgreater{}left)) // Situation d}
\NormalTok{    \{}
\NormalTok{      LR(t);}
\NormalTok{      return false; }
\NormalTok{    \}}
\NormalTok{    LL(t); // Situation c and e}
\NormalTok{    if (height(t{-}\textgreater{}left) == height(t{-}\textgreater{}right))s}
\NormalTok{    \{}
\NormalTok{      return false;}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      return true;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  else // 在左子树上删除}
\NormalTok{  \{}
\NormalTok{    if (height(t{-}\textgreater{}right) {-} height(t{-}\textgreater{}left) == 1) // Situation a}
\NormalTok{    \{}
\NormalTok{      return true;}
\NormalTok{    \}}
\NormalTok{    if (height(t{-}\textgreater{}right) == height(t{-}\textgreater{}left)) // Situation b}
\NormalTok{    \{}
\NormalTok{      return false;}
\NormalTok{    \}s}
\NormalTok{    if (height(t{-}\textgreater{}right{-}\textgreater{}left) \textgreater{} height(t{-}\textgreater{}right{-}\textgreater{}right)) // Situation d}
\NormalTok{    \{}
\NormalTok{      RL(t);}
\NormalTok{      return false;}
\NormalTok{    \}}
\NormalTok{    RR(t); // Situation c and e}
\NormalTok{    if (height(t{-}\textgreater{}right) == height(t{-}\textgreater{}left))}
\NormalTok{    \{}
\NormalTok{      return false;}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      return true;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{散列表}
\protect\phantomsection\label{ux6563ux5217ux8868}
\begin{itemize}
\tightlist
\item
  也叫哈希表
\item
  通过所求节点的关键字词 \texttt{KEY} 找到这个节点
\item
  时间复杂度为 {}
\end{itemize}

\begin{block}{基本概念}
\protect\phantomsection\label{ux57faux672cux6982ux5ff5}
\begin{enumerate}
\tightlist
\item
  初始化\\
  将数组转化为一个特殊的、表示单元为空的值
\item
  \texttt{insert(i)}\strut \\
  将 \texttt{i} 存放到 \texttt{a{[}i.key{]}} 中
\item
  \texttt{find(i)}\strut \\
  取出 \texttt{a{[}i.key{]}} 中的值
\item
  \texttt{remove(i)}\strut \\
  将 \texttt{a{[}i.key{]}} 中的值置为空
\end{enumerate}
\end{block}

\begin{block}{散列函数}
\protect\phantomsection\label{ux6563ux5217ux51fdux6570}
将一个项映射成一个较小的下标的函数称为散列函数（hush function）

\begin{itemize}
\tightlist
\item
  {}\strut \\
  D为存储地址，key为关键值，H为散列函数
\item
  散列函数的要求

  \begin{itemize}
  \tightlist
  \item
    计算速度快
  \item
    散列地址均匀分布
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{常用的散列函数}
\protect\phantomsection\label{ux5e38ux7528ux7684ux6563ux5217ux51fdux6570}
\begin{block}{直接地址法}
\protect\phantomsection\label{ux76f4ux63a5ux5730ux5740ux6cd5}
{} 或 {}
\end{block}

\begin{block}{\textbf{除留余数法}}
\protect\phantomsection\label{ux9664ux7559ux4f59ux6570ux6cd5}
{} 或 {} 这里的 {} 是一个小于等于 {} 的素数
\end{block}

\begin{block}{数字分析法}
\protect\phantomsection\label{ux6570ux5b57ux5206ux6790ux6cd5}
对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分
\end{block}

\begin{block}{平方取中法}
\protect\phantomsection\label{ux5e73ux65b9ux53d6ux4e2dux6cd5}
如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字\textbf{平方后}，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。
\end{block}

\begin{block}{折叠法}
\protect\phantomsection\label{ux6298ux53e0ux6cd5}
\begin{itemize}
\tightlist
\item
  如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法
\item
  选取一个长度后，将关键字按此长度分组相加
\end{itemize}
\end{block}
\end{block}

\begin{block}{冲突问题}
\protect\phantomsection\label{ux51b2ux7a81ux95eeux9898}
当两个以上的关键字映射到一个存储单元时，称为\textbf{冲突或碰撞}

\begin{itemize}
\tightlist
\item
  解决冲突的方法

  \begin{itemize}
  \tightlist
  \item
    闭散列表：利用本散列表中的空余单元

    \begin{itemize}
    \tightlist
    \item
      线性探测法
    \item
      二次探测法
    \item
      再次散列法
    \end{itemize}
  \item
    开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）
  \end{itemize}
\end{itemize}

\begin{block}{闭散列表类的实现}
\protect\phantomsection\label{ux95edux6563ux5217ux8868ux7c7bux7684ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  支持三种操作

  \begin{itemize}
  \tightlist
  \item
    \texttt{insert}：插入一个元素
  \item
    \texttt{remove}：删除一个元素
  \item
    \texttt{find}：查找一个元素
  \end{itemize}
\item
  由一个数组实现，数组的大小由用户定义散列表时指定
\item
  由于删除时的迟删除，每个数组元素还要保存一个状态值

  \begin{itemize}
  \tightlist
  \item
    \texttt{0}：空
  \item
    \texttt{1}：有效
  \item
    \texttt{2}：删除
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{class closeHashTable:public dynamicSearchTable\textless{}KEY, OTHER\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    struct node  //散列表的结点类}
\NormalTok{    \{ }
\NormalTok{      SET \textless{}KEY, OTHER\textgreater{} data;}
\NormalTok{      int state; //0 {-}{-} empty 1 {-}{-} active 2 {-}{-} deleted}
\NormalTok{      node()}
\NormalTok{      \{}
\NormalTok{        state = 0;}
\NormalTok{      \}}
\NormalTok{    \};}
\NormalTok{    node *array;}
  
\NormalTok{    int size;}
\NormalTok{    int (*key)(const KEY \&x);//哈希函数}
\NormalTok{    static int defaultKey(const int \&x)}
\NormalTok{    \{}
\NormalTok{      return x;}
\NormalTok{    \}}
\NormalTok{  public:}
\NormalTok{    closeHashTable(int length = 101, int (*f)(const KEY \&x) = defaultKey)}
\NormalTok{    \textasciitilde{}closeHashTable()}
\NormalTok{    \{}
\NormalTok{      delete [] array;}
\NormalTok{    \}}
\NormalTok{    SET\textless{}KEY, OTHER\textgreater{} *find(const KEY \&x) const;}
\NormalTok{    void insert(const SET\textless{}KEY, OTHER\textgreater{} \&x);}
\NormalTok{    void remove(const KEY \&x);}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  构造函数
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{closeHashTable\textless{}KEY, OTHER\textgreater{}::closeHashTable(int length, int (*f)(const KEY \&x))}
\NormalTok{\{}
\NormalTok{  size = length;}
\NormalTok{  array = new node[size];}
\NormalTok{  key = f; //哈希函数为f}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{insert}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void closeHashTable\textless{}KEY, OTHER\textgreater{}::insert(const SET\textless{}KEY, OTHER\textgreater{} \&x)}
\NormalTok{\{}
\NormalTok{  int initPos, pos ;}
\NormalTok{  initPos= pos = key(x.key) \% size; //\%size保护作用，避免越界}
\NormalTok{  do}
\NormalTok{  \{}
\NormalTok{    if (array[pos].state != 1)}
\NormalTok{    \{ // 0或2，找到空单元}
\NormalTok{      array[pos].data = x;}
\NormalTok{      array[pos].state = 1;}
\NormalTok{      return;}
\NormalTok{    \}}
\NormalTok{    pos = (pos+1) \% size;}
\NormalTok{  \} while (pos != initPos);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{remove}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void closeHashTable\textless{}KEY, OTHER\textgreater{}::remove(const KEY \&x)}
\NormalTok{\{}
\NormalTok{  int initPos, pos ;}
\NormalTok{  initPos= pos = key(x) \% size;}
\NormalTok{  do}
\NormalTok{  \{}
\NormalTok{    if (array[pos].state == 0) return; //没找到}
\NormalTok{    if (array[pos].state == 1 \&\& array[pos].data.key== x)// 找到，删除}
\NormalTok{    \{}
\NormalTok{      array[pos].state = 2;}
\NormalTok{      return;}
\NormalTok{    \}}
\NormalTok{    pos = (pos+1) \% size; //没找到，需要往后找}
\NormalTok{  \} while (pos != initPos);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{find}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{SET\textless{}KEY, OTHER\textgreater{} *closeHashTable\textless{}KEY, OTHER\textgreater{}::find(const KEY \&x) const}
\NormalTok{\{}
\NormalTok{  int initPos, pos ;}
\NormalTok{  initPos = pos = key(x) \% size;}
\NormalTok{  do}
\NormalTok{  \{}
\NormalTok{    if (array[pos].state == 0) // 没有找到}
\NormalTok{    \{}
\NormalTok{      return nullptr;}
\NormalTok{    \}}
\NormalTok{    if (array[pos].state == 1 \&\& array[pos].data.key == x) // 找到}
\NormalTok{    \{}
\NormalTok{      return (SET\textless{}KEY,OTHER\textgreater{} *)\&array[pos];}
\NormalTok{    \}}
\NormalTok{    pos = (pos+1) \% size;}
\NormalTok{  \} while (pos != initPos);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{block}{线性探测法}
\protect\phantomsection\label{ux7ebfux6027ux63a2ux6d4bux6cd5}
当散列发生冲突时，依次\textbf{探测下一个单元}，直到发现一个空单元

\end{block}

\begin{block}{二次探测法}
\protect\phantomsection\label{ux4e8cux6b21ux63a2ux6d4bux6cd5}
以此向后探测 {}，{}，{}，{}，{}，{}

\textbf{定理}

\begin{itemize}
\tightlist
\item
  如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子
  {}），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次
\end{itemize}
\end{block}

\begin{block}{再次散列法}
\protect\phantomsection\label{ux518dux6b21ux6563ux5217ux6cd5}
\begin{itemize}
\tightlist
\item
  采用一个新的散列函数 {}
\item
  {}，{} ，{}，{}，{}
\end{itemize}
\end{block}
\end{block}

\begin{block}{开散列表}
\protect\phantomsection\label{ux5f00ux6563ux5217ux8868}
链地址法

\begin{itemize}
\tightlist
\item
  将具有同一散列地址的结点保存于 \texttt{M} 存区的各自的链表之中
\end{itemize}

\begin{block}{开散列表的实现}
\protect\phantomsection\label{ux5f00ux6563ux5217ux8868ux7684ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  将所有散列到同一地址的元素链接成一个单链表
\item
  采用不带头结点的单链表
\item
  散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY , class OTHER\textgreater{}}
\NormalTok{class openHashTable:public dynamicSearchTable\textless{}KEU , OTHER\textgreater{}}
\NormalTok{\{}
\NormalTok{  private:}
\NormalTok{    struct node}
\NormalTok{    \{}
\NormalTok{      SET\textless{}KEY , OTHER\textgreater{} data;}
\NormalTok{      node *next;}
\NormalTok{      node (const SET\textless{}KEY , OTHER\textgreater{} \&d , nde *n = nullptr)}
\NormalTok{      \{}
\NormalTok{        data = d;}
\NormalTok{        next = n;}
\NormalTok{      \}}
\NormalTok{      node()}
\NormalTok{      \{}
\NormalTok{        next = nullptr;}
\NormalTok{      \}}
\NormalTok{    \};}
\NormalTok{    node **array; // 散列表，指针数组}
\NormalTok{     int size;}
\NormalTok{     static int defaultKry(const int \&x)}
\NormalTok{     \{}
\NormalTok{        return x;}
\NormalTok{     \}}
\NormalTok{  public:}
\NormalTok{    openHashTable(int length = 101,int (*f)(const KEY \&x) = defaultKey);}
\NormalTok{    \textasciitilde{}openashTable();}
\NormalTok{    SET\textless{}KEY,OTHER\textgreater{} *finf(const KEY \&x) const;}
\NormalTok{    void insert(const SET\textless{}KEY,OTHER\textgreater{} \&x);}
\NormalTok{    void remove(const KEY \&x);}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  构造函数
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{openHashTable\textless{}KEY, OTHER\textgreater{}::\textasciitilde{}openHashTable()}
\NormalTok{\{}
\NormalTok{  node *p, *q;}
\NormalTok{  for (int i = 0; i\textless{} size; ++i)}
\NormalTok{  \{ }
\NormalTok{    p = array[i];}
\NormalTok{    while (p!=nullptr)}
\NormalTok{    \{ }
\NormalTok{      q= p{-}\textgreater{}next; delete p; p = q;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  delete [] array；}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{insert}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void openHashTable\textless{}KEY, OTHER\textgreater{}::insert(const SET\textless{}KEY, OTHER\textgreater{} \&x)}
\NormalTok{\{}
\NormalTok{  int pos;}
\NormalTok{  node *p;}
\NormalTok{  //插入单链表的头部}
\NormalTok{  pos = key(x.key) \% size;}
\NormalTok{  array[pos] = new node(x, array[pos]);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{remove}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void openHashTable\textless{}KEY, OTHER\textgreater{}::remove(const KEY \&x)}
\NormalTok{\{}
\NormalTok{  int pos ;}
\NormalTok{  node *p, *q;}
\NormalTok{  pos = key(x) \% size;}
\NormalTok{  if (array[pos] == nullptr)}
\NormalTok{  \{}
\NormalTok{    return;}
\NormalTok{  \}}
\NormalTok{  p = array[pos];}
\NormalTok{  if (array[pos]{-}\textgreater{}data.key== x)}
\NormalTok{  \{ // 删除第一个结点}
\NormalTok{    array[pos] = p{-}\textgreater{}next;}
\NormalTok{    delete p;}
\NormalTok{    return;}
\NormalTok{  \}}
\NormalTok{  while (p{-}\textgreater{}next != nullptr \&\& !(p{-}\textgreater{}next{-}\textgreater{}data.key== x))}
\NormalTok{  \{}
\NormalTok{    p = p{-}\textgreater{}next;}
\NormalTok{  \}}
\NormalTok{  if (p{-}\textgreater{}next != nullptr)}
\NormalTok{  \{}
\NormalTok{    q = p{-}\textgreater{}next;}
\NormalTok{    p{-}\textgreater{}next = q{-}\textgreater{}next;}
\NormalTok{    delete q;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{find}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{SET\textless{}KEY, OTHER\textgreater{} *openHashTable\textless{}KEY, OTHER\textgreater{}::find(const KEY \&x) const}
\NormalTok{\{}
\NormalTok{  int pos ;}
\NormalTok{  node *p;}
\NormalTok{  pos = key(x) \% size;}
\NormalTok{  p = array[pos];}
\NormalTok{  while (p != nullptr \&\& !(p{-}\textgreater{}data.key == x))}
\NormalTok{  \{}
\NormalTok{    p = p{-}\textgreater{}next;}
\NormalTok{  \}}
\NormalTok{  if (p == nullptr)}
\NormalTok{  \{}
\NormalTok{    return nullptr;}
\NormalTok{  \}}
\NormalTok{  else}
\NormalTok{  \{}
\NormalTok{    return (SET\textless{}KEY, OTHER\textgreater{} *)p;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}
\end{block}
\end{block}

\begin{block}{排序}
\protect\phantomsection\label{ux6392ux5e8f}
\begin{block}{基本概念}
\protect\phantomsection\label{ux57faux672cux6982ux5ff5-1}
\begin{itemize}
\tightlist
\item
  按照关键字的非递减或非递增序排成一个序列
\item
  \textbf{稳定与非稳定排序}:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序
\item
  内排序与外排序

  \begin{itemize}
  \tightlist
  \item
    \textbf{内排序：}排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置
  \item
    \textbf{外排序：}在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{插入排序}
\protect\phantomsection\label{ux63d2ux5165ux6392ux5e8f}
首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的n-1个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的

\begin{block}{直接插入排序}
\protect\phantomsection\label{ux76f4ux63a5ux63d2ux5165ux6392ux5e8f}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void simpleInsertSort(SET\textless{}KEY, OTHER\textgreater{}a[], int size)}
\NormalTok{\{}
\NormalTok{  int k;}
\NormalTok{  SET\textless{}KEY, OTHER\textgreater{} tmp;}
\NormalTok{  for (int j=1; j\textless{}size; ++j)}
\NormalTok{  \{}
\NormalTok{  tmp = a[j];}
\NormalTok{  for ( k = j{-}1; tmp.key \textless{} a[k].key \&\& k \textgreater{}= 0; {-}{-}k)}
\NormalTok{  \{}
\NormalTok{    a[k+1] = a[k];}
\NormalTok{  \}}
\NormalTok{  a[k+1] = tmp;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  空间复杂度：{}
\item
  稳定性：稳定
\item
  时间复杂度

  \begin{itemize}
  \tightlist
  \item
    最好：{}
  \item
    最坏：{}
  \item
    平均：{}
  \end{itemize}
\item
  适用情况：短序列或者几乎已经排好序的
\end{itemize}
\end{block}

\begin{block}{折半插入排序}
\protect\phantomsection\label{ux6298ux534aux63d2ux5165ux6392ux5e8f}
先用二分排序找到插入位置

\begin{itemize}
\tightlist
\item
  时间复杂度

  \begin{itemize}
  \tightlist
  \item
    最好：{}
  \item
    最坏：{}
  \item
    平均：{}
  \end{itemize}
\item
  空间复杂度：{}
\item
  稳定性：稳定
\end{itemize}

改进很小，对于接近排好序的序列甚至\textbf{更差}
\end{block}

\begin{block}{希尔排序}
\protect\phantomsection\label{ux5e0cux5c14ux6392ux5e8f}
\begin{itemize}
\tightlist
\item
  相隔一定的距离的记录组成一个子序列
\item
  逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态
\item
  最后再用直接插入排序对整个序列进行一次排序
\end{itemize}

\begin{block}{步长序列的选择}
\protect\phantomsection\label{ux6b65ux957fux5e8fux5217ux7684ux9009ux62e9}
\begin{itemize}
\item
  {}
\item
  时间复杂度：{}
\item
  Knuth推荐：{}
\item
  时间复杂度：{}
\item
  空间复杂度：{}
\item
  不稳定
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void shellSort(SET\textless{}KEY, OTHER\textgreater{} a[], int size)}
\NormalTok{\{}
\NormalTok{  int step, i, j;}
\NormalTok{  SET\textless{}KEY, OTHER\textgreater{} tmp;}
\NormalTok{  for (step = size/2; step \textgreater{} 0; step /= 2) //step为希尔增量}
\NormalTok{  \{}
\NormalTok{    for (i = step; i \textless{} size; ++i)}
\NormalTok{    \{}
\NormalTok{      tmp = a[i];}
\NormalTok{      for (j = i {-}step; j \textgreater{}= 0 \&\& a[j].key \textgreater{} tmp.key; j {-}= step)}
\NormalTok{      \{}
\NormalTok{        a[j+step] = a[j];}
\NormalTok{      \}}
\NormalTok{      a[j+step] = tmp;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}

\begin{block}{选择排序}
\protect\phantomsection\label{ux9009ux62e9ux6392ux5e8f}
\begin{enumerate}
\tightlist
\item
  在 {} 个元素中选出最小的元素
\item
  从剩下的 {} 个元素中选出最小的元素
\item
  以此类推，直到最后一个元素
\end{enumerate}

\begin{block}{直接选择排序}
\protect\phantomsection\label{ux76f4ux63a5ux9009ux62e9ux6392ux5e8f}
\begin{enumerate}
\tightlist
\item
  在所有元素中逐个比较找到最小元素，与第一个元素交换
\item
  在剩下的元素中逐个比较找到最小元素，与第二个元素交换
\item
  以此类推，直到最后一个元素
\end{enumerate}

\begin{itemize}
\tightlist
\item
  时间复杂度：{}
\item
  空间复杂度：{}
\item
  不稳定
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void simpleSelectSort(SET\textless{}KEY, OTHER\textgreater{} a[], int size)}
\NormalTok{\{}
\NormalTok{  int i, j, min;}
\NormalTok{  SET\textless{}KEY, OTHER\textgreater{} tmp;}
\NormalTok{  for (i = 0; i \textless{} size {-}1; ++i)}
\NormalTok{  \{}
\NormalTok{  min = i;}
\NormalTok{  for (j = i+1; j \textless{} size; ++j)}
\NormalTok{  \{}
\NormalTok{    if (a[j].key \textless{} a[min].key)}
\NormalTok{    \{}
\NormalTok{      min = j;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  tmp = a[i]; a[i] = a[min]; a[min] = tmp;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{堆排序}
\protect\phantomsection\label{ux5806ux6392ux5e8f}
\begin{enumerate}
\tightlist
\item
  建立一个最大堆
\item
  执行 {} 次 \texttt{deQuqeue} 操作取出每个项
\end{enumerate}

\begin{itemize}
\item
  时间复杂度 {}
\item
  堆排序
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void heapSort(SET\textless{}KEY, OTHER\textgreater{} a[], int size)}
\NormalTok{\{}
\NormalTok{  int i;}
\NormalTok{  SET\textless{}KEY, OTHER\textgreater{} tmp; // 创建初始的堆}
\NormalTok{  for( i = size / 2 {-}1; i \textgreater{}= 0; i{-}{-})}
\NormalTok{  \{}
\NormalTok{    percolateDown( a, i, size );}
\NormalTok{  \}}
\NormalTok{  //执行n{-}1次deQueue}
\NormalTok{  for ( i = size {-}1; i \textgreater{} 0; {-}{-}i)\textbackslash{}}
\NormalTok{  \{}
\NormalTok{  tmp = a[0]; a[0] = a[i]; a[i] = tmp; //delete a[0]}
\NormalTok{  percolateDown( a, 0, i );}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{precolateDown}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void percolateDown( SET\textless{}KEY, OTHER\textgreater{} a[], int hole, int size)}
\NormalTok{\{}
\NormalTok{  int child;}
\NormalTok{  SET\textless{}KEY, OTHER\textgreater{} tmp= a[ hole ];}
\NormalTok{  for( ; hole * 2 + 1 \textless{} size; hole = child )}
\NormalTok{  \{}
\NormalTok{    child = hole * 2 + 1;}
\NormalTok{    if( child != size {-}1 \&\& a[ child + 1 ].key \textgreater{} a[ child ].key )}
\NormalTok{    \{}
\NormalTok{      child++;}
\NormalTok{    \}}
\NormalTok{    if( a[ child ].key \textgreater{}tmp.key)}
\NormalTok{    \{}
\NormalTok{      a[ hole ] = a[ child ];}
\NormalTok{    \}}
\NormalTok{    else}
\NormalTok{    \{}
\NormalTok{      break;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  a[ hole ] = tmp;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{交换排序}
\protect\phantomsection\label{ux4ea4ux6362ux6392ux5e8f}
通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动

\begin{block}{冒泡排序}
\protect\phantomsection\label{ux5192ux6ce1ux6392ux5e8f}
从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡

然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置

依次类推，经过第 {} 趟起泡，将倒数第 {} 个大的元素放入第2个单元

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{void bubbleSort(SET\textless{}KEY, OTHER\textgreater{} a[], int size)}
\NormalTok{\{}
\NormalTok{  int i, j;}
\NormalTok{  SET\textless{}KEY, OTHER\textgreater{} tmp;}
\NormalTok{  bool flag = true; //记录一趟起泡中有没有发生过交换}
\NormalTok{  for (i = 1; i \textless{} size\&\& flag; ++i)}
\NormalTok{  \{ //size{-}1次起泡}
\NormalTok{    flag = false;}
\NormalTok{    for (j = 0; j \textless{} size{-}i; ++j) //第i次起泡}
\NormalTok{    if (a[j+1].key \textless{} a[j].key)}
\NormalTok{    \{}
\NormalTok{      tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp;}
\NormalTok{      flag = true;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{快速排序}
\protect\phantomsection\label{ux5febux901fux6392ux5e8f}
\begin{itemize}
\tightlist
\item
  选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边
\item
  然后对基准元素左边和右边的子序列进行递归排序
\end{itemize}

\begin{block}{选择中心点}
\protect\phantomsection\label{ux9009ux62e9ux4e2dux5fc3ux70b9}
\begin{itemize}
\tightlist
\item
  第一个元素
\item
  随机
\item
  中值（采样得到）
\end{itemize}
\end{block}

\begin{block}{划分（第一个元素为中心点）}
\protect\phantomsection\label{ux5212ux5206ux7b2cux4e00ux4e2aux5143ux7d20ux4e3aux4e2dux5fc3ux70b9}
\begin{enumerate}
\tightlist
\item
  序列的下标上界为 \texttt{high}，下届为
  \texttt{low}，中心点选取第一个元素，关键值为 \texttt{K}，\texttt{low}
  位置空出
\item
  从右向左开始检查：如果 \texttt{high} 的关键值大于
  \texttt{K}，该位置中的值位置正确，\texttt{high} 减
  {}，继续往前检查，直到遇到一个小于 \texttt{K} 的值
\item
  将小于 \texttt{k} 的这个值放入 \texttt{low} 的位置，此时 \texttt{high}
  的位置又空出。然后从 \texttt{low}
  位置开始从左向右检查，直到遇到一个大于 \texttt{K} 的值
\item
  将 \texttt{low} 位置的值放入 \texttt{high} 位置，重复第2步，直到
  \texttt{low} 和 \texttt{high} 重叠，将 \texttt{K} 放入此位置
\end{enumerate}

划分函数的实现

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class KEY, class OTHER\textgreater{}}
\NormalTok{int divide( SET\textless{}KEY, OTHER\textgreater{} a[], int low, int high)}
\NormalTok{\{}
\NormalTok{  SET\textless{}KEY, OTHER\textgreater{} k = a[low];}
\NormalTok{  do}
\NormalTok{  \{}
\NormalTok{    while (low \textless{} high \&\& a[high].key \textgreater{}= k.key)}
\NormalTok{    \{}
\NormalTok{      {-}{-}high;}
\NormalTok{    \}}
\NormalTok{    if (low \textless{} high)}
\NormalTok{    \{}
\NormalTok{      a[low] = a[high]; ++low;}
\NormalTok{    \}}
\NormalTok{    while (low \textless{} high \&\& a[low].key \textless{}= k.key)}
\NormalTok{    \{}
\NormalTok{      ++low;}
\NormalTok{    \}}
\NormalTok{    if (low \textless{} high)}
\NormalTok{    \{}
\NormalTok{      a[high] = a[low]; {-}{-}high;}
\NormalTok{    \}}
\NormalTok{  \} while (low != high);}
\NormalTok{  a[low] = k;}
\NormalTok{  return low;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}

\begin{block}{归并排序}
\protect\phantomsection\label{ux5f52ux5e76ux6392ux5e8f}
\begin{itemize}
\tightlist
\item
  将待排序的序列分成两个子序列，分别进行排序
\item
  将两个有序的子序列合并成一个有序的序列
\item
  递归进行
\end{itemize}
\end{block}

\begin{block}{基数排序}
\protect\phantomsection\label{ux57faux6570ux6392ux5e8f}
\begin{itemize}
\tightlist
\item
  称为口袋排序法
\item
  通过分配的方法进行排序
\item
  基数（r）：子关键字的值域的元素的个数

  \begin{itemize}
  \tightlist
  \item
    十进制数：{}，基数为 {}
  \item
    二进制数：{}，基数为 {}
  \item
    英文字符：{}，基数为 {}
  \end{itemize}
\end{itemize}

\begin{block}{高位优先法（MSD）}
\protect\phantomsection\label{ux9ad8ux4f4dux4f18ux5148ux6cd5msd}
\begin{itemize}
\tightlist
\item
  先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列
\end{itemize}
\end{block}

\begin{block}{低位优先法（LSD）}
\protect\phantomsection\label{ux4f4eux4f4dux4f18ux5148ux6cd5lsd}
\begin{itemize}
\tightlist
\item
  先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起
\item
  然后将次低位进入口袋进行排序，依次类推
\item
  最后将所有记录按照口袋的顺序收在一起
\end{itemize}
\end{block}
\end{block}
\end{block}

\begin{block}{外存储器中的查找和排序}
\protect\phantomsection\label{ux5916ux5b58ux50a8ux5668ux4e2dux7684ux67e5ux627eux548cux6392ux5e8f}
\begin{block}{主存储器与外存储器}
\protect\phantomsection\label{ux4e3bux5b58ux50a8ux5668ux4e0eux5916ux5b58ux50a8ux5668}
\begin{itemize}
\tightlist
\item
  主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据
\item
  外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息

  \begin{itemize}
  \tightlist
  \item
    价格低廉、存储量大、永久保存、\textbf{访问速度慢}
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{外部查找}
\protect\phantomsection\label{ux5916ux90e8ux67e5ux627e}
\begin{block}{B树}
\protect\phantomsection\label{bux6811}
B树是一棵平衡的M叉查找树，需要 {} 个关键字来判断到哪个分支查找

\begin{block}{B树的定义}
\protect\phantomsection\label{bux6811ux7684ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  一棵 {} 阶B树要么为空，要么满足一下条件

  \begin{itemize}
  \tightlist
  \item
    根节点要么是叶节点，要么至少有两个儿子，至多有 {} 个儿子
  \item
    每个非根节点至少有 {} 个儿子，至多有 {} 个儿子
  \item
    有 {} 个儿子的非叶节点具有 {} 个关键字
  \item
    所有的叶子节点都出现在同一层上
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{B树的插入}
\protect\phantomsection\label{bux6811ux7684ux63d2ux5165}
\begin{itemize}
\tightlist
\item
  在最底层进行插入
\end{itemize}

\begin{enumerate}
\tightlist
\item
  在 {} 阶B树上进行查找操作，确定新插入的关键字 \texttt{key}
  在最底层非叶节点的插入位置
\item
  如果被插入节点的关键字个数小于等于 {}，则插入结束
\item
  如果被插入节点的关键字个数大于 {}，则需要进行分裂
\end{enumerate}

\begin{itemize}
\tightlist
\item
  被插入节点分为三个部分

  \begin{itemize}
  \tightlist
  \item
    前半部分：前 {} 个关键字
  \item
    中间部分：中间的关键字
  \item
    后半部分：后 {} 个关键字
  \end{itemize}
\item
  中间部分的关键字上升到父节点
\item
  前后半部分生成新的两个节点
\end{itemize}
\end{block}

\begin{block}{B树的删除}
\protect\phantomsection\label{bux6811ux7684ux5220ux9664}
\begin{itemize}
\tightlist
\item
  采用替身法，替身为右子树的最小值或者左子树的最大值
\end{itemize}

\begin{enumerate}
\tightlist
\item
  删除节点，替身进入
\item
  如果删除后的替身原来在的节点满足，则直接删除
\item
  如果删除后的关键字小于下限，

  \begin{itemize}
  \tightlist
  \item
    向该节点的左或右兄弟借一个关键字
  \item
    如果兄弟节点的关键字个数等于下限，则需要进行合并
  \end{itemize}
\end{enumerate}
\end{block}

\begin{block}{M的选择}
\protect\phantomsection\label{mux7684ux9009ux62e9}
\end{block}
\end{block}

\begin{block}{B+树}
\protect\phantomsection\label{bux6811-1}
B+树是既能提供随机查找，也能提供顺序访问的存储结构

\begin{block}{B+树的定义}
\protect\phantomsection\label{bux6811ux7684ux5b9aux4e49-1}
\begin{itemize}
\tightlist
\item
  所有数据都记录在叶节点中，所有叶节点连成一个单链表
\item
  非叶节点至多保存 {} 个关键字来引导查找，键 {} 表示子树 {} 中键的最小值
\item
  根节点或者是叶节点，或者有 {} 到 {} 个子树
\item
  除了根节点之外的所有非叶节点至少有 {} 个儿子，最多有 {} 个儿子
\item
  所有的叶节点都在同一层上，并且每个叶子有 {} 到 {} 个关键字
\end{itemize}
\end{block}

\begin{block}{B+树的插入}
\protect\phantomsection\label{bux6811ux7684ux63d2ux5165-1}
\begin{itemize}
\tightlist
\item
  叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序
\item
  叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项

  \begin{itemize}
  \tightlist
  \item
    更新父结点
  \item
    如果父亲的儿子数量已经满了，就继续分裂父亲
  \end{itemize}
\end{itemize}
\end{block}
\end{block}
\end{block}

\begin{block}{外排序}
\protect\phantomsection\label{ux5916ux6392ux5e8f}
一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O操作）

\begin{block}{外排序模型}
\protect\phantomsection\label{ux5916ux6392ux5e8fux6a21ux578b}
\begin{itemize}
\tightlist
\item
  外排序由两个阶段组成

  \begin{enumerate}
  \tightlist
  \item
    预处理阶段：根据内存的大小将一个有n个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段
  \item
    归并阶段：将这些有序片段逐步归并成一个有序文件
  \end{enumerate}
\end{itemize}

减少 I/O 操作的关键

\begin{enumerate}
\tightlist
\item
  减少归并轮数
\item
  减少有序片段数量
\item
  增加合并路数
\end{enumerate}
\end{block}

\begin{block}{预处理}
\protect\phantomsection\label{ux9884ux5904ux7406}
\begin{block}{减少有序片段数量}
\protect\phantomsection\label{ux51cfux5c11ux6709ux5e8fux7247ux6bb5ux6570ux91cf}
\begin{itemize}
\tightlist
\item
  每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少
\item
  最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段
\end{itemize}
\end{block}

\begin{block}{置换排序}
\protect\phantomsection\label{ux7f6eux6362ux6392ux5e8f}
置换选择可以在只能容纳 {} 个记录的内存中生成平均长度为 {}
的初始的已排序片段

只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段

具体方法

\begin{enumerate}
\tightlist
\item
  初始时，将 {} 个元素读入内存，用 \texttt{buildHeap} 建立一个优先级队列
\item
  执行一次 \texttt{deQuqeue}，将最小的元素写入输出文件
\item
  从输入磁带读入下一个元素

  \begin{itemize}
  \tightlist
  \item
    如果它比刚才写进去的元素大，那么将它加入到优先级队列中
  \item
    否则，则无法写入队列，进行下一次 \texttt{deQuqeue}
  \end{itemize}
\item
  重复第2、3步，直到输入文件读完
\item
  重新执行 \texttt{buildHeap}，使用存放在空余位置中的元素
\end{enumerate}
\end{block}
\end{block}

\begin{block}{归并}
\protect\phantomsection\label{ux5f52ux5e76}
\begin{block}{二路归并}
\protect\phantomsection\label{ux4e8cux8defux5f52ux5e76}
\begin{itemize}
\tightlist
\item
  归并时，每次将两个有序文件归并为一个有序文件
\item
  如果生成的有序片段数量为 {}，则归并次数为 {}
\end{itemize}
\end{block}

\begin{block}{多路归并}
\protect\phantomsection\label{ux591aux8defux5f52ux5e76}
\begin{itemize}
\tightlist
\item
  归并时，每次将 {} 个有序文件归并为一个有序文件
\item
  优点：减少归并次数，为 {} 次
\item
  缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列
\end{itemize}
\end{block}

\begin{block}{多阶段归并}
\protect\phantomsection\label{ux591aux9636ux6bb5ux5f52ux5e76}
\begin{itemize}
\tightlist
\item
  可以仅使用 {} 条磁带实现 {} 路归并，称为\textbf{多阶段归并}
\end{itemize}

\textbf{实现的过程}

\begin{enumerate}
\tightlist
\item
  按照非均匀的方法分解原来的已排序的片段
\item
  将每个片段分成 {} 个子片段
\end{enumerate}
\end{block}
\end{block}
\end{block}
\end{block}

\begin{block}{图}
\protect\phantomsection\label{ux56fe}
\begin{block}{图的定义}
\protect\phantomsection\label{ux56feux7684ux5b9aux4e49}
\begin{itemize}
\tightlist
\item
  图可以用 {} 表示。其中，{} 是顶点集，{} 是边集。
\item
  如果边是有方向的，称为\textbf{有向图}.有向图的边用 {} 表示

  \begin{itemize}
  \tightlist
  \item
    {} 表示从 {} 到 {} 的一条边
  \end{itemize}
\item
  如果边是无方向的，称为\textbf{无向图}.无向图的边用 {} 表示

  \begin{itemize}
  \tightlist
  \item
    {} 表示 {} 和 {} 之间有一条边
  \item
    无向图也称为双向图
  \end{itemize}
\item
  \textbf{加权图：}
  边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图

  \begin{itemize}
  \tightlist
  \item
    加权图中边的表示：{}
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{图的基本术语}
\protect\phantomsection\label{ux56feux7684ux57faux672cux672fux8bed}
\begin{itemize}
\tightlist
\item
  邻接

  \begin{itemize}
  \tightlist
  \item
    若 {} 是图 {} 的一条边，则称 {} 和 {} 是邻接的；若 {} 是图 {}
    的一条边，则称 {} 邻接到 {}，{} 和 {} 邻接
  \end{itemize}
\item
  度\\
  无向图中邻接与某一顶点的边的总数
\item
  入度\\
  有向图中进入某一顶点的边数
\item
  出度\\
  有向图中离开某一顶点的边数
\item
  边与度的关系\\
  {}，其中 {} 是边数，{} 是顶点 {} 的度
\end{itemize}

\begin{block}{子图}
\protect\phantomsection\label{ux5b50ux56fe}
设有两个图 {} 和 {}，如果 {}，{}，则称 {} 是 {} 的子图
\end{block}

\begin{block}{路径和路径长度}
\protect\phantomsection\label{ux8defux5f84ux548cux8defux5f84ux957fux5ea6}
\begin{itemize}
\tightlist
\item
  对于 {}，顶点序列 {} 中的顶点对 {} 都有 {} 或 {}，则称 {}
  是图中的一条\textbf{路径}
\item
  \textbf{非加权的路径长度}就是组成路径的边数，对于路径 {}，路径长度为
  {}
\item
  \textbf{加权的路径长度}是指路径上所有边的权值之和
\item
  \textbf{简单路径和环：}
  如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为
  {}
\end{itemize}
\end{block}

\begin{block}{无向图的连通性}
\protect\phantomsection\label{ux65e0ux5411ux56feux7684ux8fdeux901aux6027}
\begin{itemize}
\tightlist
\item
  \textbf{连通：} 顶点 {} 和顶点 {} 之间又路径存在
\item
  \textbf{连通图：} 无向图 G 的任意两点之间都是连通的
\item
  \textbf{连通分量：} 非连通图中的极大连通子图
\end{itemize}
\end{block}

\begin{block}{有向图的连通性}
\protect\phantomsection\label{ux6709ux5411ux56feux7684ux8fdeux901aux6027}
\begin{itemize}
\tightlist
\item
  \textbf{强连通图：} 有向图 G 的任意两点之间都是连通的，则称 G
  是强连通图
\item
  \textbf{强连通分量：} 极大连通子图
\item
  \textbf{弱连通图：} 如有向图 G
  不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的
\end{itemize}
\end{block}

\begin{block}{完全图}
\protect\phantomsection\label{ux5b8cux5168ux56fe}
\begin{itemize}
\tightlist
\item
  \textbf{完全图：} 每两个顶点之间都有边的无向图称为完全图。完全图有 {}
  条边，即 {}
\item
  \textbf{有向完全图：}
  每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 {}
  条边，即 {}
\item
  \textbf{有向无环图：} 不含环的有向图
\end{itemize}
\end{block}

\begin{block}{生成树与最小生成树}
\protect\phantomsection\label{ux751fux6210ux6811ux4e0eux6700ux5c0fux751fux6210ux6811}
\begin{itemize}
\tightlist
\item
  \textbf{生成树}是图 G 的\textbf{极小}连通子图 G\textquotesingle，其中
  {}
\item
  用一棵树把图 G 的所有顶点都连起来，并且没有回路
\item
  生成树有 {} 个顶点，{} 条边
\item
  生成树可以有多个
\item
  \textbf{最小生成树}是所有生成树中权值之和最小的生成树
\end{itemize}
\end{block}
\end{block}

\begin{block}{图的运算}
\protect\phantomsection\label{ux56feux7684ux8fd0ux7b97}
\begin{itemize}
\tightlist
\item
  常规操作

  \begin{itemize}
  \tightlist
  \item
    构造一个由若干个顶点、若干条边组成的图
  \item
    判断两个顶点之间是否有边存在
  \item
    在图中添加或删除一条边
  \item
    返回图中的顶点数或边数
  \item
    按某种规则\textbf{遍历}图中的所有顶点
  \end{itemize}
\item
  和应用紧密结合的运算

  \begin{itemize}
  \tightlist
  \item
    拓扑排序和关键路径
  \item
    找最小生成树
  \item
    找最短路径等
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{图的抽象类}
\protect\phantomsection\label{ux56feux7684ux62bdux8c61ux7c7b}
\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class TypeOfVer, class TypeOfEdge\textgreater{}}
\NormalTok{class graph}
\NormalTok{\{}
\NormalTok{  public:}
\NormalTok{    virtual void insert(TypeOfVer x, TypeOfVer y, TypeOfEdge w) = 0;}
\NormalTok{    virtual void remove(TypeOfVer x, TypeOfVer y) = 0;}
\NormalTok{    virtual bool exist(TypeOfVer x, TypeOfVer y) const = 0;}
\NormalTok{    int numOfVer() const}
\NormalTok{    \{}
\NormalTok{      return Vers;}
\NormalTok{    \}}
\NormalTok{    int numOfEdge() const}
\NormalTok{    \{}
\NormalTok{      return Edges;}
\NormalTok{    \}}
 
\NormalTok{  protected:}
\NormalTok{    int Vers, Edges;}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}
\end{block}

\begin{block}{图的存储}
\protect\phantomsection\label{ux56feux7684ux5b58ux50a8}
\begin{block}{邻接矩阵和加权邻接矩阵}
\protect\phantomsection\label{ux90bbux63a5ux77e9ux9635ux548cux52a0ux6743ux90bbux63a5ux77e9ux9635}
\begin{block}{有向图的邻接矩阵}
\protect\phantomsection\label{ux6709ux5411ux56feux7684ux90bbux63a5ux77e9ux9635}
设有向图有 {} 个顶点，则用一个 {} 的布尔矩阵 {} 来表示该有向图


\begin{itemize}
\tightlist
\item
  分别使用 {} 表示 顶点 {}，如果存在一条从 {} 到 {} 的边，则 {}，否则 {}
\item
  出度：{} 行之和
\item
  入度：{} 列之和
\item
  真正的顶点数据字段之值放入一个一维数组之中
\end{itemize}
\end{block}

\begin{block}{无向图的邻接矩阵}
\protect\phantomsection\label{ux65e0ux5411ux56feux7684ux90bbux63a5ux77e9ux9635}
设无向图有 {} 个顶点，则用一个 {} 的布尔矩阵 {} 来表示该无向图


\begin{itemize}
\tightlist
\item
  分别使用 {} 表示 顶点 {}，如果存在一条从 {} 到 {} 的边，则 {}，否则 {}
\item
  顶点 {} 的度：第 {} 行或第 {} 列之和
\item
  无向图的邻接矩阵是一个三角对称矩阵
\end{itemize}
\end{block}

\begin{block}{邻接矩阵的特点}
\protect\phantomsection\label{ux90bbux63a5ux77e9ux9635ux7684ux7279ux70b9}
\begin{itemize}
\tightlist
\item
  优点：判断任意两点之间是否有边方便，仅耗费 {} 时间
\item
  缺点：即使 {} 条边，也需内存 {} 单元，太多; 仅读入数据耗费 {}
  时间，太长。而大多数的图的边数远远小于 {}。\textbf{适合稠密网}
\item
  不适合增减顶点
\end{itemize}
\end{block}
\end{block}

\begin{block}{邻接表}
\protect\phantomsection\label{ux90bbux63a5ux8868}
\begin{itemize}
\item
  设有向图或者无向图由 {}
  个顶点，则用\textbf{顶点表}和\textbf{边表}来表示该有向图或无向图
\item
  \textbf{顶点表：} 用数组或单链表的形式存放所有的顶点

  \begin{itemize}
  \tightlist
  \item
    如果顶点数 {} 已知，则采用数组
  \item
    如果顶点数未知，则采用单链表
  \item
    每个元素包含两个部分

    \begin{itemize}
    \tightlist
    \item
      顶点值
    \item
      指向该顶点对应的边表的首地址
    \end{itemize}
  \end{itemize}
\item
  \textbf{边表：} 每条边用一个节点进行表示

  同一个顶点出发的所有的边形成它的边界点单链表
\end{itemize}

\end{block}

\begin{block}{邻接表的特点}
\protect\phantomsection\label{ux90bbux63a5ux8868ux7684ux7279ux70b9}
\begin{itemize}
\tightlist
\item
  邻接表是图的\textbf{标准}存储方式
\item
  优点

  \begin{itemize}
  \tightlist
  \item
    {内存顶点数边数}，时间复杂度为 {}，\textbf{适合稀疏网}
  \end{itemize}
\item
  当谈及图的线性算法时，一般指的是 {}
\item
  缺点

  \begin{itemize}
  \tightlist
  \item
    确定 {} 是否有边，最坏需耗费 {} 时间
  \item
    无向图同一条边表示两次。边表空间浪费一倍
  \item
    有向图中寻找进入某结点的边，非常困难（逆邻接表）
  \end{itemize}
\end{itemize}
\end{block}
\end{block}

\begin{block}{图的遍历}
\protect\phantomsection\label{ux56feux7684ux904dux5386}
按照某种次序系统地访问图中的所有顶点，并且使得\textbf{每个顶点需且只能被访问一次}

需对访问过的顶点加以\textbf{标记}

\begin{block}{深度优先搜索}
\protect\phantomsection\label{ux6df1ux5ea6ux4f18ux5148ux641cux7d22}
\begin{enumerate}
\tightlist
\item
  选中第一个被访问的顶点
\item
  对顶点作已访问过的标志
\item
  依次从顶点的未被访问过的第一个、第二个、第三个\ldots\ldots 邻接顶点出发，进行深度优先搜索
\end{enumerate}

出现了问题

\begin{block}{存在的问题}
\protect\phantomsection\label{ux5b58ux5728ux7684ux95eeux9898}
\protect\phantomsection\label{DFSdamn}{如果图不是连通或强连通，在进行
DFS 时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点}
\end{block}

\begin{block}{深度优先生成森林}
\protect\phantomsection\label{ux6df1ux5ea6ux4f18ux5148ux751fux6210ux68eeux6797}
在这种情况下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止

此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成\textbf{森林}

所以将深度优先搜索的流程改为

\begin{enumerate}
\tightlist
\item
  选中第一个被访问的顶点
\item
  对顶点作已访问过的标志
\item
  依次从顶点的未被访问过的第一个、第二个、第三个\ldots\ldots 邻接顶点出发，进行深度优先搜索
\item
  如果还有顶点未被访问，则选中一个起始顶点，转向2
\item
  所有的顶点都被访问到，则结束
\end{enumerate}
\end{block}

\begin{block}{深度优先搜索的实现}
\protect\phantomsection\label{ux6df1ux5ea6ux4f18ux5148ux641cux7d22ux7684ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  公有的 \texttt{dfs} 函数的伪代码
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{void dfs()}
\NormalTok{\{}
\NormalTok{  visited [v] =false; //对每个节点标记为未访问}

\NormalTok{  while(v=尚未访问的节点)}
\NormalTok{  \{}
\NormalTok{    dfs(v,visited);}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  私有的 \texttt{dfs} 函数的伪代码
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{void dfs(v,visited)}
\NormalTok{\{}
\NormalTok{  visited(v)=true;}
\NormalTok{  for 每个 v 的邻接点 w}
\NormalTok{  \{}
\NormalTok{    if(!visited[w])}
\NormalTok{    \{}
\NormalTok{      dfs(w,visited);}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}

\begin{block}{广度优先搜索}
\protect\phantomsection\label{ux5e7fux5ea6ux4f18ux5148ux641cux7d22}
\begin{enumerate}
\tightlist
\item
  选中第一个被访问的顶点
\item
  对顶点作已访问过的标志
\item
  依次访问已访问顶点的未被访问过的第 {} 个、第 {} 个、第 {} 个、{} 、第
  {} 个邻接顶点 {} ，进行访问且进行标记，转向3
\item
  如果还有顶点未被访问，则选中一个起始顶点，转向2
\item
  所有的顶点都被访问到，则结束
\end{enumerate}

按照顶点序号小的先访问，大的后访问的原则以\textbf{队列}的形式实现

同样能够生成广度优先生成森林

\begin{block}{广度优先搜索的实现}
\protect\phantomsection\label{ux5e7fux5ea6ux4f18ux5148ux641cux7d22ux7684ux5b9eux73b0}
\begin{enumerate}
\tightlist
\item
  将序号最小的顶点放入队列
\item
  重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问

  \begin{itemize}
  \tightlist
  \item
    如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队
  \end{itemize}
\item
  检查是否还有顶点未被访问。如果有，重复上述两个步骤
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class TypeOfVer, class TypeOfEdge\textgreater{}}
\NormalTok{void adjListGraph\textless{}TypeOfVer, TypeOfEdge\textgreater{}::bfs() const}
\NormalTok{\{}
\NormalTok{  bool *visited = new bool[Vers];}
\NormalTok{  int currentNode;}
\NormalTok{  linkQueue\textless{}int\textgreater{} q;}
\NormalTok{  edgeNode *p; }
\NormalTok{  for (int i=0; i \textless{} Vers; ++i)}
\NormalTok{  \{}
\NormalTok{   visited[i] = false;}
\NormalTok{  \}}
\NormalTok{  cout \textless{}\textless{} "当前图的广度优先遍历序列为："\textless{}\textless{} endl;}
\NormalTok{  for (i = 0; i \textless{} Vers; ++i)}
\NormalTok{  \{}
\NormalTok{    if (visited[i] == true)}
\NormalTok{    \{}
\NormalTok{      continue;}
\NormalTok{    \}}
\NormalTok{    while (!q.isEmpty()) //连续访问队列的队头，将其拉出，若其后继非空则拉入队列}
\NormalTok{    \{}
\NormalTok{      currentNode = q.deQueue();}
\NormalTok{      if (visited[currentNode] == true)}
\NormalTok{      \{}
\NormalTok{        continue;}
\NormalTok{      \}}
\NormalTok{      cout \textless{}\textless{} verList[currentNode].ver \textless{}\textless{}\textquotesingle{}\textbackslash{}t\textquotesingle{};}
\NormalTok{      visited[currentNode] = true;}
\NormalTok{      p = verList[currentNode].head;}
\NormalTok{      while (p != NULL)}
\NormalTok{      \{}
\NormalTok{        if (visited[p{-}\textgreater{}end] == false)}
\NormalTok{        q.enQueue(p{-}\textgreater{}end);}
\NormalTok{        p = p{-}\textgreater{}next;}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{    cout \textless{}\textless{} endl;}
\NormalTok{  \}}
\NormalTok{\} }
\end{Highlighting}
\end{Shaded}
\end{block}
\end{block}
\end{block}

\begin{block}{图遍历的应用}
\protect\phantomsection\label{ux56feux904dux5386ux7684ux5e94ux7528}
\begin{block}{无向图的连通性}
\protect\phantomsection\label{ux65e0ux5411ux56feux7684ux8fdeux901aux6027-1}
\begin{itemize}
\tightlist
\item
  如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先\textbf{生成树}
\item
  如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先\textbf{生成森林}。每棵树就是一个\textbf{连通分量}。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量
\item
  在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量
\end{itemize}
\end{block}

\begin{block}{有向图的连通性}
\protect\phantomsection\label{ux6709ux5411ux56feux7684ux8fdeux901aux6027-1}
\begin{itemize}
\tightlist
\item
  对有向图，深度优先搜索可以\textbf{测试是否强连通}，并\textbf{找出所有强连通分量}

  \begin{enumerate}
  \tightlist
  \item
    从任意顶点开始\textbf{深度优先遍历} {}
  \item
    对森林中的每棵树进行\textbf{后序遍历}，并按遍历的顺序给每个顶点编号
  \item
    将 {} 的每条边逆向，形成 {}
  \item
    从编号\textbf{最大}的顶点开始\textbf{深度优先遍历
    {}}。得到的深度优先遍历森林的每棵树就是 {} 的强连通分量
  \end{enumerate}
\end{itemize}
\end{block}

\begin{block}{欧拉回路}
\protect\phantomsection\label{ux6b27ux62c9ux56deux8def}
\begin{itemize}
\tightlist
\item
  哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径
\end{itemize}


\begin{block}{欧拉的证明}
\protect\phantomsection\label{ux6b27ux62c9ux7684ux8bc1ux660e}
\begin{itemize}
\tightlist
\item
  如果都是偶数桥，从任意地方出发都能回到原点 \textbf{（欧拉回路）}
\item
  如果都是偶数桥，从任意地方出发都能回到原点 \textbf{（欧拉路径）}
\item
  如果有奇数桥的地方不止两个，满足要求的路径是找不到的
\end{itemize}
\end{block}

\begin{block}{查找欧拉回路的基本想法}
\protect\phantomsection\label{ux67e5ux627eux6b27ux62c9ux56deux8defux7684ux57faux672cux60f3ux6cd5}
\begin{itemize}
\tightlist
\item
  执行一次\textbf{不允许回溯}的 \texttt{DFS} ，也被称为一笔画问题
\item
  但是很多搜索都是不符合的
\end{itemize}
\end{block}

\begin{block}{解决方法}
\protect\phantomsection\label{ux89e3ux51b3ux65b9ux6cd5}
找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问

\end{block}
\end{block}

\begin{block}{拓扑排序}
\protect\phantomsection\label{ux62d3ux6251ux6392ux5e8f}
设 {} 是一个具有 {} 个顶点的\textbf{有向无环图}

若 {} 中的顶点序列 {} 满足下列条件

\begin{itemize}
\tightlist
\item
  在 {} 中，从 {} 到 {} 有一条路径
\item
  在序列中 {} 在 {} 之前
\end{itemize}

则称 {} 是 {} 的一个\textbf{拓扑排序}

拓扑排序将图转换为线性序，相对前去后继关系不变

\begin{block}{顶点活动网络（Activu on vertex network）}
\protect\phantomsection\label{ux9876ux70b9ux6d3bux52a8ux7f51ux7edcactivu-on-vertex-network}
\begin{itemize}
\tightlist
\item
  顶点表示各项子任务
\item
  有向边表示具有先决条件关系
\item
  仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施
\end{itemize}

\textbf{AOV}的特点

\begin{enumerate}
\tightlist
\item
  有起始顶点
\item
  无回路
\end{enumerate}
\end{block}

\begin{block}{找出拓扑排序的过程}
\protect\phantomsection\label{ux627eux51faux62d3ux6251ux6392ux5e8fux7684ux8fc7ux7a0b}
\begin{itemize}
\tightlist
\item
  第一个输出的顶点必须无前驱，即入度为 {}
\item
  无前驱以及后继的顶点在任何时候都可以输出
\item
  逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度
  {}
\end{itemize}
\end{block}

\begin{block}{拓扑排序的实现}
\protect\phantomsection\label{ux62d3ux6251ux6392ux5e8fux7684ux5b9eux73b0}
\begin{itemize}
\tightlist
\item
  计算每个顶点的入度，保存在数组 \texttt{inDegree} 中
\item
  检查 \texttt{inDegree} 中的每个元素，将入度为 {} 的顶点入队
\item
  不断从队列中将入度为 {} 的顶点入队，输出此顶点，并将该顶点的入度
  {}，如果某个邻接点的入度为 {}，则将其入队
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template \textless{}class TypeOfVer, class TypeOfEdge\textgreater{}}
\NormalTok{void adjListGraph\textless{}TypeOfVer, TypeOfEdge\textgreater{}::topSort() const}
\NormalTok{\{}
\NormalTok{  linkQueue\textless{}int\textgreater{} q;}
\NormalTok{  edgeNode *p;}
\NormalTok{  int current, *inDegree = new int[Vers];}
\NormalTok{  for (int i = 0; i \textless{} Vers; ++i)}
\NormalTok{  \{}
\NormalTok{    inDegree[i] = 0;}
\NormalTok{  \}}
\NormalTok{  for ( i = 0; i \textless{} Vers; ++i)}
\NormalTok{  \{}
\NormalTok{    for (p = verList[i].head; p != NULL; p = p{-}\textgreater{}next)}
\NormalTok{    \{}
\NormalTok{    ++inDegree[p{-}\textgreater{}end];}
\NormalTok{    \}}
\NormalTok{  \}                                                                 //计算入度}
\NormalTok{  for (i = 0; i \textless{} Vers; ++i)   if (inDegree[i] == 0) q.enQueue(i);  //入度0节点入队}
\NormalTok{  cout \textless{}\textless{} "拓扑排序为：" \textless{}\textless{} endl;}
\NormalTok{  while(!q.isEmpty())}
\NormalTok{  \{}
\NormalTok{    current = q.deQueue( );}
\NormalTok{    cout \textless{}\textless{} verList[current].ver \textless{}\textless{} \textquotesingle{}\textbackslash{}t\textquotesingle{};}
\NormalTok{    for (p = verList[current].head; p != NULL; p = p{-}\textgreater{}next)}
\NormalTok{    if( {-}{-}inDegree[p{-}\textgreater{}end] == 0 )    q.enQueue( p{-}\textgreater{}end );}
\NormalTok{  \}                                                                 //出队，删除关联的边}
\NormalTok{  cout \textless{}\textless{} endl;}
\NormalTok{\} }
\end{Highlighting}
\end{Shaded}

\textbf{时间复杂度：}

\begin{itemize}
\tightlist
\item
  若图以邻接表表示
\item
  计算入度的时间复杂度为 {}，搜索入度为 {} 的顶点的时间复杂度为
  {}，出队和删除边的时间复杂度为 {}，总执行时间为 {}
\end{itemize}
\end{block}
\end{block}

\begin{block}{关键路径}
\protect\phantomsection\label{ux5173ux952eux8defux5f84}
\begin{block}{边活动网络（Activity on Edge）}
\protect\phantomsection\label{ux8fb9ux6d3bux52a8ux7f51ux7edcactivity-on-edge}
\begin{itemize}
\tightlist
\item
  \textbf{AOE网络：} 加权有向无环图

  \begin{itemize}
  \tightlist
  \item
    顶点表示事件，边表示活动
  \item
    有向边的权值表示活动的持续时间
  \item
    有向边的方向表示事件发生的先后次序
  \item
    顶点的进入表示事件发生后允许开始的活动
  \item
    有一个源点、一个终点
  \end{itemize}
\end{itemize}
\end{block}

\begin{block}{关键路径的定义}
\protect\phantomsection\label{ux5173ux952eux8defux5f84ux7684ux5b9aux4e49}
AOE 网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序

再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动
\end{block}
\end{block}
\end{block}
\end{block}
\end{frame}

\end{document}
